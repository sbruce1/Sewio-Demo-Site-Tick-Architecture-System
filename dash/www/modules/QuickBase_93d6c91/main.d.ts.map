{"version":3,"sources":["lib/jsbn.ts","lib/tools.ts","classes/RTTI.ts","lib/pivot.ts","lib/dash-client-lib.ts","classes/log.ts","lib/delta-client-base.ts","lib/liteOp.ts","lib/c.ts","lib/delta-client-lib.ts","lib/error-tooltip.ts","lib/genericTooltip.ts","lib/helpers.ts","classes/quickbase.ts","lib/cClasses.ts","lib/long.ts","lib/ipc/TypeBase.ts","lib/ipc/Vector.ts","lib/ipc/U8.ts","lib/ipc/Boolean.ts","lib/ipc/Byte.ts","lib/ipc/I64.ts","lib/ipc/Char.ts","lib/ipc/I32.ts","lib/ipc/Constants.ts","lib/ipc/QDate.ts","lib/ipc/F64.ts","lib/ipc/DateTime.ts","lib/ipc/Dict.ts","lib/ipc/Double.ts","lib/ipc/Float.ts","lib/ipc/Int.ts","lib/spark-md5.ts","lib/ipc/List.ts","lib/ipc/QLong.ts","lib/ipc/Minute.ts","lib/ipc/Month.ts","lib/ipc/Second.ts","lib/ipc/Short.ts","lib/ipc/Symbol.ts","lib/ipc/QString.ts","lib/ipc/Time.ts","lib/ipc/Timespan.ts","lib/ipc/Timestamp.ts","lib/ipc/Util.ts","classes/removeObsoleteWidgets.ts","lib/backbone-deep-model.ts","lib/diff.ts","classes/commonDefinitions.ts","models/ICommandable.ts","models/component.ts","models/componentDefinition.ts","models/connection.ts","models/connectionGroup.ts","models/service.ts","models/layout.ts","models/widget.ts","lib/ipc/Guid.ts","lib/ipc/Unary.ts","lib/ipc/Table.ts","lib/ipc/Parse.ts","lib/dashClient.ts","classes/PerformanceMetrics.ts","classes/Agent.ts","classes/ChangeSetInterface.ts","classes/DataModelInterface.ts","classes/ViewModelInterface.ts","classes/ComponentInterface.ts","classes/DataMapper.ts","classes/ColumnInfo.ts","classes/ChangeSet.ts","classes/DataSet.ts","classes/DataSet2.ts","classes/LegacyUpdate.ts","classes/viewStateBinding.ts","lib/qb/Interfaces.ts","lib/qb/RuleModel.ts","lib/qb/GroupModel.ts","lib/qb/DataFilter.ts","lib/qb/GraphNode.ts","lib/qb/DataNode.ts","lib/qb/FilterNode.ts","lib/qb/GroupByNode.ts","lib/qb/JoinNode.ts","lib/qb/ResultNode.ts","lib/qb/UpdateNode.ts","lib/qb/QueryBuilder.ts","models/documentDataModel.ts","models/documentViewModel.ts","models/screen.ts","models/popup.ts","models/document.ts","viewModels/app.ts","templates/combined.ts","views/AboutDialog.ts","views/Accordion.ts","classes/CustomEvents.ts","classes/DocumentGraph.ts","classes/DatasourceNotifications.ts","classes/NotificationManager.ts","classes/ComponentApi.ts","views/AppView.ts","views/DialogBase.ts","views/AreYouSureDialog.ts","views/ChangePasswordDialog.ts","views/ConfirmDialog.ts","views/ComponentView.ts","views/ComponentDropView.ts","views/DocumentSelector.ts","views/DocumentView.ts","views/LoginDialog.ts","views/HeuristicHelpers.ts","views/HelpDialog.ts","views/ProfileMenu.ts","views/PopupView.ts","export/RawDataFormatter.ts","export/FileExportDataGenerator.ts","views/SimpleInputDialog.ts","export/FileExport.ts","views/ErrorDialog.ts","export/fileExporterView.ts","export/ExportTools.ts","views/app.ts","lib/jquery.cookie.ts"],"names":[],"mappings":"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","file":"main.d.ts","sourcesContent":["// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n\n// Basic JavaScript BN library - subset useful for RSA encryption.\nvar jsbn = (function () {\n    // Bits per digit\n    var dbits;\n\n    // JavaScript engine analysis\n    var canary = 0xdeadbeefcafe;\n    var j_lm = ((canary & 0xffffff) == 0xefcafe);\n\n    // (public) Constructor\n    function BigInteger(a, b?, c?) {\n        if (a != null)\n            if (\"number\" == typeof a) this.fromNumber(a, b, c);\n            else if (b == null && \"string\" != typeof a) this.fromBytes(a);\n            else this.fromString(a, b);\n    }\n\n    // return new, unset BigInteger\n    function nbi() { return new BigInteger(null); }\n\n    // am: Compute w_j += (x*this_i), propagate carries,\n    // c is initial carry, returns final carry.\n    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n    // We need to select the fastest one that works in this environment.\n\n    // am1: use a single mult and divide to get the high bits,\n    // max digit bits should be 26 because\n    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n    function am1(i, x, w, j, c, n) {\n        while (--n >= 0) {\n            var v = x * this[i++] + w[j] + c;\n            c = Math.floor(v / 0x4000000);\n            w[j++] = v & 0x3ffffff;\n        }\n        return c;\n    }\n    // am2 avoids a big mult-and-extract completely.\n    // Max digit bits should be <= 30 because we do bitwise ops\n    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n    function am2(i, x, w, j, c, n) {\n        var xl = x & 0x7fff, xh = x >> 15;\n        while (--n >= 0) {\n            var l = this[i] & 0x7fff;\n            var h = this[i++] >> 15;\n            var m = xh * l + h * xl;\n            l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n            c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n            w[j++] = l & 0x3fffffff;\n        }\n        return c;\n    }\n    // Alternately, set max digit bits to 28 since some\n    // browsers slow down when dealing with 32-bit numbers.\n    function am3(i, x, w, j, c, n) {\n        var xl = x & 0x3fff, xh = x >> 14;\n        while (--n >= 0) {\n            var l = this[i] & 0x3fff;\n            var h = this[i++] >> 14;\n            var m = xh * l + h * xl;\n            l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n            c = (l >> 28) + (m >> 14) + xh * h;\n            w[j++] = l & 0xfffffff;\n        }\n        return c;\n    }\n    if (j_lm && (navigator.appName == \"Microsoft Internet Explorer\")) {\n        BigInteger.prototype.am = am2;\n        dbits = 30;\n    }\n    else if (j_lm && (navigator.appName != \"Netscape\")) {\n        BigInteger.prototype.am = am1;\n        dbits = 26;\n    }\n    else { // Mozilla/Netscape seems to prefer am3\n        BigInteger.prototype.am = am3;\n        dbits = 28;\n    }\n\n    BigInteger.prototype.DB = dbits;\n    BigInteger.prototype.DM = ((1 << dbits) - 1);\n    BigInteger.prototype.DV = (1 << dbits);\n\n    var BI_FP = 52;\n    BigInteger.prototype.FV = Math.pow(2, BI_FP);\n    BigInteger.prototype.F1 = BI_FP - dbits;\n    BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n\n    // Digit conversions\n    var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n    var BI_RC = new Array();\n    var rr, vv;\n    rr = \"0\".charCodeAt(0);\n    for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n    rr = \"a\".charCodeAt(0);\n    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n    rr = \"A\".charCodeAt(0);\n    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n    function int2char(n) { return BI_RM.charAt(n); }\n    function intAt(s, i) {\n        var c = BI_RC[s.charCodeAt(i)];\n        return (c == null) ? -1 : c;\n    }\n\n    // (protected) copy this to r\n    function bnpCopyTo(r) {\n        for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n        r.t = this.t;\n        r.s = this.s;\n    }\n\n    // (protected) set from integer value x, -DV <= x < DV\n    function bnpFromInt(x) {\n        this.t = 1;\n        this.s = (x < 0) ? -1 : 0;\n        if (x > 0) this[0] = x;\n        else if (x < -1) this[0] = x + this.DV;\n        else this.t = 0;\n    }\n\n    // return bigint initialized to value\n    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n    // (protected) set from string and radix\n\n    function bnpFromBytes(s) {\n        this.t = 0;\n        this.s = 0;\n        var i = -1, mi = false, sh = 0;\n        while (++i < s.length) {\n            var x = s[i] & 0xff;\n            if (sh == 0)\n                this[this.t++] = x;\n            else if (sh + 8 > this.DB) {\n                this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n                this[this.t++] = (x >> (this.DB - sh));\n            }\n            else\n                this[this.t - 1] |= x << sh;\n            sh += 8;\n            if (sh >= this.DB) sh -= this.DB;\n        }\n        if ((s[s.length - 1] & 0x80) != 0) {\n            this.s = -1;\n            if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n        }\n        this.clamp();\n    }\n\n    function bnpFromString(s, b) {\n        var k;\n        if (b == 16) k = 4;\n        else if (b == 8) k = 3;\n        else if (b == 256) k = 8; // byte array\n        else if (b == 2) k = 1;\n        else if (b == 32) k = 5;\n        else if (b == 4) k = 2;\n        else { this.fromRadix(s, b); return; }\n        this.t = 0;\n        this.s = 0;\n        var i = s.length, mi = false, sh = 0;\n        while (--i >= 0) {\n            var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n            if (x < 0) {\n                if (s.charAt(i) == \"-\") mi = true;\n                continue;\n            }\n            mi = false;\n            if (sh == 0)\n                this[this.t++] = x;\n            else if (sh + k > this.DB) {\n                this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n                this[this.t++] = (x >> (this.DB - sh));\n            }\n            else\n                this[this.t - 1] |= x << sh;\n            sh += k;\n            if (sh >= this.DB) sh -= this.DB;\n        }\n        if (k == 8 && (s[0] & 0x80) != 0) {\n            this.s = -1;\n            if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n        }\n        this.clamp();\n        if (mi) BigInteger.ZERO.subTo(this, this);\n    }\n\n    // (protected) clamp off excess high words\n    function bnpClamp() {\n        var c = this.s & this.DM;\n        while (this.t > 0 && this[this.t - 1] == c)--this.t;\n    }\n\n    // (public) return string representation in given radix\n    function bnToString(b) {\n        if (this.s < 0) return \"-\" + this.negate().toString(b);\n        var k;\n        if (b == 16) k = 4;\n        else if (b == 8) k = 3;\n        else if (b == 2) k = 1;\n        else if (b == 32) k = 5;\n        else if (b == 4) k = 2;\n        else return this.toRadix(b);\n        var km = (1 << k) - 1, d, m = false, r = \"\", i = this.t;\n        var p = this.DB - (i * this.DB) % k;\n        if (i-- > 0) {\n            if (p < this.DB && (d = this[i] >> p) > 0) { m = true; r = int2char(d); }\n            while (i >= 0) {\n                if (p < k) {\n                    d = (this[i] & ((1 << p) - 1)) << (k - p);\n                    d |= this[--i] >> (p += this.DB - k);\n                }\n                else {\n                    d = (this[i] >> (p -= k)) & km;\n                    if (p <= 0) { p += this.DB; --i; }\n                }\n                if (d > 0) m = true;\n                if (m) r += int2char(d);\n            }\n        }\n        return m ? r : \"0\";\n    }\n\n    // (public) -this\n    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this, r); return r; }\n\n    // (public) |this|\n    function bnAbs() { return (this.s < 0) ? this.negate() : this; }\n\n    // (public) return + if this > a, - if this < a, 0 if equal\n    function bnCompareTo(a) {\n        var r = this.s - a.s;\n        if (r != 0) return r;\n        var i = this.t;\n        r = i - a.t;\n        if (r != 0) return (this.s < 0) ? -r : r;\n        while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;\n        return 0;\n    }\n\n    // returns bit length of the integer x\n    function nbits(x) {\n        var r = 1, t;\n        if ((t = x >>> 16) != 0) { x = t; r += 16; }\n        if ((t = x >> 8) != 0) { x = t; r += 8; }\n        if ((t = x >> 4) != 0) { x = t; r += 4; }\n        if ((t = x >> 2) != 0) { x = t; r += 2; }\n        if ((t = x >> 1) != 0) { x = t; r += 1; }\n        return r;\n    }\n\n    // (public) return the number of bits in \"this\"\n    function bnBitLength() {\n        if (this.t <= 0) return 0;\n        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n    }\n\n    // (protected) r = this << n*DB\n    function bnpDLShiftTo(n, r) {\n        var i;\n        for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n        for (i = n - 1; i >= 0; --i) r[i] = 0;\n        r.t = this.t + n;\n        r.s = this.s;\n    }\n\n    // (protected) r = this >> n*DB\n    function bnpDRShiftTo(n, r) {\n        for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n        r.t = Math.max(this.t - n, 0);\n        r.s = this.s;\n    }\n\n    // (protected) r = this << n\n    function bnpLShiftTo(n, r) {\n        var bs = n % this.DB;\n        var cbs = this.DB - bs;\n        var bm = (1 << cbs) - 1;\n        var ds = Math.floor(n / this.DB), c = (this.s << bs) & this.DM, i;\n        for (i = this.t - 1; i >= 0; --i) {\n            r[i + ds + 1] = (this[i] >> cbs) | c;\n            c = (this[i] & bm) << bs;\n        }\n        for (i = ds - 1; i >= 0; --i) r[i] = 0;\n        r[ds] = c;\n        r.t = this.t + ds + 1;\n        r.s = this.s;\n        r.clamp();\n    }\n\n    // (protected) r = this >> n\n    function bnpRShiftTo(n, r) {\n        r.s = this.s;\n        var ds = Math.floor(n / this.DB);\n        if (ds >= this.t) { r.t = 0; return; }\n        var bs = n % this.DB;\n        var cbs = this.DB - bs;\n        var bm = (1 << bs) - 1;\n        r[0] = this[ds] >> bs;\n        for (var i = ds + 1; i < this.t; ++i) {\n            r[i - ds - 1] |= (this[i] & bm) << cbs;\n            r[i - ds] = this[i] >> bs;\n        }\n        if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n        r.t = this.t - ds;\n        r.clamp();\n    }\n\n    // (protected) r = this - a\n    function bnpSubTo(a, r) {\n        var i = 0, c = 0, m = Math.min(a.t, this.t);\n        while (i < m) {\n            c += this[i] - a[i];\n            r[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        if (a.t < this.t) {\n            c -= a.s;\n            while (i < this.t) {\n                c += this[i];\n                r[i++] = c & this.DM;\n                c >>= this.DB;\n            }\n            c += this.s;\n        }\n        else {\n            c += this.s;\n            while (i < a.t) {\n                c -= a[i];\n                r[i++] = c & this.DM;\n                c >>= this.DB;\n            }\n            c -= a.s;\n        }\n        r.s = (c < 0) ? -1 : 0;\n        if (c < -1) r[i++] = this.DV + c;\n        else if (c > 0) r[i++] = c;\n        r.t = i;\n        r.clamp();\n    }\n\n    // (protected) r = this * a, r != this,a (HAC 14.12)\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyTo(a, r) {\n        var x = this.abs(), y = a.abs();\n        var i = x.t;\n        r.t = i + y.t;\n        while (--i >= 0) r[i] = 0;\n        for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n        r.s = 0;\n        r.clamp();\n        if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n    }\n\n    // (protected) r = this^2, r != this (HAC 14.16)\n    function bnpSquareTo(r) {\n        var x = this.abs();\n        var i = r.t = 2 * x.t;\n        while (--i >= 0) r[i] = 0;\n        for (i = 0; i < x.t - 1; ++i) {\n            var c = x.am(i, x[i], r, 2 * i, 0, 1);\n            if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {\n                r[i + x.t] -= x.DV;\n                r[i + x.t + 1] = 1;\n            }\n        }\n        if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n        r.s = 0;\n        r.clamp();\n    }\n\n    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n    // r != q, this != m.  q or r may be null.\n    function bnpDivRemTo(m, q, r) {\n        var pm = m.abs();\n        if (pm.t <= 0) return;\n        var pt = this.abs();\n        if (pt.t < pm.t) {\n            if (q != null) q.fromInt(0);\n            if (r != null) this.copyTo(r);\n            return;\n        }\n        if (r == null) r = nbi();\n        var y = nbi(), ts = this.s, ms = m.s;\n        var nsh = this.DB - nbits(pm[pm.t - 1]);\t// normalize modulus\n        if (nsh > 0) { pm.lShiftTo(nsh, y); pt.lShiftTo(nsh, r); }\n        else { pm.copyTo(y); pt.copyTo(r); }\n        var ys = y.t;\n        var y0 = y[ys - 1];\n        if (y0 == 0) return;\n        var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;\n        var i = r.t, j = i - ys, t = (q == null) ? nbi() : q;\n        y.dlShiftTo(j, t);\n        if (r.compareTo(t) >= 0) {\n            r[r.t++] = 1;\n            r.subTo(t, r);\n        }\n        BigInteger.ONE.dlShiftTo(ys, t);\n        t.subTo(y, y);\t// \"negative\" y so we can replace sub with am later\n        while (y.t < ys) y[y.t++] = 0;\n        while (--j >= 0) {\n            // Estimate quotient digit\n            var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n            if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {\t// Try it out\n                y.dlShiftTo(j, t);\n                r.subTo(t, r);\n                while (r[i] < --qd) r.subTo(t, r);\n            }\n        }\n        if (q != null) {\n            r.drShiftTo(ys, q);\n            if (ts != ms) BigInteger.ZERO.subTo(q, q);\n        }\n        r.t = ys;\n        r.clamp();\n        if (nsh > 0) r.rShiftTo(nsh, r);\t// Denormalize remainder\n        if (ts < 0) BigInteger.ZERO.subTo(r, r);\n    }\n\n    // (public) this mod a\n    function bnMod(a) {\n        var r = nbi();\n        this.abs().divRemTo(a, null, r);\n        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n        return r;\n    }\n\n    // Modular reduction using \"classic\" algorithm\n    function Classic(m) { this.m = m; }\n    function cConvert(x) {\n        if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n        else return x;\n    }\n    function cRevert(x) { return x; }\n    function cReduce(x) { x.divRemTo(this.m, null, x); }\n    function cMulTo(x, y, r) { x.multiplyTo(y, r); this.reduce(r); }\n    function cSqrTo(x, r) { x.squareTo(r); this.reduce(r); }\n\n    Classic.prototype.convert = cConvert;\n    Classic.prototype.revert = cRevert;\n    Classic.prototype.reduce = cReduce;\n    Classic.prototype.mulTo = cMulTo;\n    Classic.prototype.sqrTo = cSqrTo;\n\n    // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n    // justification:\n    //         xy == 1 (mod m)\n    //         xy =  1+km\n    //   xy(2-xy) = (1+km)(1-km)\n    // x[y(2-xy)] = 1-k^2m^2\n    // x[y(2-xy)] == 1 (mod m^2)\n    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n    // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n    function bnpInvDigit() {\n        if (this.t < 1) return 0;\n        var x = this[0];\n        if ((x & 1) == 0) return 0;\n        var y = x & 3;\t\t// y == 1/x mod 2^2\n        y = (y * (2 - (x & 0xf) * y)) & 0xf;\t// y == 1/x mod 2^4\n        y = (y * (2 - (x & 0xff) * y)) & 0xff;\t// y == 1/x mod 2^8\n        y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;\t// y == 1/x mod 2^16\n        // last step - calculate inverse mod DV directly;\n        // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n        y = (y * (2 - x * y % this.DV)) % this.DV;\t\t// y == 1/x mod 2^dbits\n        // we really want the negative inverse, and -DV < y < DV\n        return (y > 0) ? this.DV - y : -y;\n    }\n\n    // Montgomery reduction\n    function Montgomery(m) {\n        this.m = m;\n        this.mp = m.invDigit();\n        this.mpl = this.mp & 0x7fff;\n        this.mph = this.mp >> 15;\n        this.um = (1 << (m.DB - 15)) - 1;\n        this.mt2 = 2 * m.t;\n    }\n\n    // xR mod m\n    function montConvert(x) {\n        var r = nbi();\n        x.abs().dlShiftTo(this.m.t, r);\n        r.divRemTo(this.m, null, r);\n        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n        return r;\n    }\n\n    // x/R mod m\n    function montRevert(x) {\n        var r = nbi();\n        x.copyTo(r);\n        this.reduce(r);\n        return r;\n    }\n\n    // x = x/R mod m (HAC 14.32)\n    function montReduce(x) {\n        while (x.t <= this.mt2)\t// pad x so am has enough room later\n            x[x.t++] = 0;\n        for (var i = 0; i < this.m.t; ++i) {\n            // faster way of calculating u0 = x[i]*mp mod DV\n            var j = x[i] & 0x7fff;\n            var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n            // use am to combine the multiply-shift-add into one call\n            j = i + this.m.t;\n            x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n            // propagate carry\n            while (x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n        }\n        x.clamp();\n        x.drShiftTo(this.m.t, x);\n        if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n    }\n\n    // r = \"x^2/R mod m\"; x != r\n    function montSqrTo(x, r) { x.squareTo(r); this.reduce(r); }\n\n    // r = \"xy/R mod m\"; x,y != r\n    function montMulTo(x, y, r) { x.multiplyTo(y, r); this.reduce(r); }\n\n    Montgomery.prototype.convert = montConvert;\n    Montgomery.prototype.revert = montRevert;\n    Montgomery.prototype.reduce = montReduce;\n    Montgomery.prototype.mulTo = montMulTo;\n    Montgomery.prototype.sqrTo = montSqrTo;\n\n    // (protected) true iff this is even\n    function bnpIsEven() { return ((this.t > 0) ? (this[0] & 1) : this.s) == 0; }\n\n    // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n    function bnpExp(e, z) {\n        if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n        var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;\n        g.copyTo(r);\n        while (--i >= 0) {\n            z.sqrTo(r, r2);\n            if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n            else { var t = r; r = r2; r2 = t; }\n        }\n        return z.revert(r);\n    }\n\n    // (public) this^e % m, 0 <= e < 2^32\n    function bnModPowInt(e, m) {\n        var z;\n        if (e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n        return this.exp(e, z);\n    }\n\n    // protected\n    BigInteger.prototype.copyTo = bnpCopyTo;\n    BigInteger.prototype.fromInt = bnpFromInt;\n    BigInteger.prototype.fromString = bnpFromString;\n    BigInteger.prototype.fromBytes = bnpFromBytes\n    BigInteger.prototype.clamp = bnpClamp;\n    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n    BigInteger.prototype.lShiftTo = bnpLShiftTo;\n    BigInteger.prototype.rShiftTo = bnpRShiftTo;\n    BigInteger.prototype.subTo = bnpSubTo;\n    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n    BigInteger.prototype.squareTo = bnpSquareTo;\n    BigInteger.prototype.divRemTo = bnpDivRemTo;\n    BigInteger.prototype.invDigit = bnpInvDigit;\n    BigInteger.prototype.isEven = bnpIsEven;\n    BigInteger.prototype.exp = bnpExp;\n\n    // public\n    BigInteger.prototype.toString = bnToString;\n    BigInteger.prototype.negate = bnNegate;\n    BigInteger.prototype.abs = bnAbs;\n    BigInteger.prototype.compareTo = bnCompareTo;\n    BigInteger.prototype.bitLength = bnBitLength;\n    BigInteger.prototype.mod = bnMod;\n    BigInteger.prototype.modPowInt = bnModPowInt;\n\n    // \"constants\"\n    BigInteger.ZERO = nbv(0);\n    BigInteger.ONE = nbv(1);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    // Copyright (c) 2005-2009  Tom Wu\n    // All Rights Reserved.\n    // See \"LICENSE\" for details.\n\n    // Extended JavaScript BN functions, required for RSA private ops.\n\n    // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n    // Version 1.2: square() API, isProbablePrime fix\n\n    // (public)\n    function bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n    // (public) return value as integer\n    function bnIntValue() {\n        if (this.s < 0) {\n            if (this.t == 1) return this[0] - this.DV;\n            else if (this.t == 0) return -1;\n        }\n        else if (this.t == 1) return this[0];\n        else if (this.t == 0) return 0;\n        // assumes 16 < DB < 32\n        return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n    }\n\n    // (public) return value as byte\n    function bnByteValue() { return (this.t == 0) ? this.s : (this[0] << 24) >> 24; }\n\n    // (public) return value as short (assumes DB>=16)\n    function bnShortValue() { return (this.t == 0) ? this.s : (this[0] << 16) >> 16; }\n\n    // (protected) return x s.t. r^x < DV\n    function bnpChunkSize(r) { return Math.floor(Math.LN2 * this.DB / Math.log(r)); }\n\n    // (public) 0 if this == 0, 1 if this > 0\n    function bnSigNum() {\n        if (this.s < 0) return -1;\n        else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n        else return 1;\n    }\n\n    // (protected) convert to radix string\n    function bnpToRadix(b) {\n        if (b == null) b = 10;\n        if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n        var cs = this.chunkSize(b);\n        var a = Math.pow(b, cs);\n        var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\n        this.divRemTo(d, y, z);\n        while (y.signum() > 0) {\n            r = (a + z.intValue()).toString(b).substr(1) + r;\n            y.divRemTo(d, y, z);\n        }\n        return z.intValue().toString(b) + r;\n    }\n\n    // (protected) convert from radix string\n    function bnpFromRadix(s, b) {\n        this.fromInt(0);\n        if (b == null) b = 10;\n        var cs = this.chunkSize(b);\n        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;\n        for (var i = 0; i < s.length; ++i) {\n            var x = intAt(s, i);\n            if (x < 0) {\n                if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n                continue;\n            }\n            w = b * w + x;\n            if (++j >= cs) {\n                this.dMultiply(d);\n                this.dAddOffset(w, 0);\n                j = 0;\n                w = 0;\n            }\n        }\n        if (j > 0) {\n            this.dMultiply(Math.pow(b, j));\n            this.dAddOffset(w, 0);\n        }\n        if (mi) BigInteger.ZERO.subTo(this, this);\n    }\n\n    // (protected) alternate constructor\n    function bnpFromNumber(a, b, c) {\n        if (\"number\" == typeof b) {\n            // new BigInteger(int,int,RNG)\n            if (a < 2) this.fromInt(1);\n            else {\n                this.fromNumber(a, c);\n                if (!this.testBit(a - 1))\t// force MSB set\n                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n                if (this.isEven()) this.dAddOffset(1, 0); // force odd\n                while (!this.isProbablePrime(b)) {\n                    this.dAddOffset(2, 0);\n                    if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n                }\n            }\n        }\n        else {\n            // new BigInteger(int,RNG)\n            var x = new Array(), t = a & 7;\n            x.length = (a >> 3) + 1;\n            b.nextBytes(x);\n            if (t > 0) x[0] &= ((1 << t) - 1); else x[0] = 0;\n            this.fromString(x, 256);\n        }\n    }\n\n    // (public) convert to bigendian byte array\n    function bnToByteArray() {\n        var i = this.t, r = new Array();\n        r[0] = this.s;\n        var p = this.DB - (i * this.DB) % 8, d, k = 0;\n        if (i-- > 0) {\n            if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n                r[k++] = d | (this.s << (this.DB - p));\n            while (i >= 0) {\n                if (p < 8) {\n                    d = (this[i] & ((1 << p) - 1)) << (8 - p);\n                    d |= this[--i] >> (p += this.DB - 8);\n                }\n                else {\n                    d = (this[i] >> (p -= 8)) & 0xff;\n                    if (p <= 0) { p += this.DB; --i; }\n                }\n                if ((d & 0x80) != 0) d |= -256;\n                if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n                if (k > 0 || d != this.s) r[k++] = d;\n            }\n        }\n        return r;\n    }\n\n    function bnEquals(a) { return (this.compareTo(a) == 0); }\n    function bnMin(a) { return (this.compareTo(a) < 0) ? this : a; }\n    function bnMax(a) { return (this.compareTo(a) > 0) ? this : a; }\n\n    // (protected) r = this op a (bitwise)\n    function bnpBitwiseTo(a, op, r) {\n        var i, f, m = Math.min(a.t, this.t);\n        for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n        if (a.t < this.t) {\n            f = a.s & this.DM;\n            for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n            r.t = this.t;\n        }\n        else {\n            f = this.s & this.DM;\n            for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n            r.t = a.t;\n        }\n        r.s = op(this.s, a.s);\n        r.clamp();\n    }\n\n    // (public) this & a\n    function op_and(x, y) { return x & y; }\n    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a, op_and, r); return r; }\n\n    // (public) this | a\n    function op_or(x, y) { return x | y; }\n    function bnOr(a) { var r = nbi(); this.bitwiseTo(a, op_or, r); return r; }\n\n    // (public) this ^ a\n    function op_xor(x, y) { return x ^ y; }\n    function bnXor(a) { var r = nbi(); this.bitwiseTo(a, op_xor, r); return r; }\n\n    // (public) this & ~a\n    function op_andnot(x, y) { return x & ~y; }\n    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a, op_andnot, r); return r; }\n\n    // (public) ~this\n    function bnNot() {\n        var r = nbi();\n        for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n        r.t = this.t;\n        r.s = ~this.s;\n        return r;\n    }\n\n    // (public) this << n\n    function bnShiftLeft(n) {\n        var r = nbi();\n        if (n < 0) this.rShiftTo(-n, r); else this.lShiftTo(n, r);\n        return r;\n    }\n\n    // (public) this >> n\n    function bnShiftRight(n) {\n        var r = nbi();\n        if (n < 0) this.lShiftTo(-n, r); else this.rShiftTo(n, r);\n        return r;\n    }\n\n    // return index of lowest 1-bit in x, x < 2^31\n    function lbit(x) {\n        if (x == 0) return -1;\n        var r = 0;\n        if ((x & 0xffff) == 0) { x >>= 16; r += 16; }\n        if ((x & 0xff) == 0) { x >>= 8; r += 8; }\n        if ((x & 0xf) == 0) { x >>= 4; r += 4; }\n        if ((x & 3) == 0) { x >>= 2; r += 2; }\n        if ((x & 1) == 0)++r;\n        return r;\n    }\n\n    // (public) returns index of lowest 1-bit (or -1 if none)\n    function bnGetLowestSetBit() {\n        for (var i = 0; i < this.t; ++i)\n            if (this[i] != 0) return i * this.DB + lbit(this[i]);\n        if (this.s < 0) return this.t * this.DB;\n        return -1;\n    }\n\n    // return number of 1 bits in x\n    function cbit(x) {\n        var r = 0;\n        while (x != 0) { x &= x - 1; ++r; }\n        return r;\n    }\n\n    // (public) return number of set bits\n    function bnBitCount() {\n        var r = 0, x = this.s & this.DM;\n        for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n        return r;\n    }\n\n    // (public) true iff nth bit is set\n    function bnTestBit(n) {\n        var j = Math.floor(n / this.DB);\n        if (j >= this.t) return (this.s != 0);\n        return ((this[j] & (1 << (n % this.DB))) != 0);\n    }\n\n    // (protected) this op (1<<n)\n    function bnpChangeBit(n, op) {\n        var r = BigInteger.ONE.shiftLeft(n);\n        this.bitwiseTo(r, op, r);\n        return r;\n    }\n\n    // (public) this | (1<<n)\n    function bnSetBit(n) { return this.changeBit(n, op_or); }\n\n    // (public) this & ~(1<<n)\n    function bnClearBit(n) { return this.changeBit(n, op_andnot); }\n\n    // (public) this ^ (1<<n)\n    function bnFlipBit(n) { return this.changeBit(n, op_xor); }\n\n    // (protected) r = this + a\n    function bnpAddTo(a, r) {\n        var i = 0, c = 0, m = Math.min(a.t, this.t);\n        while (i < m) {\n            c += this[i] + a[i];\n            r[i++] = c & this.DM;\n            c >>= this.DB;\n        }\n        if (a.t < this.t) {\n            c += a.s;\n            while (i < this.t) {\n                c += this[i];\n                r[i++] = c & this.DM;\n                c >>= this.DB;\n            }\n            c += this.s;\n        }\n        else {\n            c += this.s;\n            while (i < a.t) {\n                c += a[i];\n                r[i++] = c & this.DM;\n                c >>= this.DB;\n            }\n            c += a.s;\n        }\n        r.s = (c < 0) ? -1 : 0;\n        if (c > 0) r[i++] = c;\n        else if (c < -1) r[i++] = this.DV + c;\n        r.t = i;\n        r.clamp();\n    }\n\n    // (public) this + a\n    function bnAdd(a) { var r = nbi(); this.addTo(a, r); return r; }\n\n    // (public) this - a\n    function bnSubtract(a) { var r = nbi(); this.subTo(a, r); return r; }\n\n    // (public) this * a\n    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a, r); return r; }\n\n    // (public) this^2\n    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n    // (public) this / a\n    function bnDivide(a) { var r = nbi(); this.divRemTo(a, r, null); return r; }\n\n    // (public) this % a\n    function bnRemainder(a) { var r = nbi(); this.divRemTo(a, null, r); return r; }\n\n    // (public) [this/a,this%a]\n    function bnDivideAndRemainder(a) {\n        var q = nbi(), r = nbi();\n        this.divRemTo(a, q, r);\n        return new Array(q, r);\n    }\n\n    // (protected) this *= n, this >= 0, 1 < n < DV\n    function bnpDMultiply(n) {\n        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n        ++this.t;\n        this.clamp();\n    }\n\n    // (protected) this += n << w words, this >= 0\n    function bnpDAddOffset(n, w) {\n        if (n == 0) return;\n        while (this.t <= w) this[this.t++] = 0;\n        this[w] += n;\n        while (this[w] >= this.DV) {\n            this[w] -= this.DV;\n            if (++w >= this.t) this[this.t++] = 0;\n            ++this[w];\n        }\n    }\n\n    // A \"null\" reducer\n    function NullExp() { }\n    function nNop(x) { return x; }\n    function nMulTo(x, y, r) { x.multiplyTo(y, r); }\n    function nSqrTo(x, r) { x.squareTo(r); }\n\n    NullExp.prototype.convert = nNop;\n    NullExp.prototype.revert = nNop;\n    NullExp.prototype.mulTo = nMulTo;\n    NullExp.prototype.sqrTo = nSqrTo;\n\n    // (public) this^e\n    function bnPow(e) { return this.exp(e, new NullExp()); }\n\n    // (protected) r = lower n words of \"this * a\", a.t <= n\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyLowerTo(a, n, r) {\n        var i = Math.min(this.t + a.t, n);\n        r.s = 0; // assumes a,this >= 0\n        r.t = i;\n        while (i > 0) r[--i] = 0;\n        var j;\n        for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n        for (j = Math.min(a.t, n) ; i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n        r.clamp();\n    }\n\n    // (protected) r = \"this * a\" without lower n words, n > 0\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyUpperTo(a, n, r) {\n        --n;\n        var i = r.t = this.t + a.t - n;\n        r.s = 0; // assumes a,this >= 0\n        while (--i >= 0) r[i] = 0;\n        for (i = Math.max(n - this.t, 0) ; i < a.t; ++i)\n            r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n        r.clamp();\n        r.drShiftTo(1, r);\n    }\n\n    // Barrett modular reduction\n    function Barrett(m) {\n        // setup Barrett\n        this.r2 = nbi();\n        this.q3 = nbi();\n        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n        this.mu = this.r2.divide(m);\n        this.m = m;\n    }\n\n    function barrettConvert(x) {\n        if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n        else if (x.compareTo(this.m) < 0) return x;\n        else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n    }\n\n    function barrettRevert(x) { return x; }\n\n    // x = x mod m (HAC 14.42)\n    function barrettReduce(x) {\n        x.drShiftTo(this.m.t - 1, this.r2);\n        if (x.t > this.m.t + 1) { x.t = this.m.t + 1; x.clamp(); }\n        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n        while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n        x.subTo(this.r2, x);\n        while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n    }\n\n    // r = x^2 mod m; x != r\n    function barrettSqrTo(x, r) { x.squareTo(r); this.reduce(r); }\n\n    // r = x*y mod m; x,y != r\n    function barrettMulTo(x, y, r) { x.multiplyTo(y, r); this.reduce(r); }\n\n    Barrett.prototype.convert = barrettConvert;\n    Barrett.prototype.revert = barrettRevert;\n    Barrett.prototype.reduce = barrettReduce;\n    Barrett.prototype.mulTo = barrettMulTo;\n    Barrett.prototype.sqrTo = barrettSqrTo;\n\n    // (public) this^e % m (HAC 14.85)\n    function bnModPow(e, m) {\n        var i = e.bitLength(), k, r = nbv(1), z;\n        if (i <= 0) return r;\n        else if (i < 18) k = 1;\n        else if (i < 48) k = 3;\n        else if (i < 144) k = 4;\n        else if (i < 768) k = 5;\n        else k = 6;\n        if (i < 8)\n            z = new Classic(m);\n        else if (m.isEven())\n            z = new Barrett(m);\n        else\n            z = new Montgomery(m);\n\n        // precomputation\n        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;\n        g[1] = z.convert(this);\n        if (k > 1) {\n            var g2 = nbi();\n            z.sqrTo(g[1], g2);\n            while (n <= km) {\n                g[n] = nbi();\n                z.mulTo(g2, g[n - 2], g[n]);\n                n += 2;\n            }\n        }\n\n        var j = e.t - 1, w, is1 = true, r2 = nbi(), t;\n        i = nbits(e[j]) - 1;\n        while (j >= 0) {\n            if (i >= k1) w = (e[j] >> (i - k1)) & km;\n            else {\n                w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n                if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n            }\n\n            n = k;\n            while ((w & 1) == 0) { w >>= 1; --n; }\n            if ((i -= n) < 0) { i += this.DB; --j; }\n            if (is1) {\t// ret == 1, don't bother squaring or multiplying it\n                g[w].copyTo(r);\n                is1 = false;\n            }\n            else {\n                while (n > 1) { z.sqrTo(r, r2); z.sqrTo(r2, r); n -= 2; }\n                if (n > 0) z.sqrTo(r, r2); else { t = r; r = r2; r2 = t; }\n                z.mulTo(r2, g[w], r);\n            }\n\n            while (j >= 0 && (e[j] & (1 << i)) == 0) {\n                z.sqrTo(r, r2); t = r; r = r2; r2 = t;\n                if (--i < 0) { i = this.DB - 1; --j; }\n            }\n        }\n        return z.revert(r);\n    }\n\n    // (public) gcd(this,a) (HAC 14.54)\n    function bnGCD(a) {\n        var x = (this.s < 0) ? this.negate() : this.clone();\n        var y = (a.s < 0) ? a.negate() : a.clone();\n        if (x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n        var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n        if (g < 0) return x;\n        if (i < g) g = i;\n        if (g > 0) {\n            x.rShiftTo(g, x);\n            y.rShiftTo(g, y);\n        }\n        while (x.signum() > 0) {\n            if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n            if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n            if (x.compareTo(y) >= 0) {\n                x.subTo(y, x);\n                x.rShiftTo(1, x);\n            }\n            else {\n                y.subTo(x, y);\n                y.rShiftTo(1, y);\n            }\n        }\n        if (g > 0) y.lShiftTo(g, y);\n        return y;\n    }\n\n    // (protected) this % n, n < 2^26\n    function bnpModInt(n) {\n        if (n <= 0) return 0;\n        var d = this.DV % n, r = (this.s < 0) ? n - 1 : 0;\n        if (this.t > 0)\n            if (d == 0) r = this[0] % n;\n            else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n        return r;\n    }\n\n    // (public) 1/this % m (HAC 14.61)\n    function bnModInverse(m) {\n        var ac = m.isEven();\n        if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n        var u = m.clone(), v = this.clone();\n        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n        while (u.signum() != 0) {\n            while (u.isEven()) {\n                u.rShiftTo(1, u);\n                if (ac) {\n                    if (!a.isEven() || !b.isEven()) { a.addTo(this, a); b.subTo(m, b); }\n                    a.rShiftTo(1, a);\n                }\n                else if (!b.isEven()) b.subTo(m, b);\n                b.rShiftTo(1, b);\n            }\n            while (v.isEven()) {\n                v.rShiftTo(1, v);\n                if (ac) {\n                    if (!c.isEven() || !d.isEven()) { c.addTo(this, c); d.subTo(m, d); }\n                    c.rShiftTo(1, c);\n                }\n                else if (!d.isEven()) d.subTo(m, d);\n                d.rShiftTo(1, d);\n            }\n            if (u.compareTo(v) >= 0) {\n                u.subTo(v, u);\n                if (ac) a.subTo(c, a);\n                b.subTo(d, b);\n            }\n            else {\n                v.subTo(u, v);\n                if (ac) c.subTo(a, c);\n                d.subTo(b, d);\n            }\n        }\n        if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n        if (d.compareTo(m) >= 0) return d.subtract(m);\n        if (d.signum() < 0) d.addTo(m, d); else return d;\n        if (d.signum() < 0) return d.add(m); else return d;\n    }\n\n    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n\n    // (public) test primality with certainty >= 1-.5^t\n    function bnIsProbablePrime(t) {\n        var i, x = this.abs();\n        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {\n            for (i = 0; i < lowprimes.length; ++i)\n                if (x[0] == lowprimes[i]) return true;\n            return false;\n        }\n        if (x.isEven()) return false;\n        i = 1;\n        while (i < lowprimes.length) {\n            var m = lowprimes[i], j = i + 1;\n            while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n            m = x.modInt(m);\n            while (i < j) if (m % lowprimes[i++] == 0) return false;\n        }\n        return x.millerRabin(t);\n    }\n\n    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n    function bnpMillerRabin(t) {\n        var n1 = this.subtract(BigInteger.ONE);\n        var k = n1.getLowestSetBit();\n        if (k <= 0) return false;\n        var r = n1.shiftRight(k);\n        t = (t + 1) >> 1;\n        if (t > lowprimes.length) t = lowprimes.length;\n        var a = nbi();\n        for (var i = 0; i < t; ++i) {\n            //Pick bases at random, instead of starting at 2\n            a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n            var y = a.modPow(r, this);\n            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n                var j = 1;\n                while (j++ < k && y.compareTo(n1) != 0) {\n                    y = y.modPowInt(2, this);\n                    if (y.compareTo(BigInteger.ONE) == 0) return false;\n                }\n                if (y.compareTo(n1) != 0) return false;\n            }\n        }\n        return true;\n    }\n\n    // protected\n    BigInteger.prototype.chunkSize = bnpChunkSize;\n    BigInteger.prototype.toRadix = bnpToRadix;\n    BigInteger.prototype.fromRadix = bnpFromRadix;\n    BigInteger.prototype.fromNumber = bnpFromNumber;\n    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n    BigInteger.prototype.changeBit = bnpChangeBit;\n    BigInteger.prototype.addTo = bnpAddTo;\n    BigInteger.prototype.dMultiply = bnpDMultiply;\n    BigInteger.prototype.dAddOffset = bnpDAddOffset;\n    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n    BigInteger.prototype.modInt = bnpModInt;\n    BigInteger.prototype.millerRabin = bnpMillerRabin;\n\n    // public\n    BigInteger.prototype.clone = bnClone;\n    BigInteger.prototype.intValue = bnIntValue;\n    BigInteger.prototype.byteValue = bnByteValue;\n    BigInteger.prototype.shortValue = bnShortValue;\n    BigInteger.prototype.signum = bnSigNum;\n    BigInteger.prototype.toByteArray = bnToByteArray;\n    BigInteger.prototype.equals = bnEquals;\n    BigInteger.prototype.min = bnMin;\n    BigInteger.prototype.max = bnMax;\n    BigInteger.prototype.and = bnAnd;\n    BigInteger.prototype.or = bnOr;\n    BigInteger.prototype.xor = bnXor;\n    BigInteger.prototype.andNot = bnAndNot;\n    BigInteger.prototype.not = bnNot;\n    BigInteger.prototype.shiftLeft = bnShiftLeft;\n    BigInteger.prototype.shiftRight = bnShiftRight;\n    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n    BigInteger.prototype.bitCount = bnBitCount;\n    BigInteger.prototype.testBit = bnTestBit;\n    BigInteger.prototype.setBit = bnSetBit;\n    BigInteger.prototype.clearBit = bnClearBit;\n    BigInteger.prototype.flipBit = bnFlipBit;\n    BigInteger.prototype.add = bnAdd;\n    BigInteger.prototype.subtract = bnSubtract;\n    BigInteger.prototype.multiply = bnMultiply;\n    BigInteger.prototype.divide = bnDivide;\n    BigInteger.prototype.remainder = bnRemainder;\n    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n    BigInteger.prototype.modPow = bnModPow;\n    BigInteger.prototype.modInverse = bnModInverse;\n    BigInteger.prototype.pow = bnPow;\n    BigInteger.prototype.gcd = bnGCD;\n    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n    // JSBN-specific extension\n    BigInteger.prototype.square = bnSquare;\n\n    // BigInteger interfaces not implemented in jsbn:\n\n    // BigInteger(int signum, byte[] magnitude)\n    // double doubleValue()\n    // float floatValue()\n    // int hashCode()\n    // long longValue()\n    // static BigInteger valueOf(long val)\n\n    return {\n        BigInteger: BigInteger\n    };\n})();","/// <reference path=\"../lib/jsbn.ts\" />\n\n// Object.assign PolyFill for IE\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nif (typeof Object.assign !== \"function\") {\n    // Must be writable: true, enumerable: false, configurable: true\n    Object.defineProperty(Object, \"assign\", {\n        value: function assign(target, varArgs) {\n            // .length of function is 2\n            \"use strict\";\n            if (target == null) {\n                // TypeError if undefined or null\n                throw new TypeError(\"Cannot convert undefined or null to object\");\n            }\n\n            const to = Object(target);\n\n            for (let index = 1; index < arguments.length; index++) {\n                const nextSource = arguments[index];\n\n                if (nextSource != null) {\n                    // Skip over if undefined or null\n                    for (const nextKey in nextSource) {\n                        // Avoid bugs when hasOwnProperty is shadowed\n                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                            to[nextKey] = nextSource[nextKey];\n                        }\n                    }\n                }\n            }\n            return to;\n        },\n        writable: true,\n        configurable: true,\n    });\n}\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class Tools {\n        public static isIE11 = /Trident\\/.*rv:11/.test(navigator.userAgent);\n\n        static timezone =\n            (function getCookie(cname) {\n                const name = cname + \"=\";\n                const ca = document.cookie.split(\";\");\n                for (let i = 0; i < ca.length; i++) {\n                    let c = ca[i];\n                    while (c.charAt(0) == \" \") {\n                        c = c.substring(1);\n                    }\n                    if (c.indexOf(name) == 0) {\n                        return decodeURIComponent(c.substring(name.length, c.length));\n                    }\n                }\n                return \"\";\n            })(\"dashboard-timezone\") || moment.tz.guess();\n\n        static Formats = {\n            Date: [\n                \"YYYY-MM-DD\",\n                \"DD/MM/YYYY\",\n                \"DD.MM.YYYY\",\n                \"MM/DD/YYYY\",\n                \"D/M/YYYY\",\n                \"M/D/YYYY\",\n                \"D/M/YY\",\n                \"M/D/YY\",\n                \"YYYY-MMM-DD\",\n                \"D MMM\",\n                \"D MMM YYYY\",\n                \"MMM D\",\n                \"MMM D, YYYY\",\n                //for kdb month type\n                \"YYYY-MM\",\n                \"MM/YYYY\",\n                \"M/YY\",\n                \"MMM YYYY\",\n            ],\n\n            DateTime: [\n                \"YYYY-MM-DD HH:mm:ss\",\n                \"YYYY-MM-DD HH:mm:ss.SSS\",\n                \"YYYY-MM-DD HH:mm:ss.SSSSSS\",\n                \"YYYY-MM-DD HH:mm:ss.SSSSSSSSS\",\n                \"YYYY-MM-DD\",\n                \"MM/DD/YYYY\",\n                \"D/M/YYYY\",\n                \"M/D/YYYY\",\n                \"D/M/YY\",\n                \"M/D/YY\",\n                \"YYYY-MMM-DD\",\n                \"D MMM\",\n                \"D MMM YYYY\",\n                \"MMM D\",\n                \"MMM D, YYYY\",\n                \"HH:mm\",\n                \"HH:mm:ss\",\n                \"HH:mm:ss.SSS\",\n                \"HH:mm:ss.SSSSSS\",\n                \"HH:mm:ss.SSSSSSSSS\",\n                \"mm:ss\",\n                \"mm:ss.SSS\",\n                \"mm:ss.SSSSSS\",\n                \"mm:ss.SSSSSSSSS\",\n                \"ss\",\n                \"ss.SSS\",\n                \"ss.SSSSSS\",\n                \"ss.SSSSSSSSS\",\n            ],\n\n            Time: [\n                \"HH:mm\",\n                \"HH:mm:ss\",\n                \"HH:mm:ss.SSS\",\n                \"HH:mm:ss.SSSSSS\",\n                \"HH:mm:ss.SSSSSSSSS\",\n                \"mm:ss\",\n                \"mm:ss.SSS\",\n                \"ss\",\n                \"ss.SSS\",\n            ],\n        };\n\n        static TIME_RX = /^((\\d\\d\\d\\d-\\d\\d)|(\\d\\d\\d\\d-\\d\\d-\\d\\d))?((T\\d\\d:\\d\\d:\\d\\d\\.\\d{3})(\\d{6})?)?(?:Z)?$/;\n\n        /**\n         * Enum for Rounding values.\n         * @enum {number}\n         */\n        static Rounding = {\n            Normal: 0,\n            Floor: 1,\n            Ceiling: 2,\n        };\n\n        static Types = {\n            dashboardToKdb: {\n                timestamp: \"1212\",\n                month: \"1213\",\n                date: \"1214\",\n                datetime: \"1215\",\n                timespan: \"1216\",\n                minute: \"1217\",\n                second: \"1218\",\n                time: \"1219\",\n            },\n            kdbTemporals: [\n                \"1212\", // kdb.JTimeStamp\n                \"1213\", // kdb.JMonth\n                \"1214\", // kdb.JDate\n                \"1215\", // kdb.JDateTime\n                \"1216\", // kdb.JTimeSpan\n                \"1217\", // kdb.JMinute\n                \"1218\", // kdb.JSecond\n                \"1219\", // kdb.JTime\n            ],\n            kdbToDashboard: {\n                \"1212\": \"timestamp\",\n                \"1213\": \"month\",\n                \"1214\": \"date\",\n                \"1215\": \"datetime\",\n                \"1216\": \"timespan\",\n                \"1217\": \"minute\",\n                \"1218\": \"second\",\n                \"1219\": \"time\",\n            },\n        };\n\n        static binarySearch(element, array, accessor, typeNum) {\n            const compareFn = Tools.getComparator(typeNum, accessor);\n            return Tools.binarySearch2(element, array, compareFn);\n        }\n\n        static binarySearch2<T, S>(\n            element: T,\n            array: S[],\n            compareFn: (aValue: T, b: S) => 1 | -1 | 0,\n        ): number {\n            let mid = 0,\n                n = array.length - 1,\n                cmp,\n                i;\n\n            while (mid <= n) {\n                i = (n + mid) >> 1;\n                cmp = compareFn(element, array[i]);\n                if (cmp > 0) {\n                    mid = i + 1;\n                } else if (cmp < 0) {\n                    n = i - 1;\n                } else {\n                    return i;\n                }\n            }\n\n            // returns a negative value indicating the insertion point\n            // for the new element if the element is not found\n            return -mid - 1;\n        }\n\n        /**\n         * Function calculates height for Jquery UI Dialogs if window\n         *  size is too small as specified in default size\n         * @param {number} defHeight - default height of the dialog\n         */\n        static calcDialogHeight(defHeight: number, dialogName?: string): number {\n            const offset =\n                \"FSBL\" in window\n                    ? (window[\"finApi\"][\"getDialogHeightOffset\"] as Function)(dialogName)\n                    : 40;\n            return window.innerHeight < defHeight + offset\n                ? window.innerHeight - offset\n                : defHeight;\n        }\n        /**\n         * Function calculates and returns font color contrast based on background\n         * if color is not provided an empty string is returned\n         */\n        static calculateFontContrast(color: string): string {\n            let fontColor = \"\";\n            const isHex = color.indexOf(\"#\") === 0,\n                isRgb = color.indexOf(\"rgb\") === 0 || color.indexOf(\"rgba\") === 0;\n            if (color && (isHex || isRgb)) {\n                const rgb: Array<number> = isHex ? Tools.hex2RGB(color) : Tools.rgbStr2Array(color);\n                if (rgb.length) {\n                    const o = Math.round(\n                        (parseInt(String(rgb[0])) * 299 +\n                            parseInt(String(rgb[1])) * 587 +\n                            parseInt(String(rgb[2])) * 114) /\n                            1000,\n                    );\n                    if (o > 125) {\n                        //dark\n                        fontColor = isHex\n                            ? Tools.getDefaultThemeColors(\"Dark\")[0]\n                            : \"rgb(40,40,40)\";\n                    } else {\n                        //light\n                        fontColor = isHex\n                            ? Tools.getDefaultThemeColors(\"Light\")[0]\n                            : \"rgb(15,15,15)\";\n                    }\n                }\n            }\n            return fontColor;\n        }\n\n        static clickEvent(onEnd?: boolean): string {\n            const touch = this.hasTouch();\n\n            if (onEnd) {\n                return touch ? \"touchend mouseup\" : \"click\";\n            } else {\n                return touch ? \"touchstart click\" : \"click\";\n            }\n        }\n\n        static convertDateStringValueToMoment(\n            value: any,\n            timezone?: string,\n        ): moment.Moment | moment.Duration {\n            return moment.tz(value, timezone || \"UTC\");\n        }\n\n        static convertISODatetimeToKDBLikeObject(value: string): any {\n            let m,\n                matches = this.TIME_RX.exec(value);\n\n            const result = _.filter(matches, function(r) {\n                return r !== undefined;\n            });\n\n            if (!result || result.length < 2) {\n                // not an ISO string\n                return value;\n            }\n\n            m = Tools.convertValueToMoment(value);\n\n            return m.toKdbObject();\n        }\n\n        static convertKDBTemporalToMoment(value: any): moment.Moment | moment.Duration {\n            let applyUserTimezone = false,\n                m;\n\n            if (value && _.isNumber(value.i) && _.includes(Tools.Types.kdbTemporals, value.class)) {\n                switch (value.class) {\n                    case \"1212\": // kdb.JTimeStamp\n                        // datetime with nanos\n                        m = moment.tz(value.i, \"UTC\");\n                        m.nanoseconds(value.n % 1000000); // kdb n is milliseconds + nanoseconds\n                        applyUserTimezone = true;\n                        break;\n                    case \"1213\": // kdb.JMonth\n                        //bug in toString() for \"1999.02m\", .., \"1999.12m\"\n                        m = moment.tz(\"2000-01-01\", \"UTC\");\n                        m.add(value.i, \"month\");\n                        break;\n                    case \"1214\": // kdb.JDate\n                        // toDate() may return incorrect date depending on timezone\n                        // parse from string instead without applying timezone\n                        m = moment.tz(value.toString(), \"UTC\");\n                        break;\n                    case \"1216\": // kdb.JTimeSpan\n                        // duration, in nanoseconds\n                        // kdb.JTimeSpan i is in nanoseconds\n                        m = moment.duration(\n                            value.i > 0\n                                ? Math.floor(value.i / 1000000)\n                                : Math.ceil(value.i / 1000000),\n                        );\n                        m.nanoseconds(value.i % 1000000);\n                        break;\n                    case \"1217\": // kdb.JMinute\n                        // duration, in minutes\n                        m = moment.duration(value.i * 60 * 1000);\n                        break;\n                    case \"1218\": // kdb.JSecond\n                        // duration, in seconds\n                        m = moment.duration(value.i * 1000);\n                        break;\n                    case \"1219\": // kdb.JTime\n                        // duration, in milliseconds\n                        m = moment.duration(value.i);\n                        break;\n                    default:\n                        m = moment.tz(value.i, \"UTC\");\n                        applyUserTimezone = true;\n                        break;\n                }\n\n                m.kdbType(value.class);\n            } else {\n                m = moment.tz(value, \"UTC\");\n            }\n\n            // apply user timezone\n            if (applyUserTimezone && this.timezone && m.isValid()) {\n                m.tz(this.timezone);\n            }\n\n            return m;\n        }\n\n        //used in datagrid for highlight rules (for kdb temporals & guid), string comparison is used\n        static convertKDBToViewstateValue(value: any): string {\n            let toReturn = value;\n\n            if (_.hasIn(value, \"class\")) {\n                toReturn =\n                    value.class === \"1222\"\n                        ? //guid only\n                          value.toString()\n                        : //temporals\n                          Tools.convertKDBTemporalToMoment(value).toDashString();\n            }\n\n            return toReturn;\n        }\n\n        // function converts value to datepicker format before -\n        //  fidding it back in to datapicker form\n        static convertMomentToDatePicker(m: moment.Moment, ignoreTimezone?: boolean): Date {\n            let date, nano;\n\n            m = Tools.convertValueToMoment(m) as moment.Moment;\n\n            // apply user timezone\n            if (ignoreTimezone) {\n                m.tz(\"UTC\");\n            } else if (this.timezone && m.isValid() && !moment.isDuration(m)) {\n                m.tz(this.timezone);\n            }\n\n            date = new Date(\n                m.year(),\n                m.month(),\n                m.date(),\n                m.hour(),\n                m.minute(),\n                m.second(),\n                m.millisecond(),\n            );\n\n            // apply nanos\n            nano = m.nanoseconds();\n            if (nano && !_.isNaN(nano)) date.nanoseconds = nano;\n\n            return date;\n        }\n\n        static convertTypeToKdbType(type: string, value: any): any {\n            if (type) {\n                if (_.includes(Tools.Types.kdbTemporals, type)) {\n                    // use given kdb type\n                    return type;\n                } else if (_.includes(Tools.Types.kdbTemporals, Tools.Types.dashboardToKdb[type])) {\n                    // convert dashboard type to kdb type\n                    return Tools.Types.dashboardToKdb[type];\n                }\n            } else {\n                // guess type based on value\n                return Tools.inferKdbTypeFromDashString(value);\n            }\n\n            return null;\n        }\n\n        static convertUserInputToMoment(\n            value: string,\n            format: string,\n            ignoreTimezone?: boolean,\n        ): moment.Moment {\n            // convert string to moment, assuming input is in user's selected timezone\n            let m, nano;\n\n            if (!_.isString(value)) return value;\n\n            // yyyy.mm.dd is not parsed correctly by moment, convert to yyyy-mm-dd\n            value = value.replace(/(\\d\\d\\d\\d)\\.(\\d\\d)\\.(\\d\\d)/, \"$1-$2-$3\");\n\n            if (ignoreTimezone) {\n                m = moment.tz(value, format, \"UTC\");\n            } else if (this.timezone) {\n                m = moment.tz(value, format, this.timezone);\n            } else {\n                m = moment(value, format);\n            }\n\n            // apply nanos\n            nano = Tools.extractNanos(value);\n            if (nano && !_.isNaN(nano)) {\n                m.kdbType(\"1212\");\n                m.nanoseconds(nano);\n            }\n\n            return m;\n        }\n\n        static convertValueToDuration(value: any, type?: string): moment.Duration | moment.Moment {\n            // HH:mm:ss.SSSSSSSSS to moment\n            let kdbType = Tools.convertTypeToKdbType(type, value),\n                m,\n                nano,\n                timeParts;\n\n            if (_.includes([\"1212\", \"1213\", \"1214\", \"1215\"], type)) {\n                // should be parsed as moment\n                return Tools.convertValueToMoment(value, type);\n            }\n\n            if (!value) return moment.duration(0);\n\n            if (moment.isDuration(value)) {\n                m = value;\n            } else if (_.isString(value)) {\n                value = value.replace(\"1970-01-01T\", \"\").replace(\"Z\", \"\");\n\n                timeParts = value.match(/(\\d\\d:\\d\\d:\\d\\d.\\d\\d\\d)(\\d\\d\\d\\d\\d\\d)/);\n                if (timeParts && timeParts[1]) {\n                    // convert days to hours expected format 0D12:12:12.000000000\n                    if (type === \"1216\" && value.indexOf(\"D\") !== -1) {\n                        const dayHourArr = value.substring(0, value.indexOf(\":\")).split(\"D\"),\n                            hours = Number(dayHourArr[1]) + Number(dayHourArr[0]) * 24;\n                        if (hours) {\n                            //get substring excluding hours\n                            timeParts[1] = hours + timeParts[1].substring(value.indexOf(\":\") - 2);\n                        }\n                    }\n\n                    m = moment.duration(timeParts[1]);\n                    nano = timeParts[2] ? Number(timeParts[2]) : 0;\n                    if (nano && !_.isNaN(nano)) m.nanoseconds(nano);\n                } else {\n                    // try moment parser\n                    m = moment.duration(value);\n                }\n            } else {\n                m = moment.duration(value);\n            }\n\n            if (m && kdbType) {\n                m.kdbType(kdbType);\n            }\n\n            return m;\n        }\n\n        static convertValueToMoment(\n            value: any,\n            type?: string,\n            ignoreTimezone?: boolean,\n        ): moment.Duration | moment.Moment {\n            let kdbType = Tools.convertTypeToKdbType(type, value),\n                m,\n                nano = 0;\n\n            if (_.includes([\"1216\", \"1217\", \"1218\", \"1219\"], type)) {\n                // should be parsed as duration\n                return Tools.convertValueToDuration(value, type);\n            }\n\n            if (value === null || value === undefined) {\n                // create moment with current date/time\n                m = moment();\n                if (!ignoreTimezone) {\n                    m.tz(this.timezone);\n                }\n            } else if (moment.isMoment(value)) {\n                // already a moment\n                m = value;\n            } else {\n                // create moment\n                if (_.isString(value) && (kdbType === \"1214\" || kdbType === \"1213\")) {\n                    // date should avoid timezone\n                    m = moment.utc(value);\n                } else {\n                    m = moment(value);\n                    if (!ignoreTimezone) {\n                        m.tz(this.timezone);\n                    }\n                }\n\n                if (_.isDate(value)) {\n                    nano = value[\"nanoseconds\"];\n                } else if (_.isString(value)) {\n                    nano = Tools.extractNanos(value);\n                }\n\n                if (nano && !_.isNaN(nano)) {\n                    m.nanoseconds(nano);\n                }\n            }\n\n            if (m && kdbType) {\n                m.kdbType(kdbType);\n            }\n\n            return m;\n        }\n\n        /*\n         * @param value {string} - fix moment incompatible string\n         * @param type {string} - kdb type id\n         */\n        static convertStringToMomentFormat(value: string, type: string) {\n            if (!value) return;\n            let ignoreTimezone = false;\n\n            switch (type) {\n                case \"1213\": //month 2001.11m\n                    //required 2001.11\n                    value = value.replace(\"m\", \"\");\n                    break;\n                case \"1212\": //timestamp \"2016.01.01D01:01:01.001123456\"\n                    //requires \"2016-01-01T01:01:01.001123456Z\"\n                    value =\n                        value.split(\"D\")[0].replace(/\\./g, \"-\") + \"T\" + value.split(\"D\")[1] + \"Z\";\n                    ignoreTimezone = true;\n                    break;\n                case \"1215\": //datetime yyyy.mm.ddThh.mm.ss\n                    //required yyyy-mm-ddThh.mm.ss\n                    value =\n                        value.split(\"T\")[0].replace(/\\./g, \"-\") + \"T\" + value.split(\"T\")[1] + \"Z\";\n                    ignoreTimezone = true;\n                    break;\n            }\n\n            return Tools.convertValueToMoment(value, type, ignoreTimezone);\n        }\n\n        static createPivotCollectionFunc(primaryKey: string) {\n            return Backbone.Collection.extend({\n                model: Backbone.Model.extend({\n                    idAttribute: primaryKey,\n                    set: function(attributes, options) {\n                        if (typeof attributes[\"subscribe\"] === \"function\") {\n                            this.subscribe = attributes.subscribe;\n                        }\n                        if (typeof attributes[\"unsubscribe\"] === \"function\") {\n                            this.unsubscribe = attributes.unsubscribe;\n                        }\n\n                        Backbone.Model.prototype.set.call(this, attributes, options);\n                    },\n                }),\n            });\n        }\n        /**\n         * Function converts kdb and other values to common dashboard strings\n         * @param {any} value - value from data source or view state can be a kdb object\n         * @param {string} [type] - value type used for kdb temporal conversion\n         */\n        static castToDashString(value, type?: string): string {\n            const DDOWN_DATE_TYPES = [\n                \"date\",\n                \"datetime\",\n                \"month\",\n                \"timestamp\",\n                \"minute\",\n                \"time\",\n                \"timespan\",\n                \"second\",\n            ];\n\n            if (type && value && value.class && _.includes(DDOWN_DATE_TYPES, type)) {\n                const m = Tools.convertKDBTemporalToMoment(value);\n                value = m.toDashString();\n            } else if (_.isString(value) && type === \"timespan\" && value.indexOf(\".000Z\") > -1) {\n                value = value.replace(\".000Z\", \".000000000Z\");\n            } else if (\n                _.isString(value) &&\n                type === \"datetime\" &&\n                value.match(/[DTZ]/g) !== null &&\n                value.length > 23\n            ) {\n                //date time has 9 nanos instead of 3\n                value = value.slice(0, 23) + \"Z\";\n            }\n\n            return value;\n        }\n        static extractNanos(value: string): number {\n            let nanos = 0,\n                regexResult;\n\n            if (value) {\n                if (_.isFunction(value.toString)) {\n                    value = value.toString();\n                }\n\n                regexResult = value.match(/\\d{1,2}:\\d{2}:\\d{2}\\.\\d{3}(\\d{6})/);\n\n                if (regexResult) {\n                    nanos = Number(regexResult[1]);\n                }\n            }\n\n            return nanos;\n        }\n\n        //convert to blob obj\n        //https://stackoverflow.com/questions/23150333/html5-javascript-dataurl-to-blob-blob-to-dataurl\n        static convertDataUrlToBlob(dataUrl) {\n            let arr = dataUrl.split(\",\"),\n                bstr = atob(arr[1]),\n                n = bstr.length,\n                blob = new Uint8Array(n);\n\n            while (n--) {\n                blob[n] = bstr.charCodeAt(n);\n            }\n\n            return blob;\n        }\n\n        static fileSave(filename: string, data: any, contentType?: string) {\n            let blob, link;\n\n            if (!contentType) {\n                // assume blob\n                //required for sheetJS.js library\n                contentType = \"application/octet-stream\";\n            }\n\n            // Download CSV file\n            link = document.createElement(\"a\");\n\n            if (window.Blob) {\n                blob = new Blob([data], {\n                    type: contentType,\n                });\n\n                if (window.navigator.msSaveOrOpenBlob) {\n                    //IE fix\n                    link.onclick = function() {\n                        window.navigator.msSaveOrOpenBlob(blob, filename);\n                    };\n                } else {\n                    if (link.download !== undefined) {\n                        link.setAttribute(\"href\", URL.createObjectURL(blob));\n                    }\n                }\n            } else {\n                link.setAttribute(\"href\", encodeURI(contentType + \",\" + data));\n            }\n\n            if (link.download !== undefined) {\n                link.setAttribute(\"download\", filename);\n            }\n\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n        }\n\n        static formatNumber(value: any, precision: number): string {\n            let numberAsString,\n                numberParts,\n                toReturn = value;\n\n            if ($.isNumeric(value)) {\n                numberAsString = this.toFixedNumber(value, precision);\n                //split to whole and decimal part\n                numberParts = numberAsString.split(\".\");\n                toReturn = numberParts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n\n                //append decimal part without any formatting\n                if (numberParts.length === 2) {\n                    toReturn += \".\" + numberParts[1];\n                }\n\n                return toReturn;\n            }\n\n            return this.htmlEncode(toReturn);\n        }\n\n        static getComparator(kdbTypeNumber, bAccessor) {\n            switch (kdbTypeNumber) {\n                default:\n                case 1: //boolean\n                case 2: //guid\n                case 4: //byte\n                case 5: //short\n                case 6: //int\n                case 8: //real\n                case 9: //float\n                    return function(aValue, b) {\n                        const bValue = bAccessor(b);\n\n                        // is undefined or is null\n                        return aValue == null || bValue == null\n                            ? aValue != null\n                                ? 1\n                                : bValue != null\n                                ? -1\n                                : 0\n                            : aValue > bValue\n                            ? 1\n                            : aValue < bValue\n                            ? -1\n                            : 0;\n                    };\n                case 10: //char\n                case 11: //symbol\n                    return function(aValue, b) {\n                        const bValue = bAccessor(b);\n\n                        // is undefined or is null\n                        return aValue == null || bValue == null\n                            ? aValue != null\n                                ? 1\n                                : bValue != null\n                                ? -1\n                                : 0\n                            : aValue.localeCompare(bValue, { caseFirst: \"lower\" });\n                    };\n                case 7: //long\n                    return function(a, b) {\n                        b = bAccessor(b);\n\n                        // is undefined or is null\n                        if (a == null || b == null) {\n                            return a != null ? 1 : b != null ? -1 : 0;\n                        } else {\n                            // calculate magnitude as a value to indicate scale\n                            const aNeg = a[0] === \"-\";\n                            const aMagnitude = aNeg ? 1 - a.length : a.length;\n                            const bMagnitude = b[0] === \"-\" ? 1 - b.length : b.length;\n\n                            if (aMagnitude !== bMagnitude) {\n                                return aMagnitude > bMagnitude ? 1 : -1;\n                            } else {\n                                // > is faster than localeCompare\n                                // https://stackoverflow.com/questions/14677060/400x-sorting-speedup-by-switching-a-localecompareb-to-ab-1ab10\n                                return (aNeg ? -1 : 1) * (a > b ? 1 : a < b ? -1 : 0);\n                            }\n                        }\n                    };\n                case 12: //timestamp\n                case 16: //timespan\n                    return function(aValue, b) {\n                        const bValue = bAccessor(b);\n\n                        const aScalar =\n                            aValue === null ||\n                            aValue === undefined ||\n                            aValue === Infinity ||\n                            aValue === -Infinity;\n                        const bScalar =\n                            bValue === null ||\n                            bValue === undefined ||\n                            bValue === Infinity ||\n                            bValue === -Infinity;\n                        if (aScalar && bScalar) {\n                            return aValue > bValue ? 1 : aValue < bValue ? -1 : 0;\n                        } else if (aScalar) {\n                            return aValue > bValue.i ? 1 : aValue < bValue.i ? -1 : 0;\n                        } else if (bScalar) {\n                            return aValue.i > bValue ? 1 : aValue.i < bValue ? -1 : 0;\n                        }\n\n                        return aValue.i > bValue.i\n                            ? 1\n                            : aValue.i < bValue.i\n                            ? -1\n                            : aValue.n > bValue.n\n                            ? 1\n                            : aValue.n < bValue.n\n                            ? -1\n                            : 0;\n                    };\n                case 13: //month\n                case 14: //date\n                case 15: //datetime\n                case 17: //minute\n                case 18: //second\n                case 19: //time\n                    return function(aValue, b) {\n                        const bValue = bAccessor(b);\n\n                        const aScalar =\n                            aValue === null ||\n                            aValue === undefined ||\n                            aValue === Infinity ||\n                            aValue === -Infinity;\n                        const bScalar =\n                            bValue === null ||\n                            bValue === undefined ||\n                            bValue === Infinity ||\n                            bValue === -Infinity;\n                        if (aScalar && bScalar) {\n                            return aValue > bValue ? 1 : aValue < bValue ? -1 : 0;\n                        } else if (aScalar) {\n                            return aValue > bValue.i ? 1 : aValue < bValue.i ? -1 : 0;\n                        } else if (bScalar) {\n                            return aValue.i > bValue ? 1 : aValue.i < bValue ? -1 : 0;\n                        }\n\n                        return aValue.i > bValue.i ? 1 : aValue.i < bValue.i ? -1 : 0;\n                    };\n            }\n        }\n\n        static getCookie(cname: string) {\n            const name = cname + \"=\";\n            const ca = document.cookie.split(\";\");\n            for (let i = 0; i < ca.length; i++) {\n                let c = ca[i];\n                while (c.charAt(0) == \" \") {\n                    c = c.substring(1);\n                }\n                if (c.indexOf(name) == 0) {\n                    return decodeURIComponent(c.substring(name.length, c.length));\n                }\n            }\n            return \"\";\n        }\n\n        static getDefaultThemeColors(theme: string): string[] {\n            if (theme === \"Light\") {\n                return [\"#ffffff\", \"#f4f4f4\", \"#cecece\"];\n            } else {\n                // Dark\n                return [\"#282828\", \"#303030\", \"#505050\"];\n            }\n        }\n\n        static getHash(win?: Window): string {\n            const match = (win || window).location.href.match(/#(.*)$/);\n            return match ? match[1] : \"\";\n        }\n\n        static getTimezoneOffset(): any {\n            let m;\n\n            if (this.timezone) {\n                m = moment.tz(this.timezone);\n            } else {\n                m = moment();\n            }\n\n            return m.utcOffset();\n        }\n\n        static getTypeCategory(type: string): string {\n            let category = \"\";\n            switch (type) {\n                case \"1212\": // kdb.JTimeStamp\n                case \"1213\": // kdb.JMonth\n                case \"1214\": // kdb.JDate\n                case \"1215\": // kdb.JDateTime\n                case \"date\":\n                case \"datetime\":\n                case \"month\":\n                case \"timestamp\":\n                    category = \"date\";\n                    break;\n                case \"1216\": // kdb.JTimeSpan\n                case \"1217\": // kdb.JMinute\n                case \"1218\": // kdb.JSecond\n                case \"1219\": // kdb.JTime\n                case \"minute\":\n                case \"second\":\n                case \"time\":\n                case \"timespan\":\n                    category = \"duration\";\n                    break;\n            }\n            return category;\n        }\n\n        /* @return decimalPlaces {int} - number of characters after last \".\" */\n        static getNumberDecimalPlaces(numberStr) {\n            let decimalPlaces = 0;\n            //prevent decimal places = to string length\n            if (numberStr.lastIndexOf(\".\") !== -1) {\n                decimalPlaces = numberStr.substr(numberStr.lastIndexOf(\".\") + 1, numberStr.length)\n                    .length;\n            }\n            return decimalPlaces;\n        }\n\n        static hasDefaultThemeColors(\n            theme: string,\n            color1: string,\n            color2?: string,\n            color3?: string,\n        ): boolean {\n            if (\n                theme === \"Light\" &&\n                color1 === \"#f0f0f0\" &&\n                (color2 === \"#e0e0e0\" || !color2) &&\n                (color3 === \"#c8c8c8\" || !color3)\n            ) {\n                return true;\n            } else if (\n                theme === \"Dark\" &&\n                color1 === \"#282828\" &&\n                (color2 === \"#303030\" || !color2) &&\n                (color3 === \"#505050\" || !color3)\n            ) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        static hasTouch(): boolean {\n            return $(document).hasClass(\"touch\");\n        }\n\n        /**\n         * @function RGB2hex\n         * @param {string} hex - Hexadecimal Color\n         * @returns {number[]} RGB Array\n         * Converts hex value to RGB Array\n         */\n        static hex2RGB(hex: string): number[] {\n            const result: any =\n                hex.length > 4\n                    ? RegExp(/^\\#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/).exec(hex)\n                    : RegExp(/^\\#?([a-f\\d])([a-f\\d])([a-f\\d])$/).exec(hex);\n            if (!result) return [];\n            return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)];\n        }\n\n        static hoverFix(el: HTMLElement) {\n            const par = el.parentNode;\n            const next = el.nextSibling;\n            par.removeChild(el);\n            setTimeout(function() {\n                par.insertBefore(el, next);\n            }, 0);\n        }\n\n        static htmlEncode(value: any): string {\n            return value\n                .toString()\n                .replace(/&/g, \"&amp;\")\n                .replace(/\"/g, \"&quot;\")\n                .replace(/'/g, \"&#39;\")\n                .replace(/</g, \"&lt;\")\n                .replace(/>/g, \"&gt;\");\n        }\n\n        static inferKdbTypeFromDashString(string) {\n            let stringParts;\n\n            if (!string || !_.isString(string)) {\n                return null;\n            }\n\n            stringParts = string.match(\n                /^(\\d\\d\\d\\d-\\d\\d)?(-\\d\\d)?(T\\d\\d:\\d\\d:\\d\\d\\.\\d{3})?(\\d{6})?(?:Z)?$/,\n            );\n\n            if (stringParts) {\n                if (stringParts[1] && stringParts[2] && stringParts[3] && stringParts[4]) {\n                    if (string.substr(0, 10) === \"1970-01-01\") {\n                        // timespan with nanos\n                        return \"1216\";\n                    } else {\n                        // timestamp with nanos\n                        return \"1212\";\n                    }\n                } else if (stringParts[1] && stringParts[2] && stringParts[3]) {\n                    if (string.substr(0, 10) === \"1970-01-01\") {\n                        // time\n                        return \"1219\";\n                    } else {\n                        // datetime\n                        return \"1215\";\n                    }\n                } else if (stringParts[1] && stringParts[2]) {\n                    // date\n                    return \"1214\";\n                } else if (stringParts[1]) {\n                    // month\n                    return \"1213\";\n                }\n            }\n\n            return null;\n        }\n\n        static isIE(): number | boolean {\n            const ua = window.navigator.userAgent;\n\n            const msie = ua.indexOf(\"MSIE \");\n            if (msie > 0) {\n                // IE 10 or older => return version number\n                return parseInt(ua.substring(msie + 5, ua.indexOf(\".\", msie)), 10);\n            }\n\n            const trident = ua.indexOf(\"Trident/\");\n            if (trident > 0) {\n                // IE 11 => return version number\n                const rv = ua.indexOf(\"rv:\");\n                return parseInt(ua.substring(rv + 3, ua.indexOf(\".\", rv)), 10);\n            }\n\n            const edge = ua.indexOf(\"Edge/\");\n            if (edge > 0) {\n                // Edge (IE 12+) => return version number\n                return parseInt(ua.substring(edge + 5, ua.indexOf(\".\", edge)), 10);\n            }\n\n            // other browser\n            return false;\n        }\n\n        static isKDBTemporal(value: any): any {\n            return (\n                (value && value.class && _.includes(Tools.Types.kdbTemporals, value.class)) || false\n            );\n        }\n\n        static objToUri(obj: any): string {\n            return _.reduce(\n                _.keys(obj),\n                function(memo, key) {\n                    if (key) {\n                        memo.push(key + \"=\" + obj[key]);\n                    }\n\n                    return memo;\n                },\n                [],\n            ).join(\"&\");\n        }\n\n        static padLeft(str: string, max: number): string {\n            if (_.isNull(str) || _.isUndefined(str)) {\n                return \"\";\n            }\n\n            str = str.toString();\n\n            return str.length < max ? Tools.padLeft(\"0\" + str, max) : str;\n        }\n\n        static roundToPlaces(num: number, decimals: number): number {\n            const multiplicand = Math.pow(10, decimals);\n            num *= multiplicand;\n            num = Math.round(num);\n            return num / multiplicand;\n        }\n\n        /// <summary>\n        /// Rounds using arithmetic (5 rounds up) symmetrical (up is away from zero) rounding\n        /// </summary>\n        /// <param name=\"d\">A Decimal number to be rounded.</param>\n        /// <param name=\"decimals\">The number of significant fractional digits (precision) in the return value.</param>\n        /// <param name=\"mode\"></param>\n        /// <returns>The number nearest d with precision equal to decimals. If d is halfway between two numbers, then the nearest whole number away from zero is returned.</returns>\n        static round(num: number, decimals: number, mode?: any): number {\n            let factor;\n\n            if (mode === this.Rounding.Normal) {\n                return Tools.roundToPlaces(num, decimals);\n            }\n\n            factor = Math.pow(10, decimals);\n            if (mode === Tools.Rounding.Floor) {\n                return Math.floor(num * factor) / factor;\n            }\n\n            return Math.ceil(num * factor) / factor;\n        }\n\n        /**\n         * @function RGB2hex\n         * @param {number[]} rgb - RGB Value Array\n         * @returns {string} Hexadecimal Color\n         * Converts array of RGB values to hex value\n         */\n        static rgb2hex(rgb: number[]): string {\n            let hexColor = \"\";\n            if (rgb.length) {\n                hexColor =\n                    \"#\" +\n                    ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1);\n            }\n            return hexColor;\n        }\n\n        /**\n         * Function to convert rgb string in to array [red,green,blue]\n         * TODO regex can be improved to parse whole integers for opacity value\n         * only works with decimal values, no % is allowed in values\n         **/\n        static rgbStr2Array(str: string): Array<any> {\n            const match = str.match(\n                /rgba?\\((\\d{1,3}), ?(\\d{1,3}), ?(\\d{1,3})\\)?(?:, ?(\\d(?:\\.\\d?))\\))?/,\n            );\n            return match ? [match[1], match[2], match[3], match[4]] : [];\n        }\n\n        static smartFormatNumber(\n            value: any,\n            precision: number,\n            hideTralingZeroes?: boolean,\n        ): string {\n            let precisionToUse,\n                num = Number(value),\n                numAbs,\n                suffix = \"\",\n                denominator = 1,\n                toReturn;\n\n            if (isNaN(num)) {\n                return \"\";\n            }\n\n            if (\n                typeof value === \"string\" &&\n                (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER)\n            ) {\n                // value is a large long. We can't use it to safely do calculations so just pad with 0's\n                return this.toFixedNumber(value, precision);\n            }\n\n            precisionToUse = Math.max(0, precision === undefined ? 2 : precision);\n            numAbs = Math.abs(num);\n\n            if (numAbs >= 1e18) {\n                denominator = 1e18;\n                suffix = \"E\";\n            } else if (numAbs >= 1e15) {\n                denominator = 1e15;\n                suffix = \"P\";\n            } else if (numAbs >= 1e12) {\n                denominator = 1e12;\n                suffix = \"T\";\n            } else if (numAbs >= 1e9) {\n                denominator = 1e9;\n                suffix = \"B\";\n            } else if (numAbs >= 1e6) {\n                denominator = 1e6;\n                suffix = \"M\";\n            } else if (numAbs >= 1000) {\n                denominator = 1000;\n                suffix = \"k\";\n            }\n\n            toReturn = Tools.roundToPlaces(num / denominator, precisionToUse);\n\n            if (hideTralingZeroes) {\n                toReturn = toReturn.toFixed(precisionToUse);\n            }\n\n            return toReturn + suffix;\n        }\n\n        static sum(list: _.List<number>): number {\n            return _.reduce(\n                list,\n                function(memo, num) {\n                    return memo + num;\n                },\n                0,\n            );\n        }\n\n        // handles long integers as strings by padding with 0's\n        static toFixedNumber(value: string | number, precision: number): string {\n            let precisionToUse = precision === undefined ? 2 : precision;\n            precisionToUse = Math.min(20, Math.max(0, precisionToUse));\n\n            if (typeof value === \"string\" && !/(^[^-\\d]|^[-\\d].*[^\\d]+|^-$)/.test(value)) {\n                // value is a string which contains only digits and may contain a leading -, e.g., a long\n                return value + (precisionToUse ? \".\" : \"\") + _.repeat(\"0\", precisionToUse);\n            } else if (typeof value === \"number\") {\n                // value is a number, e.g., an int or float\n                return value.toFixed(precisionToUse);\n            } else {\n                return this.htmlEncode(value);\n            }\n        }\n\n        static touchDownEvent(onEnd?: boolean): string {\n            return this.hasTouch() ? \"touchstart\" : \"mousedown\";\n        }\n\n        static tapEvent(): string {\n            return this.hasTouch() ? \"tap\" : \"mousedown\";\n        }\n\n        static uriToObj(uri: string): any {\n            return _.reduce(\n                uri.split(\"&\"),\n                function(memo, item) {\n                    const kvp = item.split(\"=\");\n                    memo[kvp[0]] = kvp[1];\n                    return memo;\n                },\n                {},\n            );\n        }\n    }\n}\n","/// <reference path=\"../lib/tools.ts\" />\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class RTTI {\n        private static infos = {\n            List: {\n                char: undefined,\n                size: undefined,\n                num: 0,\n                literal: undefined,\n                null: \"\",\n                name: \"list\",\n                editor: \"List\",\n                toKDBInput: function(value) {\n                    let list = [],\n                        isNumber;\n\n                    if (value) {\n                        isNumber = _.every(value, function(v) {\n                            return _.isNull(v) || _.isUndefined(v) || _.isNumber(v);\n                        });\n\n                        if (isNumber) {\n                            list = _.map(value, function(v) {\n                                return RTTI.infos[\"float\"].toKDBInput(v);\n                            });\n                        } else {\n                            list = _.map(value, function(v) {\n                                return RTTI.infos[\"char\"].toKDBInput(v);\n                            });\n                        }\n\n                        return \"(\" + list.join(\";\") + \")\";\n                    } else return \"()\";\n                },\n            },\n            boolean: {\n                char: \"b\",\n                size: \"1\",\n                num: 1,\n                literal: \"0b\",\n                null: \"\",\n                name: \"boolean\",\n                editor: { type: \"Checkbox\" },\n                toKDBInput: function(value) {\n                    return value ? \"1b\" : \"0b\"; // there is no null for boolean in kdb so false\n                },\n            },\n            guid: {\n                char: \"g\",\n                size: \"16\",\n                num: 2,\n                literal: \"\",\n                null: \"0Ng\",\n                name: \"guid\",\n                editor: {\n                    type: \"Text\",\n                    editorAttrs: {\n                        maxLength: 36,\n                    },\n                    validators: [\n                        function checkGuid(value) {\n                            if (\n                                !value.match(\n                                    /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/,\n                                )\n                            ) {\n                                return {\n                                    type: \"guid\",\n                                    message:\n                                        \"Invalid, requires: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\",\n                                };\n                            }\n                        },\n                    ],\n                },\n                toKDBInput: function(value) {\n                    if (_.isNull(value) || _.isUndefined(value) || value === \"\") {\n                        return \"0Ng\";\n                    } else if (value === -Infinity) {\n                        return \"0w\";\n                    } else if (value === Infinity) {\n                        return \"-0w\";\n                    }\n                    return '\"G\"$\"' + value.toString() + '\"';\n                },\n            },\n            byte: {\n                char: \"x\",\n                size: \"1\",\n                num: 4,\n                literal: \"0x00\",\n                null: \"\",\n                name: \"byte\",\n                editor: {\n                    type: \"Number\",\n                    editorAttrs: {\n                        min: -128,\n                        max: 127,\n                        step: 1,\n                    },\n                    validators: [\n                        \"number\",\n                        {\n                            type: \"range\",\n                            min: -128,\n                            max: 127,\n                        },\n                        function wholeNumber(value) {\n                            if (value % 1 !== 0) {\n                                return {\n                                    type: \"whole-number\",\n                                    message: \"Must be a whole number\",\n                                };\n                            }\n                        },\n                    ],\n                },\n                toKDBInput: function(value) {\n                    if (_.isNull(value) || _.isUndefined(value) || isNaN(value) || value === \"\") {\n                        return \"0x0\";\n                    } else if (value === -Infinity) {\n                        return \"0x0\";\n                    } else if (value === Infinity) {\n                        return \"0xFF\";\n                    }\n\n                    return \"0x\" + Number(value).toString(16);\n                },\n            },\n            short: {\n                char: \"h\",\n                size: \"2\",\n                num: 5,\n                literal: \"0h\",\n                null: \"0Nh\",\n                name: \"short\",\n                editor: {\n                    type: \"Number\",\n                    editorAttrs: {\n                        min: -32768,\n                        max: 32767,\n                        step: 1,\n                    },\n                    validators: [\n                        \"number\",\n                        {\n                            type: \"range\",\n                            min: -32768,\n                            max: 32767,\n                        },\n                        function wholeNumber(value) {\n                            if (value % 1 !== 0) {\n                                return {\n                                    type: \"whole-number\",\n                                    message: \"Must be a whole number\",\n                                };\n                            }\n                        },\n                    ],\n                },\n                toKDBInput: function(value) {\n                    if (_.isNull(value) || _.isUndefined(value) || isNaN(value) || value === \"\") {\n                        return \"0Nh\";\n                    } else if (value === -Infinity) {\n                        return \"-0Wh\";\n                    } else if (value === Infinity) {\n                        return \"0Wh\";\n                    }\n                    return value + \"h\";\n                },\n            },\n            int: {\n                char: \"i\",\n                size: \"4\",\n                num: 6,\n                literal: \"0\",\n                null: \"0N\",\n                name: \"int\",\n                editor: {\n                    type: \"Number\",\n                    editorAttrs: {\n                        min: -2147483648,\n                        max: 2147483647,\n                        step: 1,\n                    },\n                    validators: [\n                        \"number\",\n                        {\n                            type: \"range\",\n                            min: -2147483648,\n                            max: 2147483647,\n                        },\n                        function wholeNumber(value) {\n                            if (value % 1 !== 0) {\n                                return {\n                                    type: \"whole-number\",\n                                    message: \"Must be a whole number\",\n                                };\n                            }\n                        },\n                    ],\n                },\n                toKDBInput: function(value) {\n                    if (_.isNull(value) || _.isUndefined(value) || isNaN(value) || value === \"\") {\n                        return \"0Ni\";\n                    } else if (value === -Infinity) {\n                        return \"-0Wi\";\n                    } else if (value === Infinity) {\n                        return \"0Wi\";\n                    }\n                    return value + \"i\";\n                },\n            },\n            long: {\n                char: \"j\",\n                size: \"8\",\n                num: 7,\n                literal: \"0j\",\n                null: \"0Nj\",\n                name: \"long\",\n                editor: {\n                    type: \"Long\",\n                    validators: [\n                        \"number\",\n                        {\n                            type: \"range\",\n                            min: -9223372036854775808,\n                            max: 9223372036854775807,\n                        },\n                        function wholeNumber(value) {\n                            if (value % 1 !== 0) {\n                                return {\n                                    type: \"whole-number\",\n                                    message: \"Must be a whole number\",\n                                };\n                            }\n                        },\n                    ],\n                },\n                toKDBInput: function(value) {\n                    if (_.isNull(value) || _.isUndefined(value) || isNaN(value) || value === \"\") {\n                        return \"0Nj\";\n                    } else if (value === -Infinity) {\n                        return \"-0W\";\n                    } else if (value === Infinity) {\n                        return \"0W\";\n                    }\n                    return value;\n                },\n            },\n            real: {\n                char: \"e\",\n                size: \"4\",\n                num: 8,\n                literal: \"0e\",\n                null: \"0Ne\",\n                name: \"real\",\n                editor: {\n                    type: \"Number\",\n                    editorAttrs: {\n                        step: \"any\",\n                    },\n                    validators: [\"number\"],\n                },\n                toKDBInput: function(value) {\n                    if (_.isNull(value) || _.isUndefined(value) || isNaN(value) || value === \"\") {\n                        return \"0Ne\";\n                    } else if (value === -Infinity) {\n                        return \"-0We\";\n                    } else if (value === Infinity) {\n                        return \"0We\";\n                    }\n                    return value + \"e\";\n                },\n            },\n            float: {\n                char: \"f\",\n                size: \"8\",\n                num: 9,\n                literal: \"0.0 or 0f\",\n                null: \"0n\",\n                name: \"float\",\n                editor: {\n                    type: \"Number\",\n                    editorAttrs: {\n                        step: \"any\",\n                    },\n                    validators: [\"number\"],\n                },\n                toKDBInput: function(value) {\n                    if (_.isNull(value) || _.isUndefined(value) || isNaN(value) || value === \"\") {\n                        return \"0n\";\n                    } else if (value === -Infinity) {\n                        return \"-0Wf\";\n                    } else if (value === Infinity) {\n                        return \"0Wf\";\n                    }\n                    return value + \"f\";\n                },\n            },\n            char: {\n                char: \"c\",\n                size: \"1\",\n                num: 10,\n                literal: '\" \"',\n                null: '\" \"',\n                name: \"char\",\n                editor: {\n                    type: \"Text\",\n                    editorAttrs: {\n                        maxlength: 1,\n                    },\n                },\n                toKDBInput: function(value) {\n                    if (_.isNull(value) || _.isUndefined(value) || value.length === 0) {\n                        return \"\\\" \\\"\";\n                    }\n                    return (\n                        '\"' +\n                        (value && value.toString\n                            ? value\n                                  .toString()\n                                  .replace(/\\\\/g, \"\\\\\\\\\")\n                                  .replace(/\"/g, '\\\\\"')\n                            : \" \") +\n                        '\"'\n                    );\n                },\n            },\n            symbol: {\n                char: \"s\",\n                size: \".\",\n                num: 11,\n                literal: \"`\",\n                null: \"`\",\n                name: \"symbol\",\n                editor: {\n                    type: \"Text\",\n                },\n                toKDBInput: function(value) {\n                    if (_.isNull(value) || _.isUndefined(value)) {\n                        return \"`\";\n                    }\n                    return (\n                        '`$\"' +\n                        (value && value.toString\n                            ? value\n                                  .toString()\n                                  .replace(/\\\\/g, \"\\\\\\\\\")\n                                  .replace(/\"/g, '\\\\\"')\n                            : \"\") +\n                        '\"'\n                    );\n                },\n            },\n            timestamp: {\n                char: \"p\",\n                size: \"8\",\n                num: 12,\n                literal: \"dateDtimespan\",\n                null: \"0Np\",\n                name: \"timestamp\",\n                editor: {\n                    type: \"DateTimePicker\",\n                    options: {\n                        hasNano: true,\n                        isTimestamp: true,\n                        dateFormat: \"yy-mm-dd\",\n                        timeFormat: \"HH:mm:ss.SSSSSSSSS\",\n                        width: 200,\n                        bindButton: false,\n                    },\n                    validators: [\n                        function checkDate(value) {\n                            if (value) {\n                                const m = Tools.convertUserInputToMoment(\n                                    value,\n                                    \"YYYY/MM/DD HH:mm:ss.SSS\",\n                                );\n                                if (m && !m.isValid()) {\n                                    return {\n                                        type: \"timestamp\",\n                                        message: \"Invalid date/time\",\n                                    };\n                                }\n                            }\n                        },\n                    ],\n                },\n                toKDBInput: function(value) {\n                    let m;\n                    if (_.isNull(value) || _.isUndefined(value)) {\n                        return \"0Np\";\n                    } else if (value === -Infinity) {\n                        return \"-0Wp\";\n                    } else if (value === Infinity) {\n                        return \"0Wp\";\n                    }\n\n                    if (_.isString(value)) {\n                        value = value\n                            .replace(\"D\", \"T\")\n                            .replace(/^(\\d\\d\\d\\d)\\.(\\d\\d).(\\d\\d)/, \"$1-$2-$3\");\n                        value = /Z$/.test(value) ? value : value + \"Z\";\n                    }\n\n                    if (Tools.isKDBTemporal(value)) {\n                        m = Tools.convertKDBTemporalToMoment(value);\n                    } else {\n                        m = Tools.convertValueToMoment(value);\n                    }\n\n                    return moment.isMoment(m) && m.isValid()\n                        ? m.utcOffset(0).format(\"YYYY.MM.DD\") +\n                              \"D\" +\n                              m.formatNano(\"HH:mm:ss.SSSSSSSSS\", { trim: false })\n                        : \"0Np\";\n                },\n            },\n            month: {\n                char: \"m\",\n                size: \"4\",\n                num: 13,\n                literal: \"2000.01m\",\n                null: \"0Nm\",\n                name: \"month\",\n                editor: {\n                    type: \"Month\",\n                    options: {\n                        bindButton: false,\n                    },\n                },\n                toKDBInput: function(value) {\n                    let m;\n                    if (_.isNull(value) || _.isUndefined(value)) {\n                        return \"0Nm\";\n                    } else if (value == -Infinity) {\n                        return \"-0Wm\";\n                    } else if (value === Infinity) {\n                        return \"0Wm\";\n                    }\n\n                    if (Tools.isKDBTemporal(value)) {\n                        m = Tools.convertKDBTemporalToMoment(value);\n                    } else {\n                        // Y.MM parses both 2001-01 & 2001.01\n                        m = moment.tz(value, \"Y.MM\", \"UTC\");\n                    }\n\n                    return moment.isMoment(m) && m.isValid()\n                        ? m.utcOffset(0).format(\"YYYY.MM\") + \"m\"\n                        : \"0Nm\";\n                },\n            },\n            date: {\n                char: \"d\",\n                size: \"4\",\n                num: 14,\n                literal: \"2000.01.01\",\n                null: \"0Nd\",\n                name: \"date\",\n                editor: {\n                    type: \"DatePicker\",\n                    options: {\n                        dateFormat: \"yy-mm-dd\",\n                        width: 75,\n                        bindButton: true,\n                    },\n                    validators: [\n                        function checkDate(value) {\n                            if (value) {\n                                const m = Tools.convertUserInputToMoment(value, \"YYYY/MM/DD\");\n                                if (m && !m.isValid()) {\n                                    return {\n                                        type: \"date\",\n                                        message: \"Invalid date\",\n                                    };\n                                }\n                            }\n                            return !RTTI.REGEX_DATEPICKER.test(value.substr(0, 10));\n                        },\n                    ],\n                },\n                toKDBInput: function(value) {\n                    let m;\n                    if (_.isNull(value) || _.isUndefined(value)) {\n                        return \"0Nd\";\n                    } else if (value == -Infinity) {\n                        return \"-0Wd\";\n                    } else if (value == Infinity) {\n                        return \"0Wd\";\n                    }\n\n                    if (_.isString(value)) {\n                        value = value.replace(/^(\\d\\d\\d\\d)\\.(\\d\\d)\\.(\\d\\d)/, \"$1-$2-$3\");\n                    }\n\n                    if (Tools.isKDBTemporal(value)) {\n                        m = Tools.convertKDBTemporalToMoment(value);\n                    } else {\n                        m = moment.tz(value, \"UTC\");\n                    }\n\n                    return moment.isMoment(m) && m.isValid()\n                        ? m.utcOffset(0).format(\"YYYY.MM.DD\")\n                        : \"0Nd\";\n                },\n            },\n            datetime: {\n                char: \"z\",\n                size: \"8\",\n                num: 15,\n                literal: \"dateTtime\",\n                null: \"0Nz\",\n                name: \"datetime\",\n                editor: {\n                    type: \"DateTimePicker\",\n                    options: {\n                        dateFormat: \"yy-mm-dd\",\n                        timeFormat: \"HH:mm:ss.SSS\",\n                        width: 155,\n                        bindButton: true,\n                    },\n                    validators: [\n                        function checkDate(value) {\n                            if (_.isFunction(value.toISOString)) {\n                                value = value.toISOString();\n                            }\n                            return !RTTI.REGEX_TIMEPICKER.test(value);\n                        },\n                    ],\n                },\n                toKDBInput: function(value) {\n                    let m;\n                    if (_.isNull(value) || _.isUndefined(value)) {\n                        return \"0Nz\";\n                    } else if (value == -Infinity) {\n                        return \"-0Wz\";\n                    } else if (value == Infinity) {\n                        return \"0Wz\";\n                    }\n\n                    if (_.isString(value)) {\n                        value = value.replace(/^(\\d\\d\\d\\d)\\.(\\d\\d).(\\d\\d)/, \"$1-$2-$3\");\n                        value = /Z$/.test(value) ? value : value + \"Z\";\n                    }\n\n                    if (Tools.isKDBTemporal(value)) {\n                        m = Tools.convertKDBTemporalToMoment(value);\n                    } else {\n                        m = Tools.convertValueToMoment(value);\n                    }\n\n                    return moment.isMoment(m) && m.isValid()\n                        ? m.utcOffset(0).format(\"YYYY.MM.DD\") +\n                              \"T\" +\n                              m.formatNano(\"HH:mm:ss.SSS\", { trim: false })\n                        : \"0Np\";\n                },\n            },\n            timespan: {\n                char: \"n\",\n                size: \"8\",\n                num: 16,\n                literal: \"00:00:00.00\",\n                null: \"0Nn\",\n                name: \"timespan\",\n                editor: {\n                    type: \"TimePicker\",\n                    options: {\n                        isDuration: true,\n                        hasNano: true,\n                        isTimespan: true,\n                        timeFormat: \"HH:mm:ss.SSSSSSSSS\",\n                        width: 142,\n                        bindButton: false,\n                    },\n                    validators: [\n                        function checkTimespan(value) {\n                            return false;\n                            return !RTTI.REGEX_TIMEPICKER.test(value.toString());\n                        },\n                    ],\n                },\n                toKDBInput: function(value) {\n                    let m;\n                    if (_.isNull(value) || _.isUndefined(value)) {\n                        return \"0Nn\";\n                    } else if (value == -Infinity) {\n                        return \"-0Wn\";\n                    } else if (value == Infinity) {\n                        return \"0Wn\";\n                    }\n\n                    if (Tools.isKDBTemporal(value)) {\n                        m = Tools.convertKDBTemporalToMoment(value);\n                    } else {\n                        m = Tools.convertValueToDuration(value);\n                    }\n\n                    return moment.isDuration(m)\n                        ? m.format(\"DD\") + \"D\" + m.formatNano(\"HH:mm:ss.SSSSSSSSS\", { trim: false })\n                        : \"0Nn\";\n                },\n            },\n            minute: {\n                char: \"u\",\n                size: \"4\",\n                num: 17,\n                literal: \"00:00:00\",\n                null: \"0Nu\",\n                name: \"minute\",\n                editor: {\n                    type: \"TimePicker\",\n                    options: {\n                        isDuration: true,\n                        timeFormat: \"HH:mm\",\n                        width: 61,\n                        bindButton: false,\n                    },\n                    validators: [\n                        function checkDate(value) {\n                            return false;\n                        },\n                    ],\n                },\n                toKDBInput: function(value) {\n                    let m;\n\n                    if (_.isNull(value) || _.isUndefined(value)) {\n                        return \"0Nu\";\n                    } else if (value == -Infinity) {\n                        return \"-0Wu\";\n                    } else if (value == Infinity) {\n                        return \"0Wu\";\n                    }\n\n                    if (Tools.isKDBTemporal(value)) {\n                        m = Tools.convertKDBTemporalToMoment(value);\n                    } else {\n                        m = Tools.convertValueToDuration(value);\n                    }\n\n                    return moment.isDuration(m as moment.Duration)\n                        ? m.format(\"HH:mm\", { trim: false })\n                        : \"0Nu\";\n                },\n            },\n            second: {\n                char: \"v\",\n                size: \"4\",\n                num: 18,\n                literal: \"00:00:00\",\n                null: \"0Nv\",\n                name: \"second\",\n                editor: {\n                    type: \"TimePicker\",\n                    options: {\n                        isDuration: true,\n                        timeFormat: \"HH:mm:ss\",\n                        width: 79,\n                        bindButton: false,\n                    },\n                    validators: [\n                        function checkDate(value) {\n                            return false;\n                        },\n                    ],\n                },\n                toKDBInput: function(value) {\n                    let m;\n\n                    if (_.isNull(value) || _.isUndefined(value)) {\n                        return \"0Nv\";\n                    } else if (value == -Infinity) {\n                        return \"-0Wv\";\n                    } else if (value == Infinity) {\n                        return \"0Wv\";\n                    }\n\n                    if (Tools.isKDBTemporal(value)) {\n                        m = Tools.convertKDBTemporalToMoment(value);\n                    } else {\n                        m = Tools.convertValueToDuration(value);\n                    }\n\n                    return moment.isDuration(m) ? m.formatNano(\"HH:mm:ss\", { trim: false }) : \"0Nv\";\n                },\n            },\n            time: {\n                char: \"t\",\n                size: \"4\",\n                num: 19,\n                literal: \"00:00:00.000\",\n                null: \"0Nt\",\n                name: \"time\",\n                editor: {\n                    type: \"TimePicker\",\n                    options: {\n                        isDuration: true,\n                        timeFormat: \"HH:mm:ss.SSS\",\n                        width: 102,\n                        bindButton: false,\n                    },\n                    validators: [\n                        function checkTimespan(value) {\n                            return !RTTI.REGEX_TIMEPICKER.test(value.toString());\n                        },\n                    ],\n                },\n                toKDBInput: function(value) {\n                    let m;\n                    if (_.isNull(value) || _.isUndefined(value)) {\n                        return \"0Nt\";\n                    } else if (value == -Infinity) {\n                        return \"-0Wt\";\n                    } else if (value == Infinity) {\n                        return \"0Wt\";\n                    }\n\n                    if (Tools.isKDBTemporal(value)) {\n                        m = Tools.convertKDBTemporalToMoment(value);\n                    } else {\n                        m = Tools.convertValueToDuration(value);\n                    }\n\n                    return moment.isDuration(m)\n                        ? m.formatNano(\"HH:mm:ss.SSS\", { trim: false })\n                        : \"0Nt\";\n                },\n            },\n            string: {\n                char: \"\",\n                size: \".\",\n                num: 20,\n                literal: \"\",\n                null: \"\",\n                name: \"string\",\n                editor: {\n                    type: \"TextArea\",\n                },\n                toKDBInput: function(value) {\n                    if (_.isNull(value) || _.isUndefined(value)) {\n                        return \"\\\"\\\"\";\n                    }\n\n                    return (\n                        '\"' +\n                        (value && value.toString\n                            ? value\n                                  .toString()\n                                  .replace(/\\\\/g, \"\\\\\\\\\")\n                                  .replace(/\"/g, '\\\\\"')\n                            : \"\") +\n                        '\"'\n                    );\n                },\n            },\n            list: {\n                char: \"Q\",\n                size: \"\",\n                num: 21,\n                literal: [],\n                null: \"\",\n                name: \"list\",\n                editor: {\n                    type: \"CustomList\",\n                    options: {\n                        itemType: \"Text\",\n                    },\n                },\n                toKDBInput: function(value) {\n                    const values = _.values(value);\n                    if (values != undefined && values.length > 0) {\n                        return (\n                            \"(\" +\n                            (values.length > 1 ? \"\" : \"enlist \") +\n                            _.map(values, function(v) {\n                                return v && v.toKDBInput\n                                    ? v.toKDBInput()\n                                    : '`$\"' + (_.isString(v) ? v.replace(/\\\"/g, '\\\\\"') : v) + '\"';\n                            }).join(\";\") +\n                            \")\"\n                        );\n                    } else {\n                        return \"()\";\n                    }\n                },\n            },\n            dateRolling: {\n                char: \"d\",\n                size: \"4\",\n                num: 22,\n                literal: \"2000.01.01\",\n                null: \"0Nd\",\n                name: \"dateRolling\",\n                editor: {\n                    type: \"DatePickerRolling\",\n                    options: {\n                        dateFormat: \"yy-mm-dd\",\n                    },\n                    validators: [\n                        function checkRollingDate(value) {\n                            if (\n                                RTTI.REGEX_ROLLING.test(value.toString()) ||\n                                (value &&\n                                    value.toISOString &&\n                                    RTTI.REGEX_DATEPICKER.test(value.toISOString())) ||\n                                RTTI.REGEX_DATEPICKER.test(value.substr(0, 10))\n                            ) {\n                                return false;\n                            }\n\n                            return {\n                                type: \"rolling\",\n                                message: \"Valid rolling syntax includes NOW, T+x or T+x@HH:mm\",\n                            };\n                        },\n                    ],\n                },\n                toKDBInput: function(value) {\n                    return $.datepicker.formatDate(\"yy.mm.dd\", RTTI.castDate(value));\n                },\n            },\n            datetimeRolling: {\n                char: \"z\",\n                size: \"8\",\n                num: 23,\n                literal: \"dateTtime\",\n                null: \"0Nz\",\n                name: \"datetimeRolling\",\n                editor: {\n                    type: \"DateTimePickerRolling\",\n                    options: {\n                        dateFormat: \"yy-mm-dd\",\n                        timeFormat: \"HH:mm:ss.SSS\",\n                    },\n                    validators: [\n                        function checkRollingDate(value) {\n                            if (\n                                RTTI.REGEX_ROLLING.test(value.toString()) ||\n                                (value &&\n                                    value.toISOString &&\n                                    RTTI.REGEX_TIMEPICKER.test(value.toISOString())) ||\n                                RTTI.REGEX_TIMEPICKER.test(value)\n                            ) {\n                                return false;\n                            } else {\n                                return {\n                                    type: \"guid\",\n                                    message: \"Valid rolling syntax includes NOW, T+x or T+x@HH:mm\",\n                                };\n                            }\n                        },\n                    ],\n                },\n            },\n            timestampRolling: {\n                char: \"p\",\n                size: \"8\",\n                num: 24,\n                literal: \"dateDtimespan\",\n                null: \"0Np\",\n                name: \"timestampRolling\",\n                editor: {\n                    type: \"DateTimePickerRolling\",\n                    options: {\n                        hasNano: true,\n                        isTimestamp: true,\n                        dateFormat: \"yy-mm-dd\",\n                        timeFormat: \"HH:mm:ss.SSSSSSSSS\",\n                    },\n                    validators: [\n                        function checkRollingDate(value) {\n                            if (\n                                RTTI.REGEX_ROLLING.test(value.toString()) ||\n                                (value &&\n                                    value.toISOString &&\n                                    RTTI.REGEX_TIMEPICKER.test(value.toISOString())) ||\n                                RTTI.REGEX_TIMEPICKER.test(value)\n                            ) {\n                                return false;\n                            } else {\n                                return {\n                                    type: \"guid\",\n                                    message: \"Valid rolling syntax includes NOW, T+x or T+x@HH:mm\",\n                                };\n                            }\n                        },\n                    ],\n                },\n            },\n            timeRolling: {\n                char: \"t\",\n                size: \"4\",\n                num: 25,\n                literal: \"00:00:00.000\",\n                null: \"0Nt\",\n                name: \"timeRolling\",\n                editor: {\n                    type: \"TimePickerRolling\",\n                    options: {\n                        isDuration: true,\n                        timeFormat: \"HH:mm:ss.SSS\",\n                    },\n                    validators: [\n                        function checkRollingDate(value) {\n                            if (\n                                RTTI.REGEX_ROLLING.test(value.toString()) ||\n                                RTTI.REGEX_TIMEPICKER.test(value.toString())\n                            ) {\n                                return false;\n                            } else {\n                                return {\n                                    type: \"guid\",\n                                    message: \"Valid rolling syntax includes NOW, T+x or T-x\",\n                                };\n                            }\n                        },\n                    ],\n                },\n            },\n            minuteRolling: {\n                char: \"u\",\n                size: \"4\",\n                num: 26,\n                literal: \"00:00:00\",\n                null: \"0Nu\",\n                name: \"minuteRolling\",\n                editor: {\n                    type: \"TimePickerRolling\",\n                    options: {\n                        isDuration: true,\n                        timeFormat: \"HH:mm\",\n                    },\n                    validators: [\n                        function checkRollingDate(value) {\n                            if (\n                                RTTI.REGEX_ROLLING.test(value.toString()) ||\n                                RTTI.REGEX_TIMEPICKER.test(value.toString())\n                            ) {\n                                return false;\n                            } else {\n                                return {\n                                    type: \"guid\",\n                                    message: \"Valid rolling syntax includes NOW, T+x or T-x\",\n                                };\n                            }\n                        },\n                    ],\n                },\n            },\n            secondRolling: {\n                char: \"v\",\n                size: \"4\",\n                num: 27,\n                literal: \"00:00:00\",\n                null: \"0Nv\",\n                name: \"secondRolling\",\n                editor: {\n                    type: \"TimePickerRolling\",\n                    options: {\n                        isDuration: true,\n                        timeFormat: \"HH:mm:ss\",\n                    },\n                    validators: [\n                        function checkRollingDate(value) {\n                            if (\n                                RTTI.REGEX_ROLLING.test(value.toString()) ||\n                                RTTI.REGEX_TIMEPICKER.test(value.toString())\n                            ) {\n                                return false;\n                            } else {\n                                return {\n                                    type: \"guid\",\n                                    message: \"Valid rolling syntax includes NOW, T+x or T-x\",\n                                };\n                            }\n                        },\n                    ],\n                },\n            },\n            dict: {\n                char: \"Q\",\n                size: \"\",\n                num: 98,\n                literal: [],\n                null: \"\",\n                name: \"dict\",\n                editor: {\n                    type: \"Dict\",\n                    options: {\n                        itemType: \"Text\",\n                    },\n                },\n                toKDBInput: function(value) {\n                    if (_.isEmpty(value)) {\n                        return \"()!()\";\n                    }\n\n                    const keys = _.keys(value);\n                    const values = _.values(value);\n                    const en = keys.length === 1 ? \"enlist \" : \"\";\n                    return (\n                        \"(\" +\n                        en +\n                        _.map(keys, function(k) {\n                            return '`$\"' + k + '\"';\n                        }).join(\";\") +\n                        \")!(\" +\n                        en +\n                        _.map(values, v =>\n                            v.type\n                                ? RTTI.getByName(v.type).toKDBInput(v.value)\n                                : '`$\"' + v.replace(/\\\"/g, '\\\\\"') + '\"',\n                        ).join(\";\") +\n                        \")\"\n                    );\n                },\n            },\n            email: {\n                char: \"\",\n                size: \"\",\n                num: 29,\n                literal: \"\",\n                null: \"\",\n                name: \"email\",\n                editor: {\n                    type: \"Text\",\n                    options: {\n                        itemType: \"Text\",\n                    },\n                    validators: [\"email\"],\n                },\n                toKDBInput: function(value) {\n                    return RTTI.infos[\"symbol\"].toKDBInput(value);\n                },\n            },\n        };\n\n        private static simple = [\n            \"list\",\n            \"boolean\",\n            \"guid\",\n            \"byte\",\n            \"byte\",\n            \"short\",\n            \"int\",\n            \"long\",\n            \"real\",\n            \"float\",\n            \"char\",\n            \"symbol\",\n            \"timestamp\",\n            \"month\",\n            \"date\",\n            \"datetime\",\n            \"timespan\",\n            \"minute\",\n            \"second\",\n            \"time\",\n            \"dict\",\n        ];\n\n        private static infosByNum: Array<any> = null;\n\n        static castDate(value) {\n            return value instanceof Date\n                ? value\n                : value && value.i\n                ? new Date(value.i)\n                : new Date(value);\n            //return typeof (value) === \"Date\" ? value : new Date(value);\n        }\n\n        static convertDateToTimeObject(date) {\n            return {\n                hour: date.getUTCHours(),\n                minute: date.getUTCMinutes(),\n                second: date.getUTCSeconds(),\n                millisec: date.getUTCMilliseconds(), //,\n                //microsec:  date.getHours(),\n                //timezone: date.getTimezoneOffset() / 60\n            };\n        }\n\n        static getByQTypeNum(i) {\n            if (!RTTI.infosByNum) {\n                RTTI.infosByNum = _.map(RTTI.simple, s => RTTI.infos[s]);\n            }\n\n            return RTTI.infosByNum[i];\n        }\n\n        static getByName(name) {\n            // work around to support double by aliasing to float\n            let info = this.infos[name === \"double\" ? \"float\" : name];\n            if (!info) {\n                info = this.infos[name.replace(\"[]\", \"\")];\n\n                if (!info) {\n                    return this.infos[\"symbol\"];\n                }\n\n                return {\n                    char: info.char + \"[]\",\n                    num: -info.num,\n                    literal: info.literal,\n                    null: \"\",\n                    name: name,\n                    editor: _.extend({}, info.editor, {\n                        type: \"List\",\n                        itemType: info.editor.type,\n                        editorClass: info.name + \"List\",\n                    }),\n                    toKDBInput: function(value) {\n                        const values = _.values(value);\n                        if (values != undefined && values.length > 0) {\n                            return (\n                                \"(\" +\n                                (values.length > 1 ? \"\" : \"enlist \") +\n                                _.map(values, function(v) {\n                                    return v && v.toKDBInput ? v.toKDBInput() : info.toKDBInput(v);\n                                }).join(\";\") +\n                                \")\"\n                            );\n                        } else {\n                            return \"()\";\n                        }\n                    },\n                };\n            }\n\n            return info;\n        }\n\n        static readonly REGEX_DATEPICKER = /^\\d{4}-\\d{2}-\\d{2}$/;\n        static readonly REGEX_ROLLING = /^(?:NOW|T([\\+|\\-]\\d+)|T)(\\@)?(\\d{1,2})?(:\\d{2})?(:\\d{2})?(.(\\d{9}|\\d{3}))?(?:Z)?$/;\n        static readonly REGEX_DURATION = /^\\d{4}-\\d{2}-\\d{2}T(\\d{2,6}):(\\d{2}):(\\d{2})?[.](\\d{9}|\\d{3})?Z$/;\n        static readonly REGEX_TIMEPICKER = /^\\d{4}-\\d{2}-\\d{2}T(\\d{2}):(\\d{2}):(\\d{2})?[.](\\d{9}|\\d{3})?Z$/;\n    }\n}\n","///<reference path=\"../classes/RTTI.ts\"/>\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class Pivot {\n        private static PIVOT_FUNCTION =\n            \"$[{x~key x}`.pivot.pivotV3;.pivot.pivotV3;{[t;w;d;a;f;n;o] g:(); if [(type d)=99h; [g:d[`g]; d:d[`d],g;]];piv: 0!?[t;w;d!d;a!f]; if [(count g)>0; [d: (-1 _ d); a2:d,a; piv2: 0!?[piv;();g!g;a2!a2]; grpData:{[x;d;grpCol;f] labels: $[(count f)>1;(`$((string x[grpCol]) ,/: string f[;0]));x[grpCol]]; d xkey (d,labels) xcol flip x _ grpCol}; piv: 0! () uj/ each[grpData[;d;g[0];f]] piv2; ]]; if [(count o)>0;[field: o[0]; order: o[1]; piv:$[order>0;field xasc piv;field xdesc piv];]]; $[n<=0;piv;n sublist piv]}]\";\n\n        private static constructPivotWhereString(wheres) {\n            const whereStrings = [];\n\n            //Loop through wheres object array and construct wheres string\n            wheres.forEach(function(where) {\n                switch (where.columnType) {\n                    case 1: //boolean\n                    case 2: //guid\n                    case 4: //byte\n                    case 5: //short\n                    case 6: //int\n                    case 7: //bigint\n                    case 8: //real\n                    case 9: // float\n                    case 12: //timestamp\n                    case 13: //month\n                    case 14: //date\n                    case 15: //datetime\n                    case 16: //timespan\n                    case 17: //minute\n                    case 18: //second\n                    case 19: //time\n                        whereStrings.push(\n                            \"(\" +\n                                where.columnOperator +\n                                ';`$\"' +\n                                where.columnName +\n                                '\"; ' +\n                                RTTI.getByQTypeNum(where.columnType).toKDBInput(where.columnValue) +\n                                \")\",\n                        );\n                        break;\n                    case 10: //char\n                        if (where.columnValue.length == 1) {\n                            whereStrings.push(\n                                \"(\" +\n                                    where.columnOperator +\n                                    ';`$\"' +\n                                    where.columnName +\n                                    '\"; \"' +\n                                    where.columnValue.toString() +\n                                    '\")',\n                            );\n                        } else {\n                            whereStrings.push(\n                                '(~\\\\:;`$\"' +\n                                    where.columnName +\n                                    '\"; \"' +\n                                    where.columnValue.toString() +\n                                    '\")',\n                            );\n                        }\n                        break;\n                    case 11: //symbol\n                        whereStrings.push(\n                            \"(\" +\n                                where.columnOperator +\n                                ';`$\"' +\n                                where.columnName +\n                                '\"; enlist `$\"' +\n                                where.columnValue.toString() +\n                                '\")',\n                        );\n                        break;\n                    default:\n                        if (_.isString(where.columnValue)) {\n                            whereStrings.push(\n                                '(~\\\\:;`$\"' +\n                                    where.columnName +\n                                    '\"; \"' +\n                                    where.columnValue.toString() +\n                                    '\")',\n                            );\n                        } else {\n                            whereStrings.push(\n                                \"(\" +\n                                    where.columnOperator +\n                                    ';`$\"' +\n                                    where.columnName +\n                                    '\"; enlist `$\"' +\n                                    where.columnValue.toString() +\n                                    '\")',\n                            );\n                        }\n                        break;\n                }\n            });\n\n            if (whereStrings.length == 1) {\n                return \"enlist \" + whereStrings[0];\n            } else {\n                return \"(\" + whereStrings.join(\";\") + \")\";\n            }\n        }\n\n        private static _generateOrderingKdbSyntax(ordering) {\n            let toReturn = \"\",\n                column,\n                direction,\n                parts;\n\n            //if (typeof ordering === 'undefined') { ordering = ''; } //optional param, needs a default\n            ordering = ordering || \"\";\n            parts = ordering.split(\",\");\n            if (parts.length === 2) {\n                direction = parts[1];\n\n                if (direction != \"null\") {\n                    column = parts[0];\n                    toReturn = \"`\" + column + \";\" + (direction === \"asc\" ? 1 : -1);\n                }\n            }\n\n            return toReturn;\n        }\n        private static strip(query) {\n            return query && query.length > 0\n                ? query.replace(/((^|\\s+)\\/.*$)|^\\s+|\\s*\\n/gm, \" \")\n                : query;\n        }\n\n        public static constructPivotQuery(options) {\n            let dimsString = \"\",\n                aggsString = \"\",\n                whereString = \"\",\n                funcsString = \"\",\n                topString = \"0j\",\n                query,\n                pivotSource = options.pivotSource,\n                table = options.table,\n                queryString = this.strip(options.queryString),\n                queryParams = options.queryParams,\n                aggFn = options.aggFn,\n                aggregateFns = options.aggregateFns,\n                aggStr,\n                ordering = options._generateOrderingKdbSyntax,\n                deltaParameterRx = /^{\\[([a-z0-9A-Z\\;\\w\\/ ]+?)\\]/,\n                deltaParameterRgx,\n                deltaParameterString,\n                columnLabelString = \"\",\n                dimsDict = \"\",\n                stringParameterRx = /^[A-Za-z0-9]+\\w*$/;\n\n            // helper fn\n            function toSymbolListString(arr) {\n                if (arr.length > 1) {\n                    return (\n                        _.reduce(\n                            arr,\n                            function(acc, value, index: number, collection) {\n                                let newValue =\n                                    acc + (acc.substr(-1) !== \";\" && index > 0 ? \";\" : \"\");\n\n                                if (value.match(stringParameterRx)) {\n                                    newValue += \"`\" + value;\n                                } else {\n                                    newValue +=\n                                        '`$\"' +\n                                        value +\n                                        '\"' +\n                                        (index < collection.length - 1 ? \";\" : \"\");\n                                }\n\n                                return newValue;\n                            },\n                            \"(\",\n                        ) + \")\"\n                    );\n                } else if (arr.length === 1) {\n                    return arr[0].match(stringParameterRx)\n                        ? \"enlist `\" + arr[0]\n                        : 'enlist `$\"' + arr[0] + '\"';\n                }\n            }\n\n            ordering = this._generateOrderingKdbSyntax(ordering);\n\n            dimsString = toSymbolListString(options.dimensions);\n\n            // prefer aggregate labels over columns\n            aggsString = toSymbolListString(\n                _.isArray(options.aggregateLabels) && !_.isEmpty(options.aggregateLabels)\n                    ? _.map(options.aggregateLabels, function(label, i) {\n                          return label || options.aggregateCols[i];\n                      })\n                    : options.aggregateCols,\n            );\n\n            whereString = this.constructPivotWhereString(options.wheres);\n\n            if (options.aggregateCols.length === 1) {\n                funcsString = \"enlist \";\n            }\n            funcsString += \"(\";\n            _.each(options.aggregateCols, function(c, idx) {\n                if (c.length > 0) {\n                    aggStr = (aggregateFns && aggregateFns[idx]) || aggFn;\n                    funcsString +=\n                        \"(\" +\n                        aggStr +\n                        \";\" +\n                        (c.match(stringParameterRx) ? \"`\" + c : '`$\"' + c + '\"') +\n                        \");\";\n                }\n            });\n\n            funcsString = funcsString.substr(0, funcsString.length - 1) + \")\";\n\n            if (options.topX && options.topX !== \"null\" && options.topX !== \"all\") {\n                topString = options.topX + \"j\";\n            }\n\n            if (options.columnLabel && options.columnLabel.length > 0) {\n                columnLabelString = \"enlist `\" + options.columnLabel;\n            } else {\n                columnLabelString = \"()\";\n            }\n\n            dimsDict = \"`d`g!(\" + dimsString + \";\" + columnLabelString + \")\";\n\n            if (pivotSource === \"query\") {\n                queryString = $.trim(queryString);\n                deltaParameterRgx = deltaParameterRx.exec(queryString);\n                deltaParameterString = \"\";\n\n                //Format query string to use parametersif required\n                if ($.isArray(deltaParameterRgx)) {\n                    deltaParameterString = deltaParameterRgx[0];\n                } else if (queryString.substring(0, 3) !== \"{[]\") {\n                    queryString = \"{[] \" + queryString + \"}[]\";\n                } else {\n                    queryString = queryString + \"[]\";\n                }\n\n                if (deltaParameterString.length > 0) {\n                    if (queryParams.length === 1) {\n                        queryString = queryString + \"[\" + queryParams[0].name + \"]\";\n                    } else {\n                        //append parameter value array to query\n                        //the kdbQuery.parameters values will then be passed to this array\n                        queryString = queryString + \"[\";\n                        _.each(queryParams, function(param, idx: number) {\n                            if (idx > 0) {\n                                queryString = queryString + \";\";\n                            }\n\n                            queryString = queryString + param.name;\n                        });\n                        queryString = queryString + \"]\";\n                    }\n                }\n\n                query =\n                    deltaParameterString +\n                    \" \" +\n                    this.PIVOT_FUNCTION +\n                    \"[\" +\n                    queryString +\n                    \";\" +\n                    whereString +\n                    \";\" +\n                    dimsDict +\n                    \";\" +\n                    aggsString +\n                    \";\" +\n                    funcsString +\n                    \";\" +\n                    topString +\n                    \";(\" +\n                    ordering +\n                    \")]\";\n\n                if (deltaParameterString.length > 0) {\n                    query = query + \"}\";\n                }\n            } else {\n                query =\n                    this.PIVOT_FUNCTION +\n                    \"[`\" +\n                    table +\n                    \";\" +\n                    whereString +\n                    \";\" +\n                    dimsDict +\n                    \";\" +\n                    aggsString +\n                    \";\" +\n                    funcsString +\n                    \";\" +\n                    topString +\n                    \";(\" +\n                    ordering +\n                    \")]\";\n            }\n\n            return query;\n        }\n    }\n}\n","/// <reference path=\"pivot.ts\" />\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class DashClientLib {\r\n        public static applyAnalytic(): void {\r\n            const self = (this as unknown) as QuickBase.DocumentDataModel,\r\n                idAttribute = self.get(\"_subscriptionKey\") || DataSet.DEFAULT_ROW_INDEX,\r\n                successFn = function(data, buffer): void {\r\n                    self.onExecuteSubscriptionSuccess(data, self.get(\"_forceReset\"), buffer);\r\n                },\r\n                errorFn = function(error, ...args): void {\r\n                    self.onError(self, self.attributes, error, \"Error\", args);\r\n                };\r\n\r\n            // set up data set to receive data\r\n            self.dataSet = new DataSet({\r\n                idAttribute: idAttribute,\r\n                collectionFunc: Backbone.Collection.extend({\r\n                    model: Backbone.Model.extend({ idAttribute: idAttribute }),\r\n                }),\r\n                agent: self.agent,\r\n                maxRows: self.get(\"_maxRows\"),\r\n                primaryKey: idAttribute,\r\n            });\r\n\r\n            // set up data set to receive data\r\n            self.dataSet2 = new DataSet2({\r\n                idAttribute: idAttribute,\r\n                collectionFunc: Backbone.Collection.extend({\r\n                    model: Backbone.Model.extend({ idAttribute: idAttribute }),\r\n                }),\r\n                agent: self.agent,\r\n                maxRows: self.get(\"_maxRows\"),\r\n                primaryKey: idAttribute,\r\n            });\r\n\r\n            self.unset(\"error\");\r\n            self.unset(\"queryStatus\");\r\n            self.updateParameters(true);\r\n\r\n            if (self.get(\"_subscriptionType\") === \"streaming\") {\r\n                self.execute = self.wrapWithErrorHandler(\r\n                    function() {\r\n                        self.onExecuteBegin();\r\n                        self.runWithConnectionCheck(errorFn, function() {\r\n                            self.updateBuilder(function() {\r\n                                self.subscriptionId = DashClient.client.subscribe(\r\n                                    self.get(\"_maxRows\"),\r\n                                    self.get(\"_selectedAnalytic\"),\r\n                                    self.get(\"_connection\"),\r\n                                    successFn,\r\n                                    errorFn,\r\n                                    self.bindViewStateToKdbParams(self.get(\"_analyticParams\")),\r\n                                );\r\n                                Log.Log(\"Subbd: \" + self.subscriptionId);\r\n                                //console.trace();\r\n                            }, errorFn);\r\n                        });\r\n                    },\r\n                    self,\r\n                    self.attributes,\r\n                );\r\n            } else {\r\n                self.execute = self.wrapWithErrorHandler(\r\n                    function() {\r\n                        self.onExecuteBegin();\r\n                        self.runWithConnectionCheck(errorFn, function() {\r\n                            self.updateBuilder(function() {\r\n                                DashClient.runAnalytic2(\r\n                                    self.get(\"_selectedAnalytic\"),\r\n                                    self.get(\"_connection\"),\r\n                                    self.bindViewStateToKdbParams(self.get(\"_analyticParams\")),\r\n                                    successFn,\r\n                                    errorFn,\r\n                                    self.get(\"_maxRows\") || DocumentDataModel.DEFAULT_MAX_ROWS,\r\n                                    null,\r\n                                    self.performance,\r\n                                );\r\n                            }, errorFn);\r\n                        });\r\n                    },\r\n                    self,\r\n                    self.attributes,\r\n                );\r\n            }\r\n        }\r\n\r\n        public static applyQuery() {\r\n            const self = (this as unknown) as DocumentDataModel,\r\n                idAttribute = self.get(\"_subscriptionKey\") || DataSet.DEFAULT_ROW_INDEX,\r\n                successFn = function(data, buffer) {\r\n                    self.onExecuteSuccess(data, self.get(\"_forceReset\"), buffer);\r\n                    const fn = x => new Date(x);\r\n                    // _.defer(()=>{\r\n                    //     _.each(self.performance.performance, (v,k)=> {\r\n                    //         console.log(k + \": \" + moment(fn(v)).format('HH:mm:ss.SSS'));\r\n                    //     });\r\n                    // });\r\n                },\r\n                errorFn = function(error) {\r\n                    self.onError(self, self.attributes, error, \"Error\", arguments);\r\n                },\r\n                viewStateOptions = self.applyViewStateAttributes();\r\n\r\n            // set up data set to receive data\r\n            self.dataSet = new DataSet({\r\n                idAttribute: idAttribute,\r\n                collectionFunc: Backbone.Collection.extend({\r\n                    model: Backbone.Model.extend({ idAttribute: idAttribute }),\r\n                }),\r\n                agent: self.agent,\r\n                maxRows: self.get(\"_maxRows\"),\r\n                primaryKey: idAttribute,\r\n            });\r\n\r\n            // set up data set to receive data\r\n            self.dataSet2 = new DataSet2({\r\n                idAttribute: idAttribute,\r\n                collectionFunc: Backbone.Collection.extend({\r\n                    model: Backbone.Model.extend({ idAttribute: idAttribute }),\r\n                }),\r\n                agent: self.agent,\r\n                maxRows: self.get(\"_maxRows\"),\r\n                primaryKey: idAttribute,\r\n            });\r\n\r\n            // set defaults\r\n            self.unset(\"error\");\r\n            self.unset(\"queryStatus\");\r\n            self.updateParameters();\r\n\r\n            if (self.get(\"_subscriptionType\") === \"streaming\") {\r\n                self.execute = self.wrapWithErrorHandler(\r\n                    function() {\r\n                        self.onExecuteBegin();\r\n\r\n                        let query = self.get(\"_queryString\");\r\n                        const params = self.bindViewStateToKdbParams(self.get(\"_queryParams\"));\r\n                        query = DashClientLib.replaceParameters(query, params);\r\n                        self.subscriptionId = DashClient.client.subscribe(\r\n                            self.get(\"_maxRows\"),\r\n                            query,\r\n                            self.get(\"_connection\"),\r\n                            successFn,\r\n                            errorFn,\r\n                        );\r\n                        Log.Log(\"Subbd: \" + self.subscriptionId);\r\n                        //console.trace();\r\n                    },\r\n                    self,\r\n                    self.attributes,\r\n                );\r\n            } else {\r\n                self.execute = self.wrapWithErrorHandler(\r\n                    function() {\r\n                        self.onExecuteBegin();\r\n\r\n                        const query = self.get(\"_queryString\");\r\n                        const params = self.bindViewStateToKdbParams(self.get(\"_queryParams\"));\r\n                        //query = DashClientLib.replaceParameters(query, params);\r\n                        if (query.trim() === \"\") return;\r\n\r\n                        DashClient.getQueryData2(\r\n                            \"q\",\r\n                            self.get(\"_connection\"),\r\n                            query,\r\n                            params,\r\n                            successFn,\r\n                            errorFn,\r\n                            self.get(\"_maxRows\") || DocumentDataModel.DEFAULT_MAX_ROWS,\r\n                            undefined,\r\n                            self.performance,\r\n                        );\r\n                    },\r\n                    self,\r\n                    self.attributes,\r\n                );\r\n            }\r\n        }\r\n\r\n        public static bindViewStateToKdbParams(queryParams) {\r\n            let self = (this as unknown) as QuickBase.DocumentDataModel,\r\n                typeName,\r\n                typeDef,\r\n                paramPath,\r\n                newParams = [];\r\n\r\n            //Copy params array so we don't trigger an update event on the model\r\n            $.extend(true, newParams, queryParams);\r\n\r\n            //Replace viewstate parameters with values on relevent kdb query parameters\r\n            // gK: wtf does relevent mean!!\r\n            if (newParams && newParams.length > 0) {\r\n                _.each(newParams, function(queryParam) {\r\n                    if (typeof queryParam.value === \"string\") {\r\n                        paramPath = queryParam.value.match(DocumentDataModel.PARAMETER_RX);\r\n                        if (paramPath) {\r\n                            const viewModel = self\r\n                                .getViewState()\r\n                                .getByPath(\r\n                                    $.trim(paramPath[0].substring(2, paramPath[0].length - 2)),\r\n                                );\r\n\r\n                            if (viewModel) {\r\n                                const val = _.isFunction(viewModel.get)\r\n                                    ? viewModel.get(\"value\")\r\n                                    : viewModel[\"value\"];\r\n                                if (val === undefined) {\r\n                                    queryParam.value = null;\r\n                                }\r\n\r\n                                queryParam.value =\r\n                                    _.isObject(val) && !_.isArray(val)\r\n                                        ? $.extend(true, {}, val)\r\n                                        : val;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // dict types - replace viewstate path with viewstate value\r\n                    if (queryParam.type === \"dict\" && _.isObject(queryParam.value)) {\r\n                        _.each(_.keys(queryParam.value), function(key) {\r\n                            if (queryParam.value[key] instanceof Backbone.Model) {\r\n                                queryParam.value[key] = {\r\n                                    type: queryParam.value[key].get(\"_type\"),\r\n                                    IsKdbParam: true,\r\n                                    isViewState: true,\r\n                                    name: queryParam.value[key].path,\r\n                                    value: queryParam.value[key].get(\"value\"),\r\n                                };\r\n                            } else if (typeof queryParam.value[key] === \"object\") {\r\n                                //when no viewstates present (e.g. in ActionTracker, DDM is created without viewstates),\r\n                                // no conversion is required for dictionary values\r\n                                if (_.has(queryParam.value[key], \"_isKdbReady\")) return;\r\n\r\n                                // Update value\r\n\r\n                                //var viewModel = self.getViewState().getByPath($.trim(paramPath[0].substring(2, paramPath[0].length - 2))),\r\n                                let viewModel = self\r\n                                    .getViewState()\r\n                                    .getByPath(queryParam.value[key].name);\r\n                                if (viewModel) {\r\n                                    queryParam.value[key].type = viewModel.get(\"_type\");\r\n                                    queryParam.value[key].value = viewModel.get(\"value\");\r\n                                } else if (\r\n                                    typeof queryParam.value[key].value === \"string\" &&\r\n                                    queryParam.value[key].value.indexOf(\"<%\") === 0\r\n                                ) {\r\n                                    // path to view state is in the value of the object\r\n                                    const queryPath = $.trim(\r\n                                        queryParam.value[key].value.substring(\r\n                                            2,\r\n                                            queryParam.value[key].value.length - 2,\r\n                                        ),\r\n                                    );\r\n                                    viewModel = self.getViewState().getByPath(queryPath);\r\n                                    if (viewModel) {\r\n                                        queryParam.value[key].value = viewModel.get(\"value\");\r\n                                    }\r\n                                }\r\n                            } else if (typeof queryParam.value[key] === \"string\") {\r\n                                // Generate parameter\r\n                                if (queryParam.value[key].indexOf(\"<%\") === 0) {\r\n                                    const queryPath = $.trim(\r\n                                        queryParam.value[key].substring(\r\n                                            2,\r\n                                            queryParam.value[key].length - 2,\r\n                                        ),\r\n                                    );\r\n\r\n                                    const viewModel = self.getViewState().getByPath(queryPath);\r\n\r\n                                    if (viewModel) {\r\n                                        queryParam.value[key] = {\r\n                                            type: viewModel.get(\"_type\"),\r\n                                            IsKdbParam: true,\r\n                                            isViewState: true,\r\n                                            name: queryParam.value[key],\r\n                                            value: viewModel.get(\"value\"),\r\n                                        };\r\n                                    }\r\n                                }\r\n                            }\r\n                        });\r\n                    } else {\r\n                        typeName = queryParam.type;\r\n                        typeDef = RTTI.getByName(typeName);\r\n                        if (typeDef) {\r\n                            if (typeDef.name === \"dict\") {\r\n                                // items dilimeter\r\n                                const dictItems = queryParam.value.split(\"\\u0002\");\r\n                                const paramValue = {};\r\n\r\n                                _.each(dictItems, function(item) {\r\n                                    // item properies dilimeter\r\n                                    const parts = item.split(\"\\u0001\");\r\n\r\n                                    if (parts.length === 6) {\r\n                                        // key is name\r\n                                        paramValue[parts[0]] = {\r\n                                            type: parts[1],\r\n                                            IsKdbParam: true,\r\n                                            isViewState: true,\r\n                                            name: parts[0],\r\n                                            value: parts[2],\r\n                                        };\r\n                                    }\r\n                                });\r\n\r\n                                queryParam.value = paramValue;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            return newParams;\r\n        }\r\n\r\n        public static generatePivotModel(idAttribute, childId, modelType, options) {\r\n            let topSelf = (this as unknown) as DocumentDataModel,\r\n                model;\r\n\r\n            if (options.breakdownCols instanceof Backbone.Model) {\r\n                options.breakdownCols = options.breakdownCols.get(\"value\");\r\n            }\r\n\r\n            // init empty meta set for wheres transform\r\n            topSelf.meta = {};\r\n\r\n            model = Backbone.Model.extend(\r\n                {\r\n                    defaults: {\r\n                        _dataType: topSelf.get(\"_dataType\"),\r\n                        _pivotType: topSelf.get(\"_pivotType\"),\r\n                        _subscriptionType: topSelf.get(\"_subscriptionType\"),\r\n                        _subscriptionInterval: topSelf.get(\"_subscriptionInterval\"),\r\n                    },\r\n                    idAttribute: idAttribute,\r\n                    childId: childId,\r\n                    childModelType: modelType,\r\n\r\n                    initialize: function() {\r\n                        this.isDirty = true;\r\n                        this.isPending = false;\r\n                        this.legacyUpdates = [];\r\n                        this.agent = new Agent();\r\n                    },\r\n\r\n                    apply() {\r\n                        this.dataSet = new DataSet({\r\n                            idAttribute: childId,\r\n                            collectionFunc: Backbone.Collection.extend({\r\n                                model: modelType,\r\n                            }),\r\n                            agent: this.agent,\r\n                            maxRows: options.maxRows,\r\n                            primaryKey: childId,\r\n                        });\r\n                    },\r\n\r\n                    getRoot: function() {\r\n                        return topSelf;\r\n                    },\r\n\r\n                    getViewState: function() {\r\n                        return topSelf.getViewState();\r\n                    },\r\n\r\n                    execute: function(args) {\r\n                        let self = (this as unknown) as DocumentDataModel,\r\n                            clientExecutePending =\r\n                                !topSelf.clientPivotData ||\r\n                                topSelf.isDirty ||\r\n                                (args && args.intervalQuery),\r\n                            errorFn,\r\n                            executeFn = function(data?, buffer?) {\r\n                                self.onExecuteSuccess(\r\n                                    topSelf.executeClientPivotQuery(topSelf.clientPivotData, {\r\n                                        wheres: options.wheres,\r\n                                    }) as DCDS,\r\n                                    topSelf.get(\"_forceReset\"),\r\n                                    undefined,\r\n                                );\r\n                            };\r\n\r\n                        if (!this.wheres) {\r\n                            this.wheres = options.wheres;\r\n                        }\r\n\r\n                        self.onExecuteBegin();\r\n                        try {\r\n                            options.topX = null;\r\n                            options.ordering = null;\r\n                            options.queryParams = topSelf.bindViewStateToKdbParams(\r\n                                topSelf.get(\"_queryParams\"),\r\n                            );\r\n                            options.maxRows =\r\n                                topSelf.get(\"_maxRows\") || DocumentDataModel.DEFAULT_MAX_ROWS;\r\n                            options.queryString = options.queryString;\r\n\r\n                            // options only contain wheres from level 1 on\r\n                            _.each(options.wheres, function(where, i) {\r\n                                const whereKey =\r\n                                    typeof where === \"string\" ? where : where.columnName;\r\n                                const columnType = topSelf.meta[whereKey];\r\n                                // transform where to object with type information from top meta set\r\n                                options.wheres[i] = {\r\n                                    columnName: whereKey,\r\n                                    columnType: columnType,\r\n                                    columnOperator: \"=\",\r\n                                    columnValue: self.get(whereKey),\r\n                                };\r\n                            });\r\n\r\n                            errorFn = function(error) {\r\n                                topSelf.onError(model, options, error, \"Error\", arguments);\r\n                            };\r\n\r\n                            if (self.get(\"_pivotType\") === \"client\") {\r\n                                if (clientExecutePending) {\r\n                                    topSelf.runWithConnectionCheck(errorFn, function() {\r\n                                        switch (topSelf.get(\"_dataType\")) {\r\n                                            case \"query\":\r\n                                                DashClient.getQueryData(\r\n                                                    \"kdb\",\r\n                                                    topSelf.get(\"_connection\"),\r\n                                                    options.queryString,\r\n                                                    options.queryParams,\r\n                                                    function(data) {\r\n                                                        if (data) {\r\n                                                            topSelf.clientPivotData = data;\r\n                                                            executeFn();\r\n                                                        } else {\r\n                                                            executeFn(data);\r\n                                                        }\r\n                                                    },\r\n                                                    errorFn,\r\n                                                    null,\r\n                                                    null,\r\n                                                    topSelf.performance,\r\n                                                );\r\n                                                break;\r\n                                            case \"virtual\":\r\n                                                topSelf.executeVirtualQuery(\r\n                                                    topSelf.get(\"_virtualQueryString\"),\r\n                                                    topSelf.get(\"_virtualParams\"),\r\n                                                    function(data) {\r\n                                                        topSelf.clientPivotData = data;\r\n                                                        executeFn();\r\n                                                    },\r\n                                                );\r\n                                                break;\r\n                                        }\r\n                                    });\r\n                                } else {\r\n                                    executeFn();\r\n                                }\r\n                            } else {\r\n                                topSelf.runWithConnectionCheck(errorFn, function() {\r\n                                    DashClientLib.getPivotData(\r\n                                        options,\r\n                                        function(data, buffer) {\r\n                                            //data = ipc.Parse.reshape(data, buffer);\r\n                                            // add to top meta set for where transform above - set from level 0 on\r\n                                            _.extend(topSelf.meta, data[\"meta\"]);\r\n\r\n                                            // on success\r\n                                            self.onExecuteSuccess(\r\n                                                data,\r\n                                                topSelf.get(\"_forceReset\"),\r\n                                                buffer,\r\n                                                topSelf.meta,\r\n                                            );\r\n                                        },\r\n                                        errorFn,\r\n                                        topSelf.performance,\r\n                                    );\r\n                                });\r\n                            }\r\n                        } catch (e) {\r\n                            topSelf.onError(model, options, e, \"Error\", arguments);\r\n                        }\r\n                    },\r\n\r\n                    exportPivotData: function(callback, errorCallback) {\r\n                        errorCallback(\"Pivot export not supported\");\r\n                    },\r\n\r\n                    /* eslint-disable @typescript-eslint/unbound-method */\r\n                    clearVirtualSubscriptions: _.noop,\r\n                    clearVirtualSubscriptionsAll: _.noop,\r\n                    executeClientPivotQuery: topSelf.executeClientPivotQuery,\r\n                    formatValue: topSelf.formatValue,\r\n                    getViewStateAttribute: topSelf.getViewStateAttribute,\r\n                    isPagingData: topSelf.isPagingData,\r\n                    legacyFlush: topSelf.legacyFlush,\r\n                    legacyUpdate: topSelf.legacyUpdate,\r\n                    logPrefix: topSelf.logPrefix,\r\n                    onComplete: topSelf.onComplete,\r\n                    onExecuteBegin: topSelf.onExecuteBegin,\r\n                    onExecuteSuccess: topSelf.onExecuteSuccess,\r\n                    reset: topSelf.reset,\r\n                    start: topSelf.start,\r\n                    stop: topSelf.stop,\r\n                    subscribe: topSelf.subscribe,\r\n                    triggerCallbacks: _.noop,\r\n                    updateVirtualSubscriptions: _.noop,\r\n                    unsubscribe: topSelf.unsubscribe,\r\n                    /* eslint-enable @typescript-eslint/unbound-method */\r\n                },\r\n                {\r\n                    staticIdAttribute: idAttribute,\r\n                },\r\n            );\r\n\r\n            return model;\r\n        }\r\n\r\n        public static connectionCollectionSync(method: string, collection: any, options: any) {\r\n            switch (method) {\r\n                case \"read\":\r\n                    DashClient.runAPI(\r\n                        \".api.conList\",\r\n                        \"gw\",\r\n                        [],\r\n                        data =>\r\n                            options.success(\r\n                                _.map(data.rows, r => {\r\n                                    r.type = r.dbtype;\r\n                                    delete r.type;\r\n                                    r.password = r.pass;\r\n                                    delete r.pass;\r\n                                    return r;\r\n                                }),\r\n                            ),\r\n                        e => options.error(e),\r\n                    );\r\n                    break;\r\n                default:\r\n                    throw \"data operation not supported for DocumentCollection\";\r\n            }\r\n        }\r\n\r\n        public static connectionSync(method: string, collection: any, options: any) {\r\n            let connection,\r\n                model = (this as unknown) as Backbone.Model;\r\n\r\n            switch (method) {\r\n                case \"update\":\r\n                    connection = {};\r\n                    connection.originalName = model.get(\"originalName\");\r\n                case \"create\":\r\n                    connection = _.extend(connection || {}, {\r\n                        name: model.id,\r\n                        dbtype: model.get(\"type\"),\r\n                        tls: model.get(\"tls\"),\r\n                        host: model.get(\"host\"),\r\n                        port: model.get(\"port\"),\r\n                        user: model.get(\"user\"),\r\n                        pass: model.get(\"password\"),\r\n                        database: \"\",\r\n                    });\r\n\r\n                    // call updateConnections for create & update\r\n                    DashClient.runAPI(\r\n                        \".api.conUpsert\",\r\n                        \"gw\",\r\n                        [\r\n                            { type: \"symbol\", value: model.id },\r\n                            { type: \"string\", value: JSON.stringify(connection) },\r\n                        ],\r\n                        data => options.success(data),\r\n                        e => options.error(e),\r\n                    );\r\n                    break;\r\n                case \"delete\":\r\n                    DashClient.runAPI(\r\n                        \".api.conDelete\",\r\n                        \"gw\",\r\n                        [{ type: \"symbol\", value: model.id }],\r\n                        () => options.success(),\r\n                        e => options.error(e),\r\n                    );\r\n                    break;\r\n                default:\r\n                    throw \"data operation not supported for Document\";\r\n            }\r\n        }\r\n\r\n        public static documentCollectionSync(method: string, collection: any, options: any) {\r\n            switch (method) {\r\n                case \"read\":\r\n                    DashClient.runAPI(\r\n                        \".api.dashList\",\r\n                        \"gw\",\r\n                        [],\r\n                        function(data) {\r\n                            const dashboards = [];\r\n                            data.rows.forEach(r => {\r\n                                try {\r\n                                    dashboards.push(\r\n                                        new QuickBase.Document(JSON.parse(r.description)),\r\n                                    );\r\n                                } catch (e) {\r\n                                    // nothin here\r\n                                    Log.Error(\"Error parsing dashboard description\", r);\r\n                                }\r\n                            });\r\n\r\n                            if (options.success) {\r\n                                // HAVE TO RETURN MODELS IN ORDER TO WORK!!!\r\n                                options.success(dashboards);\r\n                            }\r\n                        },\r\n                        function(data) {\r\n                            alert(\"Retrieve Dashboards FAILED\");\r\n                            if (options.error) {\r\n                                options.error(data);\r\n                            }\r\n                        },\r\n                    );\r\n                    break;\r\n                default:\r\n                    throw \"data operation not supported for DashCollection\";\r\n            }\r\n        }\r\n\r\n        public static documentSync(method: string, collection: any, options: any) {\r\n            let dashboard,\r\n                model = (this as unknown) as Backbone.Model;\r\n\r\n            switch (method) {\r\n                case \"read\":\r\n                    DashClient.runAPI(\r\n                        \".api.dashRead\",\r\n                        \"gw\",\r\n                        [{ type: \"symbol\", value: model.id }],\r\n                        function(data) {\r\n                            try {\r\n                                dashboard = JSON.parse(data.rows[0].string);\r\n                            } catch (e) {\r\n                                options.error && options.error(e);\r\n                            }\r\n\r\n                            options.success && options.success(dashboard);\r\n                        },\r\n                        function(e) {\r\n                            options.error && options.error(e);\r\n                        },\r\n                    );\r\n                    break;\r\n                case \"update\":\r\n                    DashClient.runAPI(\r\n                        \".api.dashUpsert\",\r\n                        \"gw\",\r\n                        [\r\n                            { type: \"symbol\", value: model.id },\r\n                            {\r\n                                type: \"string\",\r\n                                value: JSON.stringify(\r\n                                    _.omit(model.attributes, [\"permissionEntity\"]),\r\n                                    null,\r\n                                    2,\r\n                                ),\r\n                            },\r\n                        ],\r\n                        function() {\r\n                            options.success && options.success(model.attributes);\r\n                        },\r\n                        function(e) {\r\n                            options.error && options.error(e);\r\n                        },\r\n                    );\r\n\r\n                    break;\r\n                case \"delete\":\r\n                    DashClient.runAPI(\r\n                        \".api.dashDelete\",\r\n                        \"gw\",\r\n                        [{ type: \"symbol\", value: model.id }],\r\n                        function() {\r\n                            options.success && options.success();\r\n                        },\r\n                        function(e) {\r\n                            options.error && options.error(e);\r\n                        },\r\n                    );\r\n                    break;\r\n                default:\r\n                    throw \"data operation not supported for Document\";\r\n            }\r\n        }\r\n\r\n        public static replaceParameters(str, paramObjs) {\r\n            let fnRx = /^\\{(\\[([^\\]]+)\\])?(.*)\\}$/,\r\n                inlineRx = /<%[^<>%]+%>/g,\r\n                paramValueRx,\r\n                matches,\r\n                params,\r\n                paramCount = 0;\r\n\r\n            if (typeof str === \"string\") {\r\n                str = this.strip(str);\r\n                matches = fnRx.exec(str);\r\n                if (matches && matches.length === 4) {\r\n                    if (matches[2]) {\r\n                        params = matches[2].split(\";\");\r\n                        paramCount += params.length;\r\n                        return (\r\n                            str +\r\n                            \"[\" +\r\n                            _.map(params, function(p, i) {\r\n                                /*\r\n                            TODO dict\r\n                            var val = paramObjs[i].value;\r\n                            if (val && _.isObject(val)) {\r\n                                var typeDef = RTTI.getByName('dict');\r\n                                return typeDef.toKDBInput(val);\r\n                            }*/\r\n\r\n                                const val = RTTI.getByName(paramObjs[i].type).toKDBInput(\r\n                                    paramObjs[i].value,\r\n                                );\r\n\r\n                                return val;\r\n                            }).join(\";\") +\r\n                            \"]\"\r\n                        );\r\n                    } else {\r\n                        return str + \"[]\";\r\n                    }\r\n                }\r\n\r\n                // replace inline params\r\n                str = str.replace(inlineRx, function(m) {\r\n                    const i = paramCount++;\r\n                    return RTTI.getByName(paramObjs[i].type).toKDBInput(paramObjs[i].value);\r\n                });\r\n            }\r\n\r\n            return str;\r\n        }\r\n\r\n        public static stop() {\r\n            const self = (this as unknown) as DocumentDataModel;\r\n\r\n            if (self.pollingEvent) {\r\n                // destroy polling event\r\n                clearInterval(self.pollingEvent);\r\n                self.pollingEvent = null;\r\n            }\r\n\r\n            if (self.subscriptionId) {\r\n                DashClient.client.unsubscribe(self.subscriptionId);\r\n                self.subscriptionId = null;\r\n                self.isPending = false;\r\n            }\r\n        }\r\n\r\n        public static getPivotData(options, callback, errorCallback, performance?) {\r\n            DashClient.getQueryData(\r\n                \"q\",\r\n                options.connection,\r\n                Pivot.constructPivotQuery(options),\r\n                options.queryParams,\r\n                function(data, buffer) {\r\n                    callback(data, buffer);\r\n                },\r\n                errorCallback,\r\n                options.maxRows,\r\n                undefined,\r\n                performance,\r\n            );\r\n        }\r\n\r\n        public static parameterRx = new RegExp(\"<%([^<>%]+?)%>\", \"g\");\r\n        public static DEFAULT_NULL_VALL = -9223372036854776000; //if a value of 0N is returned this comes back from delta client\r\n\r\n        public static strip(query) {\r\n            return query && query.length > 0\r\n                ? query.replace(/((^|\\s+)\\/.*$)|^\\s+|\\s*\\n/gm, \" \").trim()\r\n                : query;\r\n        }\r\n    }\r\n}\r\n","/// <reference path=\"../lib/jquery.cookie.ts\" />\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class Log {\n        public static Debug: Function;\n        public static Info: Function;\n        public static Log: Function;\n        public static Error: Function;\n        public static Handled: Function;\n        public static Warn: Function;\n        public static ServerLogLevel = 4;\n        private static clientLoggingEnabled: boolean;\n        private static logUploadConnected: boolean;\n\n        private static debounceRetryConnection = _.debounce(\n            function() {\n                Log.retryConnection(0);\n            },\n            300,\n            { maxWait: 1000 },\n        );\n\n        Error: (message: string, argument?: any) => {};\n        Handled: (message: string, argument?: any) => {};\n        Warn: (message: string, argument?: any) => {};\n        Debug: (message: string, argument?: any) => {};\n        Log: (message: string, argument?: any) => {};\n        Info: (message: string, argument?: any) => {};\n\n        public static attemptUpload(logString: string): void {\n            if (Log.logUploadConnected) {\n                DeltaClientLib.createLog(\n                    logString,\n                    function() {\n                        // do nothing\n                    },\n                    function() {\n                        Log.logUploadConnected = false;\n                        Log.storeLocal(logString);\n                        Log.debounceRetryConnection();\n                    },\n                );\n            } else {\n                Log.storeLocal(logString);\n            }\n        }\n\n        public static logPerformanceMetrics(\n            modelPath: string,\n            performanceMetrics: PerformanceMetrics,\n        ): void {\n            if (Log.clientLoggingEnabled) {\n                const perf = performanceMetrics.performance;\n                const totalTime = perf.onAgentNotify - perf.apply;\n                let logString =\n                    \"Performance Metrics<-->\" +\n                    moment().format(\"H:mm:ss.SSS\") +\n                    \"<-->\" +\n                    modelPath +\n                    \" (Roundtrip: \" +\n                    totalTime.toFixed(0) +\n                    \"ms)\" +\n                    \"<-->\";\n                const executionTimes = [];\n\n                const mapTimeValues = function(value) {\n                    const percentage = (value / totalTime) * 100;\n                    return value.toFixed(0) + \" ms  \" + percentage.toFixed(2) + \"%\";\n                };\n\n                executionTimes[0] = perf.serverStart ? perf.serverStart - perf.apply : 0;\n                executionTimes[1] =\n                    perf.serverStart && perf.serverEnd\n                        ? perf.serverEnd - perf.serverStart\n                        : totalTime;\n                executionTimes[2] = perf.serverEnd ? perf.onAgentNotify - perf.serverEnd : 0;\n\n                logString += \"Dispatch: \" + mapTimeValues(executionTimes[0]);\n                logString += \", Server Duration: \" + mapTimeValues(executionTimes[1]);\n                logString += \", IPC & Deserialize: \" + mapTimeValues(executionTimes[2]);\n\n                Log.attemptUpload(logString);\n            }\n        }\n\n        public static setClientLogging(): void {\n            Log.logUploadConnected = true;\n            Log.clientLoggingEnabled = true;\n            Log.traceConsoleError();\n            Log.trace(Tools.getCookie(\"dashboard-log-level\"));\n        }\n\n        public static trace(logLevelStr: string): void {\n            /* eslint-disable @typescript-eslint/unbound-method */\n            const logLevel = Number(logLevelStr);\n            if (Log.clientLoggingEnabled) {\n                Log.turnOnUploads(logLevel);\n            } else {\n                Log.Error =\n                    logLevel > 0\n                        ? console.error.bind(console, \"%s\", Log.logPrefix(Log.Level.Error))\n                        : _.noop;\n                Log.Handled =\n                    logLevel > 1\n                        ? console.error.bind(console, \"%s\", Log.logPrefix(Log.Level.Handled))\n                        : _.noop;\n                Log.Warn =\n                    logLevel > 1\n                        ? console.warn.bind(console, \"%s\", Log.logPrefix(Log.Level.Warn))\n                        : _.noop;\n                Log.Debug =\n                    logLevel > 2\n                        ? console.debug.bind(console, \"%s\", Log.logPrefix(Log.Level.Debug))\n                        : _.noop;\n                Log.Log =\n                    logLevel > 2\n                        ? console.log.bind(console, \"%s\", Log.logPrefix(Log.Level.Info))\n                        : _.noop;\n                Log.Info =\n                    logLevel > 3\n                        ? console.info.bind(console, \"%s\", Log.logPrefix(Log.Level.Info))\n                        : _.noop;\n            }\n            /* eslint-enable @typescript-eslint/unbound-method */\n        }\n\n        public static turnOnUploads(logLevel: number): void {\n            Log.Error = function(message: string, argument?: any) {\n                if (logLevel > 0) {\n                    console.error(message, argument || \"\");\n                }\n\n                if (Log.ServerLogLevel > 0) {\n                    Log.attemptUpload(Log.logUploadString(this.Level.Error, message, argument));\n                }\n            };\n\n            Log.Handled = function(message: string, argument?: any) {\n                if (logLevel > 1) {\n                    console.error(message, argument || \"\");\n                }\n\n                if (Log.ServerLogLevel > 1) {\n                    Log.attemptUpload(Log.logUploadString(this.Level.Handled, message, argument));\n                }\n            };\n\n            Log.Warn = function(message: string, argument?: any) {\n                if (logLevel > 1) {\n                    console.warn(Log.logPrefix(this.Level.Warn) + message, argument || \"\");\n                }\n\n                if (Log.ServerLogLevel > 2) {\n                    Log.attemptUpload(Log.logUploadString(this.Level.Warn, message, argument));\n                }\n            };\n\n            Log.Debug = function(message: string, argument?: any) {\n                if (logLevel > 2) {\n                    console.debug(Log.logPrefix(this.Level.Debug) + message, argument || \"\");\n                }\n\n                if (Log.ServerLogLevel > 2) {\n                    Log.attemptUpload(Log.logUploadString(this.Level.Debug, message, argument));\n                }\n            };\n\n            Log.Log = function(message: string, argument?: any) {\n                if (logLevel > 2) {\n                    console.log(Log.logPrefix(this.Level.Log) + message, argument || \"\");\n                }\n\n                if (Log.ServerLogLevel > 2) {\n                    Log.attemptUpload(Log.logUploadString(this.Level.Log, message, argument));\n                }\n            };\n\n            Log.Info = function(message: string, argument?: any) {\n                if (logLevel > 3) {\n                    console.info(Log.logPrefix(this.Level.Info) + message, argument || \"\");\n                }\n\n                if (Log.ServerLogLevel > 3) {\n                    Log.attemptUpload(Log.logUploadString(this.Level.Info, message, argument));\n                }\n            };\n        }\n\n        private static getStackTrace(): string {\n            const stack = new Error(\"\").stack || \"\";\n            return (\n                \"\\nStack Trace: \" +\n                stack\n                    .split(\"\\n\")\n                    .slice(3, 9)\n                    .join(\"\\n\")\n            );\n        }\n\n        private static logPrefix(level: Log.Level): Function {\n            const timestamp = function() {};\n            timestamp.toString = function() {\n                return level + \"\\t\" + moment().format(\"H:mm:ss.SSS\") + \"\\t\";\n            };\n            return timestamp;\n        }\n\n        private static logUploadString(\n            level: Log.Level,\n            message: string,\n            argument: Record<string, any>,\n        ): string {\n            let logString;\n            const timestamp = moment().format(\"H:mm:ss.SSS\");\n\n            logString = level + \"<-->\" + timestamp + \"<-->\" + message + \"<-->\";\n            if (argument) {\n                logString += JSON.stringify(argument);\n            }\n            if (level !== this.Level.Info) {\n                logString += Log.getStackTrace();\n            }\n            return logString;\n        }\n\n        private static retryConnection(timeout: number) {\n            const seconds = [1, 3, 15, 60, 180, 900];\n            if (timeout === seconds.length) timeout -= 1;\n            setTimeout(function() {\n                Log.uploadStoredLogs(timeout);\n            }, 1000 * seconds[timeout]);\n        }\n\n        // leading zeros added to ensure correct sequence of logs uploaded\n        // assumes key doesnt go above 9999, if it does it will rewrite at 0000 repeatedly\n        private static storeLocal(logString: string) {\n            let key,\n                newKey,\n                n = localStorage.length - 1;\n\n            // searches from end to find latest key added\n            if (localStorage.getItem(\"0000\")) {\n                while (!newKey) {\n                    key = localStorage.key(n);\n                    if (key.match(/\\d\\d\\d\\d/)) {\n                        newKey = (\"000\" + (parseInt(key) + 1)).slice(-4);\n                    }\n                    n -= 1;\n                }\n            } else {\n                newKey = \"0000\";\n            }\n            localStorage.setItem(newKey, logString);\n        }\n\n        private static traceConsoleError() {\n            const consoleError = console.error;\n            console.error = function(message, argument) {\n                const logString = Log.logPrefix(Log.Level.Error) + message;\n                consoleError.apply(console, [logString, argument || \"\"]);\n                Log.attemptUpload(Log.logUploadString(Log.Level.Error, message, argument));\n            };\n        }\n\n        // recursive function that calls itself to upload next log in sequence\n        // once callback received from deltaClient\n        private static uploadStoredLogs(timeout: number): void {\n            let key,\n                logString,\n                partialSuccess = false;\n\n            const uploadItem = function(index: number): void {\n                if (index < localStorage.length) {\n                    key = localStorage.key(index);\n\n                    if (key.match(/\\d\\d\\d\\d/)) {\n                        logString = localStorage.getItem(key);\n\n                        DeltaClientLib.createLog(\n                            logString,\n                            function() {\n                                partialSuccess = true;\n                                localStorage.removeItem(key);\n                                uploadItem(index);\n                            },\n                            function() {\n                                if (partialSuccess) {\n                                    Log.retryConnection(0);\n                                } else {\n                                    Log.retryConnection(timeout + 1);\n                                }\n                            },\n                        );\n                    } else {\n                        //moves onto next index if it does not match regex\n                        uploadItem(index + 1);\n                    }\n                } else {\n                    Log.logUploadConnected = true;\n                }\n            };\n            uploadItem(0);\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-namespace\n    export namespace Log {\n        export enum Level {\n            Info = \"INFO\",\n            Warn = \"WARN\",\n            Error = \"ERROR\",\n            Fatal = \"FATAL\",\n            Critical = \"CRITICAL\",\n            Off = \"OFF\",\n            Handled = \"HANDLED\",\n            Debug = \"DEBUG\",\n        }\n    }\n    Log.trace($.cookie(\"dashboard-log-level\"));\n\n    window.onerror = function(\n        message: string | Event,\n        source: string,\n        lineno: number,\n        colno: number,\n        error: Record<string, any>,\n    ): void {\n        /* eslint-disable @typescript-eslint/unbound-method */\n        message && message.toString ? message.toString() : \"\" + message;\n        error && error.toString ? error.toString() : \"\" + error;\n        DeltaClientLib.createLog(\n            message + \"<-->\" + moment().format(\"H:mm:ss.SSS\") + \"<-->\" + error,\n            _.noop,\n            _.noop,\n        );\n        /* eslint-enable @typescript-eslint/unbound-method */\n    };\n}\n","/*globals Backbone,_,$,console, win.Client, win.AckMessage, NackMessage, setTimeout, clearTimeout, win, kdb*/\r\n/// <reference path=\"../classes/log.ts\"/>\r\n/// <reference path=\"delta.d.ts\"/>\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    type ManagedQueryFn = (\r\n        connection: string,\r\n        query: string,\r\n        params: any[],\r\n        success: FnSuccess,\r\n        error: Function,\r\n        interval: number,\r\n        maxRows: number,\r\n        paging: any,\r\n        performance: PerformanceMetrics,\r\n    ) => void;\r\n\r\n    export class DCBase {\r\n        static host;\r\n        static port;\r\n        static secure;\r\n        static fromUrl;\r\n        static username;\r\n        static successCallback;\r\n        static errorCallback;\r\n        static token;\r\n        static appid;\r\n        static saml;\r\n        static forceLogin;\r\n        static clientLoggedIn = false;\r\n        static eCode: number | null;\r\n\r\n        static changingPassword = false;\r\n        static changingPasswordFailed = false;\r\n        static changingPasswordOld: string;\r\n        static changingPasswordNew: string;\r\n        static disconnected = false;\r\n\r\n        static properties;\r\n        static DEFAULT_TIMEOUT = 10000;\r\n\r\n        static deltaClient: win.Client;\r\n\r\n        static showLastLoginAttempts;\r\n\r\n        // yuck - these functions need to be set\r\n        static changingPasswordFail: (msg: string) => void;\r\n        static changingPasswordSuccess: () => void;\r\n\r\n        // used for legacy switching\r\n        static startManagedQuery: ManagedQueryFn;\r\n        static startManagedQuery2: ManagedQueryFn;\r\n        static startLegacyManagedQuery: ManagedQueryFn;\r\n        static startLegacyManagedQuery2: ManagedQueryFn;\r\n\r\n        static initializeDeltaClient(\r\n            host,\r\n            port,\r\n            secure,\r\n            fromUrl,\r\n            username,\r\n            password,\r\n            successCallback,\r\n            errorCallback,\r\n            token,\r\n            appid,\r\n            useBinary,\r\n            saml,\r\n            forceLogin,\r\n        ) {\r\n            this.host = host;\r\n            this.port = port;\r\n            this.secure = secure;\r\n            this.fromUrl = fromUrl;\r\n            this.username = username;\r\n            this.successCallback = successCallback;\r\n            this.errorCallback = errorCallback;\r\n            this.token = token;\r\n            this.appid = appid;\r\n            this.saml = saml;\r\n            this.forceLogin = forceLogin;\r\n            this.properties = {};\r\n            this.clientLoggedIn = false;\r\n            this.errorCallback = errorCallback;\r\n\r\n            if (!this.deltaClient) {\r\n                this.deltaClient = new win.Client(\r\n                    {\r\n                        host: this.host,\r\n                        port: this.port,\r\n                        secure: this.secure,\r\n                        fromURL: this.fromUrl,\r\n                    },\r\n                    useBinary,\r\n                    useBinary,\r\n                );\r\n\r\n                this.initDeltaClient(password);\r\n            } else {\r\n                this.saml\r\n                    ? this.deltaClient.register(\"dashboards\")\r\n                    : this.deltaClient.login(\r\n                          this.username,\r\n                          password,\r\n                          this.appid,\r\n                          [],\r\n                          this.forceLogin,\r\n                      );\r\n            }\r\n        }\r\n\r\n        static initializeDeltaClientCopy(\r\n            client,\r\n            host,\r\n            port,\r\n            secure,\r\n            fromUrl,\r\n            username,\r\n            password,\r\n            successCallback,\r\n            errorCallback,\r\n            appid,\r\n            saml,\r\n        ) {\r\n            this.host = host;\r\n            this.port = port;\r\n            this.secure = secure;\r\n            this.fromUrl = fromUrl;\r\n            this.username = username;\r\n            this.successCallback = successCallback;\r\n            this.errorCallback = errorCallback;\r\n            this.appid = appid;\r\n            this.saml = saml;\r\n            this.properties = {};\r\n            this.clientLoggedIn = true;\r\n\r\n            this.deltaClient = client;\r\n            this.deltaClient.DeltaClientLogin = true;\r\n\r\n            this.initDeltaClient(password);\r\n        }\r\n\r\n        static initDeltaClient(password) {\r\n            let wasConnected = false,\r\n                connectionTimeoutDelay = null;\r\n\r\n            this.deltaClient.status._subscribe({\r\n                next: data => {\r\n                    //console.log(data.type);\r\n                    switch (data.type) {\r\n                        case win.Client.status.CONNECTING:\r\n                            if (wasConnected) {\r\n                                //Disconnect not firing so if has been connected before fire disconnect event\r\n                                $(this).trigger(\"DeltaClientDisconnect\");\r\n                                this.disconnected = true;\r\n                            }\r\n\r\n                            this.eCode = data.eCode;\r\n                            if (!connectionTimeoutDelay) {\r\n                                connectionTimeoutDelay = _.delay(() => {\r\n                                    this.sendError(\r\n                                        this.eCode === 1006\r\n                                            ? \"WebSocket connection error, please check proxy settings\"\r\n                                            : \"Server connectivity issues, please try again.\",\r\n                                    );\r\n                                }, this.DEFAULT_TIMEOUT);\r\n                            }\r\n                            break;\r\n                        case win.Client.status.CONNECTED:\r\n                            try {\r\n                                //this.changeUserPassword.call(this);\r\n                                wasConnected = true;\r\n\r\n                                const sysConfig = this.deltaClient.systemConfig();\r\n                                if (sysConfig) {\r\n                                    this.showLastLoginAttempts = sysConfig.showLastLoginAttempts;\r\n                                }\r\n\r\n                                if (this.clientLoggedIn) {\r\n                                    $(this).trigger(\"DeltaClientConnect\");\r\n                                } else this.onFirstLogin();\r\n\r\n                                clearTimeout(connectionTimeoutDelay);\r\n                                $.cookie(\"deltaToken\", this.deltaClient.tokenKey(), {\r\n                                    expires: 30,\r\n                                    path: \"/\",\r\n                                });\r\n                                connectionTimeoutDelay = null;\r\n                            } catch (e) {\r\n                                this.sendError(\r\n                                    \"There was a problem connecting to the server: \" + e,\r\n                                );\r\n                            }\r\n                            break;\r\n                        /*case win.Client.status.DISCONNECTED:\r\n                            $(this).trigger('DeltaClientDisconnect');\r\n                            this.disconnected = true;\r\n                            break;*/\r\n                        case win.Client.status.LOGGED_IN:\r\n                            // called in host / auto scenario\r\n                            clearTimeout(connectionTimeoutDelay);\r\n                            connectionTimeoutDelay = null;\r\n\r\n                            this.username = this.deltaClient.user();\r\n\r\n                            // set deltaToken to be the current tokenKey()\r\n                            // $.cookie('deltaToken', this.deltaClient.tokenKey(), { expires: 30, path: '/' });\r\n\r\n                            break;\r\n                        case win.Client.status.LOGGED_OUT:\r\n                            //console.log(\"user logged out\");\r\n                            if (\r\n                                this.changingPassword &&\r\n                                _.isString(data.data) &&\r\n                                data.data.indexOf(\"Client action\") !== -1\r\n                            ) {\r\n                                // delay password change otherwise it will not work\r\n                                setTimeout(function() {\r\n                                    this.changingPasswordFailed = false;\r\n                                    // this will change password and login the user\r\n                                    this.deltaClient.resetPassword(\r\n                                        this.username,\r\n                                        this.changingPasswordOld,\r\n                                        this.changingPasswordNew,\r\n                                    );\r\n                                }, 500);\r\n                            } else if (\r\n                                _.isString(data.data) &&\r\n                                data.data.indexOf(\"no connection available\") === -1\r\n                            ) {\r\n                                // user initiated logout or session timeout\r\n                                $.removeCookie(\"deltaToken\", { path: \"/\" });\r\n\r\n                                if (this.saml) {\r\n                                    this.ssoLogout(\"local\");\r\n                                } else {\r\n                                    if (data.data.indexOf(\"timeout\") !== -1) {\r\n                                        $.cookie(\"deltaLoginError\", \"Your session timed out\", {\r\n                                            expires: 30,\r\n                                            path: \"/\",\r\n                                        });\r\n                                    } else if (data.data.indexOf(\"session limit\") !== -1) {\r\n                                        $.cookie(\"deltaLoginError\", data.data.split(\"|\")[2], {\r\n                                            expires: 30,\r\n                                            path: \"/\",\r\n                                        });\r\n                                    } else {\r\n                                        $.removeCookie(\"deltaLoginError\", { path: \"/\" });\r\n                                    }\r\n\r\n                                    // at this stage there is no point handling before unload as user is logged out\r\n                                    window.onbeforeunload = function(e) {}; // override Dashboards save notification\r\n                                    location.reload();\r\n                                }\r\n                            } else if (!data.data && this.disconnected) {\r\n                                // data is not defined on appServer bounce\r\n                                this.errorCallback(\"loginRequired\");\r\n                            }\r\n                            break;\r\n                        case win.Client.status.EXPIRED:\r\n                            clearTimeout(connectionTimeoutDelay);\r\n                            connectionTimeoutDelay = null;\r\n                            Log.Log(\"Expired\", data);\r\n                            this.sendError(\"Your password has expired\");\r\n                            break;\r\n                        case win.Client.status.RESET:\r\n                            clearTimeout(connectionTimeoutDelay);\r\n                            connectionTimeoutDelay = null;\r\n                            $(this).trigger(\"Reset\");\r\n                            this.sendError(\"Please reset password\");\r\n                            Log.Log(\"Reset\", data);\r\n                            break;\r\n                        case win.Client.status.RESET_FAIL:\r\n                            clearTimeout(connectionTimeoutDelay);\r\n                            connectionTimeoutDelay = null;\r\n                            this.changingPasswordFail && this.changingPasswordFail(data[\"data\"]);\r\n                            this.changingPasswordFailed = true;\r\n                            Log.Log(\"Reset Fail\", data);\r\n                            break;\r\n                        case win.Client.status.RESET_SUCCESS:\r\n                            if (this.changingPassword) {\r\n                                if (this.changingPasswordFailed) {\r\n                                    this.changingPassword = false;\r\n                                } else {\r\n                                    // changing password\r\n                                    // call password changed callback\r\n                                    this.changingPasswordSuccess && this.changingPasswordSuccess();\r\n                                    // reset\r\n                                    this.changingPassword = false;\r\n                                    this.changingPasswordFail = null;\r\n                                    this.changingPasswordSuccess = null;\r\n                                    this.changingPasswordOld = null;\r\n                                    this.changingPasswordNew = null;\r\n                                    this.successCallback && this.successCallback();\r\n                                    // The deltaToken in use is no longer valid so prompt user to log in again on next refresh\r\n                                    $.cookie(\r\n                                        \"deltaLoginError\",\r\n                                        \"Password changed. Please login again.\",\r\n                                        { expires: 30, path: \"/\" },\r\n                                    );\r\n                                    $.removeCookie(\"deltaToken\", { path: \"/\" });\r\n                                }\r\n                            }\r\n                            break;\r\n                        case win.Client.status.FAULT:\r\n                            Log.Log(\"Fault\", data);\r\n                            // wrong user / password or token\r\n                            clearTimeout(connectionTimeoutDelay);\r\n                            connectionTimeoutDelay = null;\r\n\r\n                            if (data[\"data\"] !== \"userSessionLimit\") {\r\n                                $.removeCookie(\"deltaToken\", { path: \"/\" });\r\n                            }\r\n\r\n                            this.sendError(data[\"data\"]);\r\n                            break;\r\n                    }\r\n                },\r\n                error: function() {\r\n                    Log.Error(\"onError\", arguments);\r\n                },\r\n                complete: function() {\r\n                    Log.Info(\"onCompleted\", arguments);\r\n                },\r\n            });\r\n\r\n            // prefer token if we have one\r\n            this.token = this.token || this.deltaClient.tokenKey();\r\n\r\n            if (!this.deltaClient.DeltaClientLogin) {\r\n                if (this.saml) {\r\n                    this.deltaClient.register(\"dashboards\");\r\n                } else if (this.token) {\r\n                    this.deltaClient.loginWithTokenKey(this.token, this.appid);\r\n                } else {\r\n                    this.deltaClient.login(\r\n                        this.username,\r\n                        password,\r\n                        this.appid,\r\n                        [],\r\n                        this.forceLogin,\r\n                    );\r\n                    password = null;\r\n                }\r\n            } else {\r\n                this.onFirstLogin();\r\n            }\r\n        }\r\n\r\n        static getDashboardProperty(key) {\r\n            return this.properties[key];\r\n        }\r\n\r\n        static changeUserPassword(\r\n            oldPass: string,\r\n            newPass: string,\r\n            success: () => void,\r\n            error: (e: any) => void,\r\n        ) {\r\n            // can't change password when user logged in\r\n            if (!this.changingPassword) {\r\n                this.changingPassword = true;\r\n                this.changingPasswordOld = oldPass;\r\n                this.changingPasswordNew = newPass;\r\n                this.changingPasswordSuccess = success;\r\n                this.changingPasswordFail = error;\r\n                this.changingPasswordFailed = false;\r\n\r\n                // this will change password and login the user\r\n                this.deltaClient.resetPassword(\r\n                    this.username,\r\n                    this.changingPasswordOld,\r\n                    this.changingPasswordNew,\r\n                );\r\n            }\r\n        }\r\n\r\n        static onFirstLogin() {\r\n            // get settings timezone, etc then trigger login\r\n            this.deltaClient.request(\r\n                \"ConfigAPI.getConfigParameter\",\r\n                data => {\r\n                    data.rows.forEach(kvp => {\r\n                        this.properties[kvp.Property.elementValue] = kvp.Value.elementValue;\r\n                    });\r\n\r\n                    // configure legacy managed\r\n                    if (this.properties[\"legacy_managed\"] == \"true\") {\r\n                        this.startManagedQuery = this.startLegacyManagedQuery;\r\n                        this.startManagedQuery2 = this.startLegacyManagedQuery2;\r\n                    }\r\n\r\n                    Tools.timezone =\r\n                        $.cookie(\"dashboard-timezone\") ||\r\n                        this.properties[\"timezone\"] ||\r\n                        moment.tz.guess();\r\n\r\n                    this.clientLoggedIn = true;\r\n                    if (this.deltaClient.clientLoggingEnabled()) {\r\n                        if (this.properties.hasOwnProperty(\"log-level\")) {\r\n                            // set server side log level\r\n                            Log.ServerLogLevel = Number(this.properties[\"log-level\"]);\r\n                        }\r\n\r\n                        Log.setClientLogging();\r\n                    }\r\n\r\n                    $(this).trigger(\"DeltaClientLogin\");\r\n                    this.deltaClient.DeltaClientLogin = true;\r\n                    this.successCallback && this.successCallback();\r\n                    $(this).trigger(\"DeltaClientConnect\");\r\n                },\r\n                _.noop,\r\n                \"DASHproperties\",\r\n                \"DEFAULT\",\r\n                \"delta_install_default\",\r\n            );\r\n        }\r\n\r\n        static sendError(message, detail?) {\r\n            if (this.errorCallback) {\r\n                this.errorCallback(message);\r\n            }\r\n        }\r\n\r\n        static ssoLogout(logoutType) {\r\n            this.deltaClient.ssoLogout(logoutType);\r\n        }\r\n    }\r\n}\r\n","// eslint-disable-next-line @typescript-eslint/no-namespace\nnamespace QuickBase {\n    export const enum Op {\n        Heartbeat = 0,\n        API = 1,\n        Query = 2,\n        Subscribe = 3,\n        Unsubscribe = 4,\n        Error = 5,\n        State = 6,\n    }\n}\n","// 2016.09.15 performance enhancement for temporal constructors and type identification\r\n// 2016.03.18 char vectors and symbols now [de]serialize [from]to utf8\r\n// 2014.03.18 Serialize date now adjusts for timezone.\r\n// 2013.04.29 Dict decodes to map, except for keyed tables.\r\n// 2013.02.13 Keyed tables were not being decoded correctly.\r\n// 2012.06.20 Fix up browser compatibility. Strings starting with ` encode as symbol type.\r\n// 2012.05.15 Provisional test release, subject to change\r\n// for use with websockets and kdb+v3.0, (de)serializing kdb+ ipc formatted data within javascript within a browser.\r\n// e.g. on kdb+ process, set .z.ws:{neg[.z.w] -8!value -9!x;}\r\n// and then within javascript websocket.send(serialize(\"10+20\"));\r\n// ws.onmessage=function(e){var arrayBuffer=e.data;if(arrayBuffer){var v=deserialize(arrayBuffer);...\r\n// note ws.binaryType = 'arraybuffer';\r\n/// <reference path=\"liteOp.ts\" />\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class DCRequest {\r\n        op: Op;\r\n        connectionId?: string;\r\n        query?: any;\r\n        timestamp: number;\r\n        success: Function;\r\n        error: Function;\r\n\r\n        constructor(\r\n            op: Op,\r\n            connectionId?: string,\r\n            query?: any,\r\n            success?: Function,\r\n            error?: Function,\r\n        ) {\r\n            this.op = op;\r\n            this.connectionId = connectionId;\r\n            this.query = query;\r\n            this.success = success || function() {};\r\n            this.error = error || function() {};\r\n            this.timestamp = new Date().getTime();\r\n        }\r\n    }\r\n\r\n    export interface qTyped {\r\n        qtype: number;\r\n    }\r\n\r\n    export class qAtom implements qTyped {\r\n        \"offset\": number;\r\n        \"qtype\": number;\r\n\r\n        constructor(offset: number, qtype: number) {\r\n            this[\"offset\"] = offset;\r\n            this[\"qtype\"] = qtype;\r\n        }\r\n    }\r\n\r\n    export class qVector extends qAtom {\r\n        \"length\": number;\r\n        \"isSorted\": boolean;\r\n        constructor(qtype: number, isSorted: boolean, length: number, offset: number) {\r\n            super(offset, qtype);\r\n            this[\"isSorted\"] = isSorted;\r\n            this[\"length\"] = length;\r\n        }\r\n    }\r\n\r\n    export class qGenericList implements qTyped {\r\n        \"qtype\" = 0;\r\n        \"values\": Array<qTyped>;\r\n        \"end\": number;\r\n        \"isSorted\": boolean;\r\n        constructor(isSorted: boolean, values: Array<qTyped>, end: number) {\r\n            this[\"isSorted\"] = isSorted;\r\n            this[\"values\"] = values;\r\n            this[\"end\"] = end;\r\n        }\r\n    }\r\n\r\n    export class qSymList implements qTyped {\r\n        \"qtype\" = 11;\r\n        \"offsets\": Array<number>;\r\n        \"isSorted\": boolean;\r\n        constructor(isSorted: boolean, offsets: Array<number>) {\r\n            this[\"isSorted\"] = isSorted;\r\n            this[\"offsets\"] = offsets;\r\n        }\r\n    }\r\n\r\n    export class qDict implements qTyped {\r\n        \"qtype\": number;\r\n        \"keys\": qVector | qSymList | qGenericList | qDict;\r\n        \"values\": qVector | qSymList | qGenericList | qDict;\r\n        \"isSorted\": boolean;\r\n        constructor(\r\n            qtype: number,\r\n            isSorted: boolean,\r\n            keys: qVector | qSymList | qGenericList | qDict,\r\n            values: qVector | qSymList | qGenericList | qDict,\r\n        ) {\r\n            this[\"keys\"] = keys;\r\n            this[\"values\"] = values;\r\n            this[\"qtype\"] = qtype;\r\n            this[\"isSorted\"] = isSorted;\r\n        }\r\n    }\r\n\r\n    export function getTypeSize(qType: number) {\r\n        switch (qType) {\r\n            case 1: // boolean\r\n            case 4: // byte\r\n            case 10: // char\r\n                return 1;\r\n            case 5: // short\r\n                return 2;\r\n            case 6: // int\r\n            case 8: // real (single)\r\n            case 13: // month\r\n            case 14: // date\r\n            case 17: // minute\r\n            case 18: // second\r\n            case 19: // time\r\n                return 4;\r\n            case 7: // long\r\n            case 9: // float (double)\r\n            case 12: // timestamp\r\n            case 15: // datetime\r\n            case 16: // timespan\r\n                return 8;\r\n            case 2: // guid\r\n                return 16;\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n\r\n    export function u8u16(u16: string): Array<number> {\r\n        const u8 = [];\r\n        for (let i = 0; i < u16.length; i++) {\r\n            let c = u16.charCodeAt(i);\r\n            if (c < 0x80) u8.push(c);\r\n            else if (c < 0x800) u8.push(0xc0 | (c >> 6), 0x80 | (c & 0x3f));\r\n            else if (c < 0xd800 || c >= 0xe000)\r\n                u8.push(0xe0 | (c >> 12), 0x80 | ((c >> 6) & 0x3f), 0x80 | (c & 0x3f));\r\n            else {\r\n                c = 0x10000 + (((c & 0x3ff) << 10) | (u16.charCodeAt(++i) & 0x3ff));\r\n                u8.push(\r\n                    0xf0 | (c >> 18),\r\n                    0x80 | ((c >> 12) & 0x3f),\r\n                    0x80 | ((c >> 6) & 0x3f),\r\n                    0x80 | (c & 0x3f),\r\n                );\r\n            }\r\n        }\r\n        return u8;\r\n    }\r\n\r\n    export function u16u8(u8: ArrayLike<number>): string {\r\n        let u16 = \"\",\r\n            c,\r\n            c1,\r\n            c2;\r\n        for (let i = 0; i < u8.length; i++) {\r\n            switch ((c = u8[i]) >> 4) {\r\n                case 0:\r\n                case 1:\r\n                case 2:\r\n                case 3:\r\n                case 4:\r\n                case 5:\r\n                case 6:\r\n                case 7:\r\n                    u16 += String.fromCharCode(c);\r\n                    break;\r\n                case 12:\r\n                case 13:\r\n                    c1 = u8[++i];\r\n                    u16 += String.fromCharCode(((c & 0x1f) << 6) | (c1 & 0x3f));\r\n                    break;\r\n                case 14:\r\n                    c1 = u8[++i];\r\n                    c2 = u8[++i];\r\n                    u16 += String.fromCharCode(\r\n                        ((c & 0x0f) << 12) | ((c1 & 0x3f) << 6) | ((c2 & 0x3f) << 0),\r\n                    );\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return u16;\r\n    }\r\n\r\n    // deserialize with less delta specific hacks\r\n    export function deserialize(x: ArrayBuffer, offset?: number, isLite?: boolean) {\r\n        let pos: number = offset || 8;\r\n        const dataView = new DataView(x);\r\n\r\n        function rInt8(): number {\r\n            return dataView.getInt8(pos++);\r\n        }\r\n\r\n        function rUInt8(): number {\r\n            return dataView.getUint8(pos++);\r\n        }\r\n\r\n        function rInt32(): number {\r\n            const ret = dataView.getInt32(pos, true);\r\n            pos += 4;\r\n            return ret;\r\n        }\r\n\r\n        function rSymbol() {\r\n            let c,\r\n                s = [];\r\n            while ((c = dataView.getUint8(pos++)) !== 0) s.push(c);\r\n            return u16u8(s);\r\n        }\r\n\r\n        function parseAtom(t: number): qAtom {\r\n            const column = new qAtom(pos, t);\r\n            const sz = getTypeSize(-t);\r\n            if (sz) {\r\n                // if size then is a fixed row advance\r\n                pos += sz;\r\n            } else if (t === -11) {\r\n                // if symbol, need to index by scanning 0 terminated strings\r\n                let c;\r\n                while ((c = rUInt8()) !== 0) {}\r\n            } else {\r\n                throw \"Unsupported type\";\r\n            }\r\n\r\n            return column;\r\n        }\r\n\r\n        function parseList(t: number): qVector | qGenericList | qSymList {\r\n            const isSorted = rUInt8() === 1;\r\n            const n = rInt32();\r\n            const sz = getTypeSize(t);\r\n\r\n            if (sz) {\r\n                // if size then is a fixed row advance\r\n                const column = new qVector(t, isSorted, n, pos);\r\n                pos += n * sz;\r\n                return column;\r\n            } else if (t === 11) {\r\n                // if symbol, need to index by scanning 0 terminated strings\r\n                const offsets = new Array(n);\r\n                for (let i = 0; i < n; i++) {\r\n                    offsets[i] = pos;\r\n                    let c: number;\r\n                    while ((c = rUInt8()) !== 0) {}\r\n                }\r\n                return new qSymList(isSorted, offsets);\r\n            } else if (t === 0) {\r\n                // mixed list is more complicated\r\n                const values = new Array(n);\r\n                for (let i = 0; i < n; i++) {\r\n                    values[i] = r();\r\n                }\r\n                return new qGenericList(isSorted, values, pos);\r\n            }\r\n\r\n            throw \"Unsupported type\";\r\n        }\r\n\r\n        function parseTable(): qDict {\r\n            const isSorted = rUInt8() === 1;\r\n            const checkT = rInt8(); // check type is 99 here\r\n            if (checkT !== 99) {\r\n                console.error(\"c.js Assertion type=99 failed.\");\r\n            }\r\n\r\n            return new qDict(98, isSorted, parseList(rInt8()), parseList(rInt8()));\r\n        }\r\n\r\n        function parseDict(): qDict {\r\n            const flip = 98 === dataView.getUint8(pos);\r\n\r\n            if (!flip) {\r\n                const keys = parseList(rInt8());\r\n                const t = rUInt8();\r\n                const vals = t === 98 ? parseTable() : parseList(t);\r\n                return new qDict(99, false, keys, vals);\r\n            } else {\r\n                // sorted keyed table\r\n                // delta client table -8!([a:enlist 2]b:enlist 3)\r\n                const isSorted = rUInt8() === 1;\r\n                const a = parseTable();\r\n                pos++;\r\n                const b = parseTable();\r\n\r\n                return new qDict(99, isSorted, a, b);\r\n            }\r\n        }\r\n\r\n        function r(): qTyped {\r\n            const t: number = rInt8();\r\n\r\n            // parse SINGLE\r\n            if (-20 < t && t < 0) {\r\n                return parseAtom(t);\r\n            }\r\n\r\n            // skip EXOTIC shit\r\n            if (t > 99) {\r\n                const ret = new qAtom(pos, t);\r\n                if (t === 100) {\r\n                    rSymbol();\r\n                    return r();\r\n                }\r\n                if (t < 104) return rInt8() === 0 && t === 101 ? new qAtom(pos - 1, t) : ret;\r\n                if (t > 105) r();\r\n                else for (let i = 0, n = rInt32() || 0; i < n; i++) r();\r\n\r\n                return ret;\r\n            }\r\n\r\n            // DICT - note t=127 never appears on the other side of the network!!!\r\n            if (99 === t) {\r\n                return parseDict();\r\n            }\r\n\r\n            // TABLE\r\n            if (98 === t) {\r\n                return parseTable();\r\n            }\r\n\r\n            // LIST\r\n            return parseList(t);\r\n        }\r\n\r\n        if (isLite) {\r\n            // check message format\r\n            if (rInt8() === 0) {\r\n                const msgLength = rInt32();\r\n                if (rInt8() === 0 && rInt8() === -6) {\r\n                    const requestId = rInt32();\r\n                    const qtype = rInt8();\r\n                    const mtype = rUInt8();\r\n                    const tmp = r();\r\n                    return [requestId, mtype, tmp];\r\n                }\r\n            }\r\n\r\n            return [0, Op.Error, \"Message parse error\"];\r\n        } else return r();\r\n    }\r\n}\r\n","/*globals Backbone,_,$,console, kdb, kdb.QBoolean, kdb.QSymbol, kdb.QByte, kdb.QShort, kdb.QInt, kdb.QLong, kdb.QReal,\r\nkdb.QFloat, kdb.QChar, kdb.QTimeStamp, kdb.QMonth, kdb.QDate, kdb.QDateTime, kdb.QTimeSpan, kdb.QMinute, kdb.QSecond, kdb.QTime,\r\nkdb.QList, kdb.QDict, win, win.ConnectionGroupEntity, win.ConnectionEntity, win.Client, kdb.KDBQuery, DataSet,\r\nUpdateMessage, win.AckMessage, NackMessage, setTimeout, clearTimeout, win, kdb*/\r\n/// <reference path=\"../classes/log.ts\"/>\r\n/// <reference path=\"delta-client-base.ts\"/>\r\n/// <reference path=\"c.ts\"/>\r\n/// <reference path=\"pivot.ts\" />\r\n/// <reference path=\"tools.ts\" />\r\n/// <reference path=\"delta.d.ts\"/>\r\n\r\n//var kdb = kdb || {};\r\n//var win = win || {};\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export interface DCDS {\r\n        class: string;\r\n        columns: Array<string>;\r\n        meta: { [index: string]: number };\r\n        rows?: Array<object>;\r\n        cols?: { [index: string]: qTyped };\r\n        clientId?: string;\r\n        subId?: string;\r\n        runID?: string;\r\n    }\r\n\r\n    export interface ExportParams {\r\n        columnLabel?: string; // [colName#colLabel, colName2#colLabel2, ...]\r\n        dateFormat?: string; // [temporalColumnName#FORMAT, ...]\r\n        timeZone?: string; // tobe implemented in the future\r\n    }\r\n\r\n    export type FnSuccess = (data: qTyped, buffer: ArrayBuffer) => void;\r\n    export type FnSuccessLegacy = (data: DCDS) => void;\r\n\r\n    export class DeltaClientLib extends DCBase {\r\n        static parameterRx = new RegExp(\"<%([^<>%]+?)%>\", \"g\");\r\n        static DEFAULT_NULL_VAL = -9223372036854776000; //if a value of 0N is returned this comes back from delta client\r\n        static PAGING_TYPES = [\"OFFSET\", \"OFFSET_NOCACHE\", \"PAGENO\", \"PAGENO_NOCACHE\"];\r\n        static timeout: number;\r\n\r\n        public static createLog(log: string, success: () => void, fail: () => void) {\r\n            if (this.deltaClient && this.deltaClient.clientLoggingEnabled()) {\r\n                let logs = [];\r\n                if (_.isString(log)) {\r\n                    logs = log.split(\"<-->\");\r\n                }\r\n                const self = this;\r\n                const userId = self.username;\r\n                const title = logs[0] || \"\";\r\n                const userTime = logs[1] || \"\";\r\n                const message = logs[2] || \"\";\r\n                const detail = logs[3] || \"\";\r\n                this.deltaClient.request(\r\n                    \"ClientLoggerAPI.log\",\r\n                    function(data) {\r\n                        _.isFunction(success) && success();\r\n                    },\r\n                    function(data) {\r\n                        console.log(\"Client logging FAILED\\n\\n\");\r\n                        if (data == null) {\r\n                            console.log(\"Client logging: \" + message + \"failed. Data is null\");\r\n                        } else {\r\n                            console.log(\"Client logging:\", data.toString());\r\n                        }\r\n                        _.isFunction(fail) && fail();\r\n                    },\r\n                    userId,\r\n                    userTime,\r\n                    title,\r\n                    message,\r\n                    detail,\r\n                );\r\n            }\r\n        }\r\n\r\n        public static deleteComponent(id: string, successFn: (d) => void, errorFn: (e) => void) {\r\n            this.deltaClient.request(\r\n                \"ComponentAPI.deleteComponent\",\r\n                function(data) {\r\n                    successFn(data);\r\n                },\r\n                function(data) {\r\n                    errorFn(data);\r\n                },\r\n                id,\r\n            );\r\n        }\r\n\r\n        public static connectionCollectionSync(method: string, collection: any, options: any) {\r\n            switch (method) {\r\n                case \"read\":\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"ConnectionAPI.getConnections\",\r\n                        DeltaClientLib.generateSuccessCallback(options),\r\n                        DeltaClientLib.generateErrorCallback(options, \"Error reading connections\"),\r\n                    );\r\n                    break;\r\n                default:\r\n                    throw \"data operation not supported for DocumentCollection\";\r\n            }\r\n        }\r\n\r\n        public static connectionSync(method: string, collection: any, options: any) {\r\n            let connection,\r\n                model = (this as unknown) as Backbone.Model;\r\n\r\n            switch (method) {\r\n                case \"update\":\r\n                    connection = new win.ConnectionEntity();\r\n                    connection.originalName = model.get(\"originalName\");\r\n                case \"create\":\r\n                    connection = connection || new win.ConnectionEntity();\r\n                    connection.name = model.id;\r\n                    connection.host = model.get(\"host\");\r\n                    connection.port = model.get(\"port\");\r\n                    connection.user = model.get(\"user\");\r\n                    connection.password = model.get(\"password\");\r\n                    connection.type = model.get(\"type\");\r\n                    connection.driver = model.get(\"driver\");\r\n                    connection.tls = model.get(\"tls\");\r\n\r\n                    // call updateConnections for create & update\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"ConnectionAPI.updateConnections\",\r\n                        DeltaClientLib.generateSuccessCallback(options),\r\n                        DeltaClientLib.generateErrorCallback(\r\n                            options,\r\n                            \"Error \" + method.substring(0, 5) + \"ing connection\",\r\n                        ),\r\n                        [connection],\r\n                        [],\r\n                    );\r\n\r\n                    break;\r\n                case \"delete\":\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"ConnectionAPI.updateConnections\",\r\n                        DeltaClientLib.generateSuccessCallback(options),\r\n                        DeltaClientLib.generateErrorCallback(options, \"Error deleting connection\"),\r\n                        [],\r\n                        [model.id],\r\n                    );\r\n                    break;\r\n                default:\r\n                    throw \"data operation not supported for Document\";\r\n            }\r\n        }\r\n\r\n        public static connectionGroupCollectionSync(method: string, collection: any, options: any) {\r\n            switch (method) {\r\n                case \"read\":\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"ConnectionAPI.getConnectionGroups\",\r\n                        DeltaClientLib.generateSuccessCallback(options),\r\n                        DeltaClientLib.generateErrorCallback(\r\n                            options,\r\n                            \"Error reading connection groups\",\r\n                        ),\r\n                    );\r\n                    break;\r\n                default:\r\n                    throw \"data operation not supported for ConnectionGroup Collection\";\r\n            }\r\n        }\r\n\r\n        public static connectionGroupSync(method: string, collection: any, options: any) {\r\n            let connectionGroup,\r\n                model = (this as unknown) as Backbone.Model;\r\n\r\n            switch (method) {\r\n                case \"create\":\r\n                    connectionGroup = new win.ConnectionGroupEntity();\r\n                    connectionGroup.name = model.id;\r\n                    connectionGroup.type = model.get(\"type\");\r\n                    connectionGroup.connections = model.get(\"connections\");\r\n                    connectionGroup.connectionsType = model.get(\"connectionsType\");\r\n\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"ConnectionAPI.createConnectionGroup\",\r\n                        DeltaClientLib.generateSuccessCallback(options),\r\n                        DeltaClientLib.generateErrorCallback(\r\n                            options,\r\n                            \"Error creating connection group\",\r\n                        ),\r\n                        connectionGroup,\r\n                    );\r\n                    break;\r\n                case \"update\":\r\n                    (connectionGroup = new win.ConnectionGroupEntity()),\r\n                        (connectionGroup.name = model.id);\r\n                    connectionGroup.type = model.get(\"type\");\r\n                    connectionGroup.connections = model.get(\"connections\");\r\n\r\n                    for (let i = 0; i < connectionGroup.connections.length; i += 1) {\r\n                        connectionGroup.connectionsType.push(\"default\");\r\n                    }\r\n\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"ConnectionAPI.updateConnectionGroup\",\r\n                        DeltaClientLib.generateSuccessCallback(options),\r\n                        DeltaClientLib.generateErrorCallback(\r\n                            options,\r\n                            \"Error updating connection group\",\r\n                        ),\r\n                        connectionGroup,\r\n                    );\r\n                    break;\r\n                case \"delete\":\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"ConnectionAPI.deleteConnectionGroup\",\r\n                        DeltaClientLib.generateSuccessCallback(options),\r\n                        DeltaClientLib.generateErrorCallback(\r\n                            options,\r\n                            \"Error deleting connection group\",\r\n                        ),\r\n                        model.id,\r\n                    );\r\n                    break;\r\n                default:\r\n                    throw \"data operation not supported for Connection Group\";\r\n            }\r\n        }\r\n\r\n        public static documentCollectionSync(method: string, collection: any, options: any) {\r\n            switch (method) {\r\n                case \"read\":\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"ProjectAPI.getDashboards\",\r\n                        function(data) {\r\n                            const dashboards = [];\r\n\r\n                            // add models to array\r\n                            _.each(data, function(dash) {\r\n                                // filter out dashboards without required access level\r\n                                if (\r\n                                    dash.accessLevel &&\r\n                                    DocumentCollection.requiredAccessLevel &&\r\n                                    dash.accessLevel !== DocumentCollection.requiredAccessLevel\r\n                                ) {\r\n                                    return;\r\n                                }\r\n\r\n                                // extra properties in description\r\n                                try {\r\n                                    const description = JSON.parse(dash.description);\r\n                                    dashboards.push(\r\n                                        new Document({\r\n                                            id: dash.name,\r\n                                            name: dash.displayName,\r\n                                            creationDate: description[\"creationDate\"],\r\n                                            lastUpdateDate:\r\n                                                description[\"lastUpdateDate\"] ||\r\n                                                description[\"creationDate\"],\r\n                                            screenDetails: description[\"screenDetails\"] || [],\r\n                                            thumb: description[\"thumb\"] || null,\r\n                                            tags: description[\"tags\"] || [],\r\n                                        }),\r\n                                    );\r\n                                } catch (exc) {\r\n                                    // nothin here\r\n                                    Log.Error(\"Error parsing dashboard description\", dash);\r\n                                }\r\n                            });\r\n\r\n                            if (options.success) {\r\n                                // HAVE TO RETURN MODELS IN ORDER TO WORK!!!\r\n                                options.success(dashboards);\r\n                            }\r\n                        },\r\n                        function(data) {\r\n                            alert(\"Retrieve Dashboards FAILED\");\r\n                            if (options.error) {\r\n                                options.error(data);\r\n                            }\r\n                        },\r\n                    );\r\n                    break;\r\n                default:\r\n                    throw \"data operation not supported for DashCollection\";\r\n            }\r\n        }\r\n\r\n        public static documentSync(method: string, collection: any, options: any) {\r\n            let dashboard,\r\n                model = (this as unknown) as Backbone.Model;\r\n\r\n            switch (method) {\r\n                case \"read\":\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"ProjectAPI.getDashboard\",\r\n                        function(data) {\r\n                            let json;\r\n                            //console.log(\"Retrieved Dashboard successful\", data);\r\n                            if (data) {\r\n                                // success\r\n                                json = JSON.parse(data.dataJSON);\r\n                                json.permissionEntity = data.permissionEntity;\r\n\r\n                                if (options.success) {\r\n                                    options.success(json);\r\n                                }\r\n                            } else {\r\n                                // error\r\n                                if (options.error) {\r\n                                    options.error();\r\n                                }\r\n                            }\r\n                        },\r\n                        function(data) {\r\n                            // error\r\n                            if (options.error) {\r\n                                options.error(data);\r\n                            }\r\n                        },\r\n                        model.id,\r\n                    );\r\n                    break;\r\n                case \"update\":\r\n                    dashboard = {\r\n                        name: model.id,\r\n                        displayName: model.get(\"name\"),\r\n                        description: JSON.stringify(\r\n                            {\r\n                                creationDate: model.get(\"creationDate\"),\r\n                                lastUpdateDate: model.get(\"lastUpdateDate\"),\r\n                                tags: model.get(\"tags\"),\r\n                                screenDetails: model.get(\"screenDetails\"),\r\n                                thumb: model.get(\"thumb\"),\r\n                            },\r\n                            null,\r\n                            2,\r\n                        ),\r\n                        dataJSON: JSON.stringify(\r\n                            _.omit(model.attributes, [\"permissionEntity\"]),\r\n                            null,\r\n                            2,\r\n                        ),\r\n                        class: \"api.entity.DashboardEntity\",\r\n                        permissionEntity: {\r\n                            permissions: model.get(\"permissionEntity\")\r\n                                ? model.get(\"permissionEntity\").permissions\r\n                                : {},\r\n                        },\r\n                    };\r\n\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"ProjectAPI.setDashboard\",\r\n                        function(data) {\r\n                            if (data) {\r\n                                // saved\r\n                                if (options.success) {\r\n                                    // model, id\r\n                                    options.success(model.attributes);\r\n                                }\r\n                            } else {\r\n                                // not saved\r\n                                if (options.error) {\r\n                                    options.error();\r\n                                }\r\n                            }\r\n                        },\r\n                        function(data) {\r\n                            // not saved\r\n                            if (options.error) {\r\n                                options.error(data);\r\n                            }\r\n                        },\r\n                        dashboard,\r\n                    );\r\n\r\n                    break;\r\n                case \"delete\":\r\n                    //\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"ProjectAPI.deleteDashboard\",\r\n                        function(data) {\r\n                            if (data) {\r\n                                // success\r\n                                if (options.success) {\r\n                                    // model, id\r\n                                    options.success();\r\n                                }\r\n                            } else {\r\n                                // error\r\n                                if (options.error) {\r\n                                    options.error();\r\n                                }\r\n                            }\r\n                        },\r\n                        function(data) {\r\n                            // error\r\n                            if (options.error) {\r\n                                options.error(data);\r\n                            }\r\n                        },\r\n                        model.id,\r\n                    );\r\n                    break;\r\n                default:\r\n                    throw \"data operation not supported for Document\";\r\n            }\r\n        }\r\n\r\n        public static documentViewSync(method: string, collection: any, options: any) {\r\n            let error,\r\n                model = (this as unknown) as Backbone.Model;\r\n\r\n            switch (method) {\r\n                case \"read\":\r\n                    error = DeltaClientLib.generateErrorCallback(\r\n                        options,\r\n                        \"Error reading viewstate\",\r\n                    );\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"UserSettingsAPI.readUserSetting\",\r\n                        function(data) {\r\n                            let y, key;\r\n\r\n                            if (data) {\r\n                                // saved\r\n                                if (options.success) {\r\n                                    // model, id\r\n                                    if (data && data[0]) {\r\n                                        y = JSON.parse(data[0][\"jsonData\"]);\r\n                                    }\r\n                                    options.success(y);\r\n                                }\r\n                            } else error();\r\n                        },\r\n                        error,\r\n                        model.id,\r\n                    );\r\n                    break;\r\n\r\n                case \"create\":\r\n                case \"update\":\r\n                    error = DeltaClientLib.generateErrorCallback(\r\n                        options,\r\n                        \"Error updating viewstate\",\r\n                    );\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"UserSettingsAPI.updateUserSetting\",\r\n                        function(data) {\r\n                            if (data) {\r\n                                // saved\r\n                                if (options.success) {\r\n                                    // model, id\r\n                                    options.success(model.attributes);\r\n                                }\r\n                            } else error();\r\n                        },\r\n                        error,\r\n                        {\r\n                            class: \"api.entity.UserSettingEntity\",\r\n                            id: model.id,\r\n                            type: \"dashboard_view_state\",\r\n                            jsonData: model.attributes,\r\n                        },\r\n                    );\r\n                    break;\r\n                case \"delete\":\r\n                    error = DeltaClientLib.generateErrorCallback(\r\n                        options,\r\n                        \"Error deleting viewstate\",\r\n                    );\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"UserSettingsAPI.deleteUserSetting\",\r\n                        function(data) {\r\n                            let y;\r\n\r\n                            if (data) {\r\n                                // saved\r\n                                if (options.success) {\r\n                                    options.success();\r\n                                }\r\n                            } else error();\r\n                        },\r\n                        error,\r\n                        model.id,\r\n                    );\r\n                    break;\r\n                default:\r\n                    throw \"data operation not supported for user settings: \" + method;\r\n            }\r\n        }\r\n\r\n        public static exportAnalyticData(\r\n            analytic: string,\r\n            connection: string,\r\n            params: any[],\r\n            exportName: string,\r\n            exportParams: ExportParams,\r\n            success: FnSuccess,\r\n            error: Function,\r\n        ) {\r\n            let kdbParams = [],\r\n                uiParams = null;\r\n\r\n            if (!params) {\r\n                params = [];\r\n            }\r\n\r\n            if (_.keys(exportParams).length) {\r\n                uiParams = this.processExportParams(exportParams);\r\n            }\r\n            this.createParamsObj(kdbParams, params);\r\n\r\n            // make request to download full file export with name param, string must be valid and sanitized\r\n            DeltaClientLib.exportData(\r\n                exportName,\r\n                analytic,\r\n                kdbParams,\r\n                uiParams,\r\n                connection,\r\n                success,\r\n                error,\r\n            );\r\n        }\r\n\r\n        public static exportQueryData(\r\n            connection: string,\r\n            query: string,\r\n            params: any[],\r\n            exportName: string,\r\n            exportParams: ExportParams,\r\n            success: FnSuccess,\r\n            error: Function,\r\n        ) {\r\n            const kdbParams = [],\r\n                formattedQuery = kdb.KDBQuery.create(query, undefined, undefined, true);\r\n\r\n            if (params) {\r\n                this.createParamsObj(kdbParams, params);\r\n                formattedQuery.parameters = kdbParams;\r\n                //add export parameters such as column order, labelformats, names etc.\r\n                if (_.keys(exportParams).length) {\r\n                    formattedQuery.uiParams = this.processExportParams(exportParams);\r\n                }\r\n            }\r\n\r\n            DeltaClientLib.exportData(\r\n                exportName,\r\n                formattedQuery,\r\n                null,\r\n                null,\r\n                connection,\r\n                success,\r\n                error,\r\n            );\r\n        }\r\n\r\n        public static exportPivotData(options: any, success: FnSuccess, error: Function) {\r\n            let query,\r\n                formattedQuery,\r\n                pivotSource = options.pivotSource,\r\n                queryParams = options.queryParams,\r\n                kdbParams = [],\r\n                exportParams = {},\r\n                exportName = \"\";\r\n\r\n            if (options) {\r\n                if (options.exportName) {\r\n                    exportName = options.exportName;\r\n                }\r\n                if (options.exportParams) {\r\n                    exportParams = options.exportParams;\r\n                }\r\n            }\r\n\r\n            query = Pivot.constructPivotQuery(options);\r\n            formattedQuery = kdb.KDBQuery.create(query, undefined, undefined, true);\r\n\r\n            if (pivotSource === \"query\") {\r\n                this.createParamsObj(kdbParams, queryParams);\r\n                formattedQuery.parameters = kdbParams;\r\n\r\n                if (_.keys(exportParams).length) {\r\n                    formattedQuery.uiParams = this.processExportParams(exportParams);\r\n                }\r\n            }\r\n\r\n            DeltaClientLib.exportData(\r\n                exportName,\r\n                formattedQuery,\r\n                null,\r\n                null,\r\n                options.connection,\r\n                success,\r\n                error,\r\n            );\r\n        }\r\n\r\n        public static exportData(\r\n            exportName,\r\n            queryOrAnalyticName,\r\n            kdbParams,\r\n            uiParams,\r\n            connection,\r\n            callback,\r\n            errorCallback,\r\n        ) {\r\n            const self = this,\r\n                exportCallbackFn = function(data) {\r\n                    if (_.isFunction(callback)) {\r\n                        const filename = (exportName || data) + \".zip\";\r\n                        const filepath = data + \"/\" + filename;\r\n                        const url =\r\n                            self.deltaClient.connection.url +\r\n                            \"/FileDownloadServlet\" +\r\n                            \"?client=\" +\r\n                            self.deltaClient.base64DeltaClient() +\r\n                            \"&filename=\" +\r\n                            filename +\r\n                            \"&filepath=\" +\r\n                            filepath;\r\n\r\n                        callback(url);\r\n                    }\r\n                },\r\n                runQueryArgs = [\r\n                    \"ExportAPI.export\" + (exportName ? \"ToFile\" : \"\"),\r\n                    exportCallbackFn,\r\n                    errorCallback,\r\n                    queryOrAnalyticName,\r\n                ];\r\n\r\n            // Add optional parameter in specific order\r\n            if (kdbParams) {\r\n                runQueryArgs.push(kdbParams);\r\n            }\r\n            if (uiParams) {\r\n                runQueryArgs.push(uiParams);\r\n            }\r\n            runQueryArgs.push(connection);\r\n            if (exportName) {\r\n                runQueryArgs.push(exportName);\r\n            }\r\n\r\n            this.deltaClient.request.apply(this.deltaClient.request, runQueryArgs);\r\n        }\r\n\r\n        public static generateSuccessCallback(options) {\r\n            return function(data) {\r\n                if (options.success) {\r\n                    options.success(data);\r\n                }\r\n            };\r\n        }\r\n\r\n        public static generateErrorCallback(options, msg) {\r\n            return function(data) {\r\n                Log.Error(msg, data);\r\n                if (options.error) {\r\n                    options.error(data);\r\n                }\r\n            };\r\n        }\r\n\r\n        public static getComponents(successFn, errorFn) {\r\n            Log.Info(\"Running Get Components\");\r\n            this.deltaClient.request(\r\n                \"ComponentAPI.getComponents\",\r\n                function(data) {\r\n                    successFn(data);\r\n                },\r\n                function(data) {\r\n                    errorFn(data);\r\n                },\r\n            );\r\n        }\r\n\r\n        public static getDeltaAnalytics(callback) {\r\n            this.deltaClient.request(\r\n                \"AnalyticAPI.getAnalytics\",\r\n                function(data) {\r\n                    if (callback) {\r\n                        callback(data);\r\n                    }\r\n                },\r\n                function() {\r\n                    Log.Error(\"Failed to retrieve Analytics\\n\\n\");\r\n                },\r\n            );\r\n        }\r\n\r\n        public static getDeltaInstances(callback) {\r\n            this.deltaClient.request(\r\n                \"ConnectionAPI.getProcessInstances\",\r\n                function(data) {\r\n                    if (callback) {\r\n                        callback(data);\r\n                    }\r\n                },\r\n                function() {\r\n                    Log.Error(\"Failed to retrieve Instances\\n\\n\");\r\n                },\r\n            );\r\n        }\r\n\r\n        public static getPivotData(\r\n            options: any,\r\n            success: FnSuccess,\r\n            error: Function,\r\n            performance: PerformanceMetrics,\r\n        ) {\r\n            let query,\r\n                connectionName = options.connection,\r\n                pivotSource = options.pivotSource,\r\n                queryParams = options.queryParams,\r\n                kdbParams = [],\r\n                formattedQuery,\r\n                rows = options.maxRows || null;\r\n\r\n            query = Pivot.constructPivotQuery(options);\r\n            formattedQuery = kdb.KDBQuery.create(query, rows);\r\n\r\n            if (pivotSource === \"query\") {\r\n                this.createParamsObj(kdbParams, queryParams);\r\n                formattedQuery.parameters = kdbParams;\r\n            }\r\n\r\n            //Run query using deltaClient\r\n            performance && performance.trigger(\"serverStart\");\r\n            this.deltaClient.request(\r\n                \"QueryAPI.runQueryBA\",\r\n                function(arg1, bData) {\r\n                    performance && performance.trigger(\"serverEnd\");\r\n                    const data = deserialize(bData);\r\n                    if (success) {\r\n                        success(data as qTyped, bData);\r\n                    }\r\n                },\r\n                function() {\r\n                    if (error) {\r\n                        error(arguments);\r\n                    }\r\n                },\r\n                formattedQuery,\r\n                connectionName,\r\n            );\r\n\r\n            //If subscription type is subscription run managed query query\r\n            if (options.subscriptionType === \"subscription\") {\r\n                performance && performance.trigger(\"serverStart\");\r\n                this.deltaClient.request(\r\n                    \"SubscriptionAPI.addSubscription\",\r\n                    function(data, bData) {\r\n                        if (success) {\r\n                            performance && performance.trigger(\"serverEnd\");\r\n                            if (bData && bData.byteLength) {\r\n                                data.dataSet = deserialize(bData);\r\n                            }\r\n\r\n                            success(data, bData);\r\n                        }\r\n                    },\r\n                    function(data) {\r\n                        if (error) {\r\n                            error(data);\r\n                        }\r\n                    },\r\n                    formattedQuery,\r\n                    connectionName,\r\n                    options.subscriptionInterval * 1000,\r\n                );\r\n            }\r\n        }\r\n\r\n        public static getPolledSubscription(runId): any | number {\r\n            return this.deltaClient.connection.oobupdate.filter(function(upd) {\r\n                return upd.type === \"QRPolledMessage\" && upd.data[0] === runId;\r\n            });\r\n        }\r\n\r\n        /*\r\n         * Legacy getQueryData return always rows\r\n         */\r\n        public static getQueryData(\r\n            dataSource: string,\r\n            connection: any,\r\n            query: string,\r\n            parameters: any,\r\n            success: FnSuccessLegacy,\r\n            error: Function,\r\n            maxRows?: number,\r\n            paging?: any,\r\n            performance?: PerformanceMetrics,\r\n        ) {\r\n            DeltaClientLib.getQueryData2(\r\n                dataSource,\r\n                connection,\r\n                query,\r\n                parameters,\r\n                DeltaClientLib.legacyRowCallback(success),\r\n                error,\r\n                maxRows,\r\n                paging,\r\n                performance,\r\n            );\r\n        }\r\n\r\n        public static getQueryData2(\r\n            dataSource: string,\r\n            connection: any,\r\n            query: string,\r\n            parameters: any,\r\n            success: FnSuccess,\r\n            error: Function,\r\n            maxRows?: number,\r\n            paging?: any,\r\n            performance?: PerformanceMetrics,\r\n        ) {\r\n            var formattedQuery,\r\n                kdbParams = [],\r\n                sortDict,\r\n                runQueryArgs,\r\n                rows = maxRows && maxRows != 0 ? Number(maxRows) : null,\r\n                self = this;\r\n\r\n            if (!paging || !connection || !_.includes(DeltaClientLib.PAGING_TYPES, paging.type)) {\r\n                paging = {\r\n                    type: \"NONE\",\r\n                };\r\n            }\r\n\r\n            if (dataSource === \"sql\") {\r\n                //run jdbc query if source set to sql\r\n                this.getSqlQueryData(\r\n                    connection,\r\n                    this.strip(query),\r\n                    parameters,\r\n                    success,\r\n                    error,\r\n                    maxRows,\r\n                );\r\n            } else {\r\n                if (!paging || paging.type === \"NONE\") {\r\n                    formattedQuery = kdb.KDBQuery.create(this.strip(query), rows);\r\n                } else {\r\n                    sortDict = new kdb.QDict();\r\n\r\n                    _.each(paging.sorting, function(value, key) {\r\n                        sortDict.add(key, value === true, kdb.KDB.BOOLEAN);\r\n                    });\r\n\r\n                    formattedQuery = kdb.KDBQuery.createPaged(\r\n                        this.strip(query),\r\n                        paging.type,\r\n                        paging.num,\r\n                        paging.size,\r\n                        sortDict,\r\n                    );\r\n                    formattedQuery.unlimitedRows = paging.size === -1;\r\n                }\r\n\r\n                if (parameters) {\r\n                    this.createParamsObj(kdbParams, parameters);\r\n                    formattedQuery.parameters = kdbParams;\r\n                }\r\n\r\n                Log.Info(\"QUERY: \", formattedQuery);\r\n\r\n                var reqObj,\r\n                    self = this;\r\n                runQueryArgs = [\r\n                    connection ? \"QueryAPI.runQueryBA\" : \"QueryAPI.runQuery\",\r\n                    function(arg1, bData) {\r\n                        performance && performance.trigger(\"serverEnd\");\r\n                        self.deltaClient.connection.removeResponder(reqObj.uid);\r\n                        const data = connection ? deserialize(bData) : arg1;\r\n                        if (success) {\r\n                            success(data, bData);\r\n                        }\r\n                    },\r\n                    function() {\r\n                        self.deltaClient.connection.removeResponder(reqObj.id);\r\n                        if (error) {\r\n                            error(arguments);\r\n                        }\r\n                    },\r\n                    formattedQuery,\r\n                ];\r\n\r\n                //enable running queries omitting conections (avoid hitting QueryRouter)\r\n                if (connection) {\r\n                    runQueryArgs.push(connection);\r\n                }\r\n\r\n                performance && performance.trigger(\"serverStart\");\r\n                reqObj = this.deltaClient.request.apply(this.deltaClient.request, runQueryArgs);\r\n            }\r\n        }\r\n\r\n        public static getConfigAPIDataWithProfile(\r\n            dataSource,\r\n            connection,\r\n            api,\r\n            param,\r\n            overrideName,\r\n            profileName,\r\n            callback,\r\n            errorCallback,\r\n        ) {\r\n            let runQueryArgs;\r\n\r\n            runQueryArgs = [\r\n                api,\r\n                function(data) {\r\n                    if (data) {\r\n                        if (callback) {\r\n                            callback(data);\r\n                        }\r\n                    }\r\n                },\r\n                function() {\r\n                    if (errorCallback) {\r\n                        errorCallback(arguments);\r\n                    }\r\n                },\r\n                param,\r\n                overrideName,\r\n                profileName,\r\n            ];\r\n\r\n            //enable running queries omitting conections (avoid hitting QueryRouter)\r\n            if (connection) {\r\n                runQueryArgs.push(connection);\r\n            }\r\n\r\n            this.deltaClient.request.apply(this.deltaClient.request, runQueryArgs);\r\n        }\r\n\r\n        public static getConfigAPIData(\r\n            dataSource,\r\n            connection,\r\n            api,\r\n            param,\r\n            callback,\r\n            errorCallback,\r\n        ) {\r\n            let runQueryArgs;\r\n\r\n            runQueryArgs = [\r\n                api,\r\n                function(data) {\r\n                    if (data) {\r\n                        if (callback) {\r\n                            callback(data);\r\n                        }\r\n                    }\r\n                },\r\n                function() {\r\n                    if (errorCallback) {\r\n                        errorCallback(arguments);\r\n                    }\r\n                },\r\n                param,\r\n            ];\r\n\r\n            //enable running queries omitting conections (avoid hitting QueryRouter)\r\n            if (connection) {\r\n                runQueryArgs.push(connection);\r\n            }\r\n\r\n            this.deltaClient.request.apply(this.deltaClient.request, runQueryArgs);\r\n        }\r\n\r\n        public static getConfigAPIDataNoParam(\r\n            dataSource,\r\n            connection,\r\n            api,\r\n            callback,\r\n            errorCallback,\r\n        ) {\r\n            let runQueryArgs;\r\n\r\n            runQueryArgs = [\r\n                api,\r\n                function(data) {\r\n                    if (data) {\r\n                        if (callback) {\r\n                            callback(data);\r\n                        }\r\n                    }\r\n                },\r\n                function() {\r\n                    if (errorCallback) {\r\n                        errorCallback(arguments);\r\n                    }\r\n                },\r\n            ];\r\n\r\n            //enable running queries omitting conections (avoid hitting QueryRouter)\r\n            if (connection) {\r\n                runQueryArgs.push(connection);\r\n            }\r\n\r\n            this.deltaClient.request.apply(this.deltaClient.request, runQueryArgs);\r\n        }\r\n\r\n        //IK: required for report management component\r\n        // uses APIQuery insetead of KDBQuery,\r\n        //  unwraps the lambda\r\n        public static getAPIQueryData(\r\n            connectiontype: string,\r\n            connection: any,\r\n            query: string,\r\n            parameters: any,\r\n            success: FnSuccess,\r\n            error: Function,\r\n        ) {\r\n            let formattedQuery,\r\n                kdbParams = [],\r\n                runQueryArgs;\r\n\r\n            formattedQuery = kdb.APIQuery.create(query);\r\n            //get rid of wrapping (\".rpt.addReport\" -> \"{[].rpt.addReport}\" -> \".rpt.addReport\" )\r\n            formattedQuery.lambda = query;\r\n\r\n            this.createParamsObj(kdbParams, parameters);\r\n            formattedQuery.parameters = kdbParams;\r\n\r\n            runQueryArgs = [\r\n                connection ? \"QueryAPI.runQueryBA\" : \"QueryAPI.runQuery\",\r\n                function(arg1, bData) {\r\n                    const data = connection ? deserialize(bData) : arg1;\r\n                    if (success) {\r\n                        success(data, bData);\r\n                    }\r\n                },\r\n                function() {\r\n                    if (error) {\r\n                        error(arguments);\r\n                    }\r\n                },\r\n                formattedQuery,\r\n            ];\r\n\r\n            //enable running queries omitting conections (avoid hitting QueryRouter)\r\n            if (connection) {\r\n                runQueryArgs.push(connection);\r\n            }\r\n\r\n            this.deltaClient.request.apply(this.deltaClient.request, runQueryArgs);\r\n        }\r\n\r\n        public static getSqlQueryData(\r\n            connection,\r\n            queryStr,\r\n            queryParams,\r\n            callback,\r\n            errorCallback,\r\n            maxRowCount,\r\n        ) {\r\n            let formattedQuery,\r\n                sqlParams = [],\r\n                rows = maxRowCount || 2000;\r\n\r\n            queryStr = $.trim(queryStr);\r\n\r\n            if (queryParams) {\r\n                formattedQuery = kdb.SQLQuery.create(queryStr, rows);\r\n\r\n                this.createSqlParamsObj(sqlParams, queryParams);\r\n                formattedQuery.parameters = sqlParams;\r\n            } else {\r\n                formattedQuery = kdb.SQLQuery.create(queryStr, rows);\r\n            }\r\n\r\n            if (queryParams) {\r\n                formattedQuery = kdb.SQLQuery.create(queryStr, rows);\r\n\r\n                this.createSqlParamsObj(sqlParams, queryParams);\r\n                formattedQuery.parameters = sqlParams;\r\n            }\r\n\r\n            this.deltaClient.request(\r\n                \"QueryAPI.runQuery\",\r\n                function(data) {\r\n                    if (callback) {\r\n                        callback(data);\r\n                    }\r\n                },\r\n                function() {\r\n                    if (errorCallback) {\r\n                        errorCallback(arguments);\r\n                    }\r\n                },\r\n                formattedQuery,\r\n                connection,\r\n            );\r\n        }\r\n\r\n        public static isConnectionAlive(connectionName) {\r\n            return this.deltaClient.request(\r\n                \"ConnectionAPI.isAlive\",\r\n                function(data) {\r\n                    Log.Info(data);\r\n                },\r\n                function(data) {\r\n                    Log.Info(data);\r\n                },\r\n                connectionName,\r\n            );\r\n        }\r\n\r\n        public static legacyRowCallback(callback) {\r\n            return function(data, bData) {\r\n                if (callback) {\r\n                    if (bData && bData.byteLength) {\r\n                        if (data.dataSet) {\r\n                            data.dataSet = ipc.Parse.reshape(data.dataSet, bData).toLegacy();\r\n                        } else {\r\n                            data = ipc.Parse.reshape(data, bData).toLegacy();\r\n                        }\r\n\r\n                        callback(data);\r\n                    } else callback(data);\r\n                }\r\n            };\r\n        }\r\n\r\n        public static logout() {\r\n            if (this.deltaClient) {\r\n                this.deltaClient.logout();\r\n                // this will remove token and reload page\r\n            } else {\r\n                // clear token\r\n                $.removeCookie(\"deltaToken\", { path: \"/\" });\r\n                location.reload();\r\n            }\r\n        }\r\n\r\n        /*\r\n         * Function converts export parameters for Full export to compatible object\r\n         *  for exact logic see <dashboardsDomainname>/demoClient/deltaAPIUAT.html#/main >\r\n         * js/controllers/queryAPIControler.js > $scope.runKDBQuery();\r\n         */\r\n        public static processExportParams(exportParams) {\r\n            const uiParams = new kdb.QDict(),\r\n                kdbTypeMap = {\r\n                    columnLabel: \"SYMBOL\",\r\n                    dateFormat: \"STRING\",\r\n                };\r\n            _.each(kdbTypeMap, function(kdbType, propKey) {\r\n                if (exportParams[propKey] && exportParams[propKey].length) {\r\n                    // add columnLabel ui Param\r\n                    const columnDict = new kdb.QDict();\r\n                    const columnDetails = exportParams[propKey].split(\"&&\");\r\n\r\n                    _.each(columnDetails, function(col) {\r\n                        const nameAndLabel = col.trim().split(\"#\");\r\n                        columnDict.add(nameAndLabel[0], nameAndLabel[1], kdb.KDB[kdbType]);\r\n                    });\r\n\r\n                    uiParams.add(propKey, columnDict, kdb.KDB.DICT);\r\n                }\r\n            });\r\n            return uiParams;\r\n        }\r\n\r\n        public static runAnalytic(\r\n            analytic: string,\r\n            connection: string,\r\n            params: any[],\r\n            success: FnSuccess,\r\n            error: Function,\r\n            maxRows?: number,\r\n            paging?: any,\r\n            performance?: PerformanceMetrics,\r\n        ) {\r\n            DeltaClientLib.runAnalytic2(\r\n                analytic,\r\n                connection,\r\n                params,\r\n                DeltaClientLib.legacyRowCallback(success),\r\n                error,\r\n                maxRows,\r\n                paging,\r\n                performance,\r\n            );\r\n        }\r\n\r\n        public static runAnalytic2(\r\n            analytic: string,\r\n            connection: string,\r\n            params: any[],\r\n            success: FnSuccess,\r\n            error: Function,\r\n            maxRows?: number,\r\n            paging?: any,\r\n            performance?: PerformanceMetrics,\r\n        ) {\r\n            const kdbParams = [],\r\n                rows = maxRows && maxRows != 0 ? Number(maxRows) : null,\r\n                self = this;\r\n\r\n            if (!params) {\r\n                params = [];\r\n            }\r\n\r\n            if (!connection) {\r\n                connection = \"ds_rdb_fx_eval\";\r\n            }\r\n\r\n            if (!paging || !connection || !_.includes(DeltaClientLib.PAGING_TYPES, paging.type)) {\r\n                paging = {\r\n                    type: \"NONE\",\r\n                };\r\n            }\r\n\r\n            //Create paramter object for passing ot deltaclient\r\n            this.createParamsObj(kdbParams, params);\r\n\r\n            if (!paging || paging.type === \"NONE\") {\r\n                performance && performance.trigger(\"serverStart\");\r\n                const reqObj = this.deltaClient.request(\r\n                    connection ? \"AnalyticAPI.runBA\" : \"AnalyticAPI.run\",\r\n                    function(arg1, bData) {\r\n                        performance && performance.trigger(\"serverEnd\");\r\n                        self.deltaClient.connection.removeResponder(reqObj.uid);\r\n                        const data = connection ? deserialize(bData) : arg1;\r\n                        if (success) {\r\n                            success(data, bData);\r\n                        }\r\n                    },\r\n                    function(data) {\r\n                        self.deltaClient.connection.removeResponder(reqObj.uid);\r\n                        Log.Error(\"Analytic run failed (\" + analytic + \")\", data);\r\n                        if (error) {\r\n                            error(data);\r\n                        }\r\n                    },\r\n                    analytic,\r\n                    kdbParams,\r\n                    connection,\r\n                    rows,\r\n                );\r\n            } else {\r\n                performance && performance.trigger(\"serverStart\");\r\n                const reqObj = this.deltaClient.request(\r\n                    connection ? \"AnalyticAPI.runPagedBA\" : \"AnalyticAPI.runPaged\",\r\n                    function(data, bData) {\r\n                        performance && performance.trigger(\"serverEnd\");\r\n                        self.deltaClient.connection.removeResponder(reqObj.uid);\r\n                        var data = connection ? deserialize(bData) : data;\r\n                        if (success) {\r\n                            success(data, bData);\r\n                        }\r\n                    },\r\n                    function(data) {\r\n                        self.deltaClient.connection.removeResponder(reqObj.uid);\r\n                        Log.Error(\"Analytic run failed (\" + analytic + \")\", data);\r\n                        if (error) {\r\n                            error(data);\r\n                        }\r\n                    },\r\n                    analytic,\r\n                    kdbParams,\r\n                    connection,\r\n                    paging.type,\r\n                    paging.num,\r\n                    paging.size,\r\n                    _.keys(paging.sorting)[0] || \"\",\r\n                    _.values(paging.sorting)[0] || false,\r\n                );\r\n            }\r\n        }\r\n\r\n        public static runApiFunction(apiFunction, connection, params, callback, errorCallback) {\r\n            let args, delay, onceCallback;\r\n\r\n            // ensure the callback is only called once\r\n            onceCallback = _.once(function(success, data) {\r\n                if (success) {\r\n                    if (data && callback) {\r\n                        callback(data);\r\n                    }\r\n                } else {\r\n                    Log.Error(\"Api Analytic run failed (\" + apiFunction + \")\", data);\r\n                    if (errorCallback) {\r\n                        errorCallback(data);\r\n                    }\r\n                }\r\n\r\n                clearTimeout(this.timeout);\r\n            });\r\n\r\n            // call error callback if no response within timeout\r\n            this.timeout = _.delay(function() {\r\n                if (onceCallback) {\r\n                    onceCallback(false, \"timed out\");\r\n                }\r\n            }, this.DEFAULT_TIMEOUT);\r\n\r\n            args = _.flatten([\r\n                apiFunction,\r\n                _.partial(onceCallback, true, _),\r\n                _.partial(onceCallback, false, _),\r\n                params,\r\n            ]);\r\n\r\n            this.deltaClient.request.apply(this.deltaClient, args);\r\n        }\r\n\r\n        public static servicesSync(method, collection, options) {\r\n            switch (method) {\r\n                default:\r\n                    throw \"data operation not supported for Service\";\r\n            }\r\n        }\r\n\r\n        public static servicesCollectionSync(method, collection, options) {\r\n            switch (method) {\r\n                case \"read\":\r\n                    DeltaClientLib.deltaClient.request(\r\n                        \"ConnectionAPI.getServiceClasses\",\r\n                        DeltaClientLib.generateSuccessCallback(options),\r\n                        DeltaClientLib.generateErrorCallback(\r\n                            options,\r\n                            \"Error reading services data\",\r\n                        ),\r\n                    );\r\n                    break;\r\n                default:\r\n                    throw \"data operation not supported for Service Collection\";\r\n            }\r\n        }\r\n\r\n        public static setComponent(name, displayName, description, dataJson, successFn, errorFn) {\r\n            const dashDataObj = {\r\n                name: name,\r\n                displayName: displayName,\r\n                description: description,\r\n                dataJSON: dataJson,\r\n                class: \"api.entity.ComponentEntity\",\r\n            };\r\n\r\n            this.deltaClient.request(\r\n                \"ComponentAPI.setComponent\",\r\n                function(data) {\r\n                    Log.Info(\"Save component \" + name + \" successful\", data);\r\n                    successFn(data);\r\n                },\r\n                function(data) {\r\n                    Log.Error(\"Save Dashboard \" + name + \" FAILED\");\r\n                    errorFn(data);\r\n                },\r\n                dashDataObj,\r\n            );\r\n        }\r\n\r\n        public static startManagedAnalytic(\r\n            analytic: string,\r\n            connection: string,\r\n            params: any[],\r\n            success: FnSuccess,\r\n            error: Function,\r\n            interval: number,\r\n            maxRows: number,\r\n            performance: PerformanceMetrics,\r\n        ) {\r\n            DeltaClientLib.startManagedAnalytic2(\r\n                analytic,\r\n                connection,\r\n                params,\r\n                DeltaClientLib.legacyRowCallback(success),\r\n                error,\r\n                interval,\r\n                maxRows,\r\n                performance,\r\n            );\r\n        }\r\n\r\n        public static startManagedAnalytic2(\r\n            analytic: string,\r\n            connection: string,\r\n            params: any[],\r\n            success: FnSuccess,\r\n            error: Function,\r\n            interval: number,\r\n            maxRows: number,\r\n            performance: PerformanceMetrics,\r\n        ) {\r\n            const self = this,\r\n                kdbParams = [],\r\n                callback = success || _.noop,\r\n                rows = maxRows || null;\r\n\r\n            if (!params) {\r\n                params = [];\r\n            }\r\n\r\n            //Create paramter object for passing ot deltaclient\r\n            this.createParamsObj(kdbParams, params);\r\n\r\n            //Get initial snapshot\r\n            performance && performance.trigger(\"serverStart\");\r\n            this.deltaClient.request(\r\n                connection ? \"AnalyticAPI.runBA\" : \"AnalyticAPI.run\",\r\n                function(data, bData) {\r\n                    performance && performance.trigger(\"serverEnd\");\r\n                    data = data || {};\r\n\r\n                    if (bData && bData.byteLength) {\r\n                        data = deserialize(bData);\r\n                    }\r\n\r\n                    callback(data, bData);\r\n\r\n                    //Start managed analytic. Update frequency depends on interval variable\r\n                    self.deltaClient.request(\r\n                        \"AnalyticAPI.startPolled\",\r\n                        function(data, bData) {\r\n                            // reformat new api response into subscription response format\r\n                            if (\r\n                                data[\"class\"] ==\r\n                                    \"com.fd.delta.stream.queryrouter.entity.QRResponseMessage\" &&\r\n                                data[\"success\"]\r\n                            ) {\r\n                                callback(\r\n                                    ({\r\n                                        class: \"207\",\r\n                                        add: true,\r\n                                        subId: data.runID,\r\n                                        clientId: \"polled\",\r\n                                    } as unknown) as qTyped,\r\n                                    undefined,\r\n                                );\r\n                            } else {\r\n                                error(data);\r\n                            }\r\n\r\n                            DeltaClientLib.getPolledSubscription(data.runID).subscribe(function(d) {\r\n                                if (!d.data[1]) error(\"Analytic Failed: \" + d.data);\r\n\r\n                                performance && performance.trigger(\"serverEnd\");\r\n\r\n                                if (d.appMsg && d.appMsg.byteLength) {\r\n                                    d.data.class = \"209\";\r\n                                    d.data.subId = d.data[0];\r\n                                    d.data.clientId = \"polled\";\r\n                                    d.data.dataSet = deserialize(d.appMsg);\r\n                                }\r\n\r\n                                callback(d.data, d.appMsg);\r\n                            });\r\n                        },\r\n                        function(data) {\r\n                            Log.Error(\"Managed Analytic run failed.\", data);\r\n                            if (error) {\r\n                                error(data);\r\n                            }\r\n                        },\r\n                        analytic,\r\n                        kdbParams,\r\n                        connection,\r\n                        interval,\r\n                        rows,\r\n                    );\r\n                },\r\n                function(data) {\r\n                    Log.Error(\"Analytic run failed.\", data);\r\n                    if (error) {\r\n                        error(data);\r\n                    }\r\n                },\r\n                analytic,\r\n                kdbParams,\r\n                connection,\r\n                rows,\r\n            );\r\n        }\r\n\r\n        public static startLegacyManagedQuery(\r\n            connection: string,\r\n            query: string,\r\n            params: any[],\r\n            success: FnSuccess,\r\n            error: Function,\r\n            interval: number,\r\n            maxRows: number,\r\n            paging: any,\r\n            performance: PerformanceMetrics,\r\n        ) {\r\n            DeltaClientLib.startLegacyManagedQuery2(\r\n                connection,\r\n                query,\r\n                params,\r\n                DeltaClientLib.legacyRowCallback(success),\r\n                error,\r\n                interval,\r\n                maxRows,\r\n                paging,\r\n                performance,\r\n            );\r\n        }\r\n\r\n        public static startLegacyManagedQuery2(\r\n            connection: string,\r\n            query: string,\r\n            params: any[],\r\n            success: FnSuccess,\r\n            error: Function,\r\n            interval: number,\r\n            maxRows: number,\r\n            paging: any,\r\n            performance: PerformanceMetrics,\r\n        ) {\r\n            let self = this,\r\n                callback = success || _.noop,\r\n                formattedQuery,\r\n                kdbParams = [],\r\n                rows = maxRows && maxRows != 0 ? Number(maxRows) : null,\r\n                runQueryArgs,\r\n                sortDict,\r\n                subQueryArgs;\r\n\r\n            if (!paging || !connection || !_.includes(DeltaClientLib.PAGING_TYPES, paging.type)) {\r\n                paging = {\r\n                    type: \"NONE\",\r\n                };\r\n            }\r\n\r\n            if (!paging || paging.type === \"NONE\") {\r\n                formattedQuery = kdb.KDBQuery.create(this.strip(query), rows);\r\n            } else {\r\n                sortDict = new kdb.QDict();\r\n\r\n                _.each(paging.sorting, function(value, key) {\r\n                    sortDict.add(key, value === true, kdb.KDB.BOOLEAN);\r\n                });\r\n\r\n                formattedQuery = kdb.KDBQuery.createPaged(\r\n                    this.strip(query),\r\n                    paging.type,\r\n                    paging.num,\r\n                    paging.size,\r\n                    sortDict,\r\n                );\r\n            }\r\n\r\n            if (params) {\r\n                this.createParamsObj(kdbParams, params);\r\n                formattedQuery.parameters = kdbParams;\r\n            }\r\n\r\n            // run a static query first to get immediate results\r\n            runQueryArgs = [\r\n                connection ? \"QueryAPI.runQueryBA\" : \"QueryAPI.runQuery\",\r\n                function(data, bData) {\r\n                    data = data || {};\r\n                    performance && performance.trigger(\"serverEnd\");\r\n\r\n                    if (bData && bData.byteLength) {\r\n                        data = deserialize(bData);\r\n                    }\r\n\r\n                    callback(data, bData);\r\n\r\n                    // run subscription query\r\n                    self.deltaClient.request.apply(self.deltaClient.request, subQueryArgs);\r\n                },\r\n                function() {\r\n                    if (error) {\r\n                        error(arguments);\r\n                    }\r\n                },\r\n                formattedQuery,\r\n                connection,\r\n            ];\r\n\r\n            subQueryArgs = [\r\n                \"SubscriptionAPI.addSubscription\",\r\n                function(data, bData) {\r\n                    if (callback) {\r\n                        if (bData && bData.byteLength) {\r\n                            data.dataSet = deserialize(bData);\r\n                        }\r\n\r\n                        callback(data, bData);\r\n                    }\r\n                },\r\n                function(data) {\r\n                    if (error) {\r\n                        error(data);\r\n                    }\r\n                },\r\n                formattedQuery,\r\n                connection,\r\n                interval,\r\n            ];\r\n            performance && performance.trigger(\"serverStart\");\r\n            this.deltaClient.request.apply(this.deltaClient.request, runQueryArgs);\r\n        }\r\n\r\n        public static startManagedQuery(\r\n            connection: string,\r\n            query: string,\r\n            params: any[],\r\n            success: FnSuccess,\r\n            error: Function,\r\n            interval: number,\r\n            maxRows: number,\r\n            paging: any,\r\n            performance: PerformanceMetrics,\r\n        ) {\r\n            DeltaClientLib.startManagedQuery2(\r\n                connection,\r\n                query,\r\n                params,\r\n                DeltaClientLib.legacyRowCallback(success),\r\n                error,\r\n                interval,\r\n                maxRows,\r\n                paging,\r\n                performance,\r\n            );\r\n        }\r\n\r\n        public static startManagedQuery2(\r\n            connection: string,\r\n            query: string,\r\n            params: any[],\r\n            success: FnSuccess,\r\n            error: Function,\r\n            interval: number,\r\n            maxRows: number,\r\n            paging: any,\r\n            performance: PerformanceMetrics,\r\n        ) {\r\n            let self = this,\r\n                callback = success || _.noop,\r\n                formattedQuery,\r\n                kdbParams = [],\r\n                rows = maxRows && maxRows != 0 ? Number(maxRows) : null,\r\n                sortDict,\r\n                subQueryArgs;\r\n\r\n            if (!paging || !connection || !_.includes(DeltaClientLib.PAGING_TYPES, paging.type)) {\r\n                paging = {\r\n                    type: \"NONE\",\r\n                };\r\n            }\r\n\r\n            if (!paging || paging.type === \"NONE\") {\r\n                formattedQuery = kdb.KDBQuery.create(this.strip(query), rows);\r\n            } else {\r\n                sortDict = new kdb.QDict();\r\n\r\n                _.each(paging.sorting, function(value, key) {\r\n                    sortDict.add(key, value === true, kdb.KDB.BOOLEAN);\r\n                });\r\n\r\n                formattedQuery = kdb.KDBQuery.createPaged(\r\n                    this.strip(query),\r\n                    paging.type,\r\n                    paging.num,\r\n                    paging.size,\r\n                    sortDict,\r\n                );\r\n            }\r\n\r\n            if (params) {\r\n                this.createParamsObj(kdbParams, params);\r\n                formattedQuery.parameters = kdbParams;\r\n            }\r\n\r\n            // run a static query first to get immediate results\r\n            performance && performance.trigger(\"serverStart\");\r\n            this.deltaClient.request(\r\n                \"QueryAPI.startPolledQuery\",\r\n                function(data: any) {\r\n                    // reformat new api response into subscription response format\r\n                    if (\r\n                        data[\"class\"] ==\r\n                            \"com.fd.delta.stream.queryrouter.entity.QRResponseMessage\" &&\r\n                        data[\"success\"]\r\n                    ) {\r\n                        callback(\r\n                            ({\r\n                                class: \"207\",\r\n                                add: true,\r\n                                subId: data.runID,\r\n                                clientId: \"polled\",\r\n                            } as unknown) as qTyped,\r\n                            undefined,\r\n                        );\r\n                    } else {\r\n                        error(data);\r\n                    }\r\n\r\n                    DeltaClientLib.getPolledSubscription(data.runID).subscribe(function(d) {\r\n                        performance && performance.trigger(\"serverEnd\");\r\n\r\n                        // return on error\r\n                        if (!d.data[1]) return error(\"Query Failed: \" + d.data);\r\n\r\n                        if (d.appMsg && d.appMsg.byteLength) {\r\n                            d.data.class = \"209\";\r\n                            d.data.subId = d.data[0];\r\n                            d.data.clientId = \"polled\";\r\n                            d.data.dataSet = deserialize(d.appMsg);\r\n                        }\r\n\r\n                        callback(d.data, d.appMsg);\r\n                    });\r\n                },\r\n                function() {\r\n                    if (error) {\r\n                        error(arguments);\r\n                    }\r\n                },\r\n                formattedQuery,\r\n                connection,\r\n                interval,\r\n            );\r\n        }\r\n\r\n        public static startStreamingAnalytic(\r\n            analytic: string,\r\n            connection: string,\r\n            params: any[],\r\n            success: FnSuccess,\r\n            error: Function,\r\n            performance: PerformanceMetrics,\r\n        ) {\r\n            DeltaClientLib.startStreamingAnalytic2(\r\n                analytic,\r\n                connection,\r\n                params,\r\n                DeltaClientLib.legacyRowCallback(success),\r\n                error,\r\n                performance,\r\n            );\r\n        }\r\n\r\n        public static startStreamingAnalytic2(\r\n            analytic: string,\r\n            connection: string,\r\n            params: any[],\r\n            success: FnSuccess,\r\n            error: Function,\r\n            performance: PerformanceMetrics,\r\n        ) {\r\n            const kdbParams = [];\r\n\r\n            this.createParamsObj(kdbParams, params || []);\r\n\r\n            //Start streaming analytic.\r\n            performance && performance.trigger(\"serverStart\");\r\n            this.deltaClient.request(\r\n                \"AnalyticAPI.startStreaming\",\r\n                function(data, bData) {\r\n                    performance && performance.trigger(\"serverEnd\");\r\n                    if (bData && bData.byteLength) {\r\n                        data.dataSet = deserialize(bData);\r\n                    }\r\n\r\n                    if (\r\n                        bData &&\r\n                        bData.byteLength === 10 &&\r\n                        new DataView(bData).getInt8(8) === 101\r\n                    ) {\r\n                        Log.Info(\"Streaming \" + analytic + \" returned unary primitive!\");\r\n                        return;\r\n                    }\r\n\r\n                    if (success) {\r\n                        success(data, bData);\r\n                    }\r\n                },\r\n                function(data) {\r\n                    Log.Info(\"Analytic run failed.\", data);\r\n                    if (error) {\r\n                        error(data);\r\n                    }\r\n                },\r\n                analytic,\r\n                kdbParams,\r\n                connection,\r\n            );\r\n        }\r\n\r\n        public static strip(query) {\r\n            if (query == null || query == undefined || query.length == 0) {\r\n                return query;\r\n            }\r\n\r\n            // reduce whitespace\r\n            query = query.replace(/((^|\\s+)\\/.*$)|^\\s+|\\s*\\n/gm, \" \");\r\n\r\n            // remove pointless wrapping - KXAX-15773\r\n            const lambdaTest = /^\\{(.*)\\}\\s*\\[\\]\\s*$/g.exec(query);\r\n            if (lambdaTest) {\r\n                query = lambdaTest[1];\r\n            }\r\n\r\n            return query;\r\n        }\r\n\r\n        public static removeSubscriptions(subId?: string) {\r\n            const self = this;\r\n            if (subId) {\r\n                const isPolled = subId.indexOf(\"polled:\") == 0;\r\n                const runId = isPolled ? subId.substr(7) : subId.split(\":\")[1];\r\n                const resObj = this.deltaClient.request(\r\n                    isPolled ? \"QueryAPI.stopPolledQuery\" : \"SubscriptionAPI.removeSubscription\",\r\n                    function(data) {\r\n                        if (isPolled) {\r\n                            const sub = DeltaClientLib.getPolledSubscription(runId);\r\n                            if (sub != -1) {\r\n                                sub.unsubscribe();\r\n                            }\r\n                        }\r\n\r\n                        self.deltaClient.connection.removeResponder(resObj.uid);\r\n                        Log.Info(\"Stop Subscriptions succeeded.\", data);\r\n                    },\r\n                    function(data) {\r\n                        self.deltaClient.connection.removeResponder(resObj.uid);\r\n                        Log.Error(\"Stop Subscriptions failed\", data);\r\n                    },\r\n                    isPolled ? [runId] : subId,\r\n                );\r\n\r\n                this.deltaClient.connection.removeResponder(runId);\r\n            } else {\r\n                const resObj = this.deltaClient.request(\r\n                    \"SubscriptionAPI.removeSubscriptions\",\r\n                    function(data) {\r\n                        self.deltaClient.connection.removeResponder(resObj.uid);\r\n                        Log.Info(\"Stop Subscriptions succeeded.\", data);\r\n                    },\r\n                    function(data) {\r\n                        self.deltaClient.connection.removeResponder(resObj.uid);\r\n                        Log.Error(\"Stop Subscriptions failed\", data);\r\n                    },\r\n                );\r\n\r\n                (this.deltaClient.connection.oobupdate.filter(function(upd) {\r\n                    return upd.type === \"QRPolledMessage\";\r\n                }) as any).unsubscribe();\r\n            }\r\n        }\r\n\r\n        //call update query passing in column based dictionaries for updates, called directly from datagrid curently\r\n        // options: {\r\n        //  idCol: '',\r\n        //  addedDict: {},  <-- column based dictionary 'columnName: [LISTOFROWUPDATES]'\r\n        //  updateDict: {},  <-- column based dictionary 'columnName: [LISTOFROWUPDATES]'\r\n        //  deletedDict: {},  <-- column based dictionary 'columnName: [LISTOFROWUPDATES]'\r\n        //  query: '',\r\n        //  connection: ''\r\n        //}\r\n        public static updateTable(options, successCallback, errorCallback) {\r\n            const self = this,\r\n                localUpdateParam = [];\r\n\r\n            for (let i = 0; i < 3; i += 1) {\r\n                localUpdateParam[i] = {\r\n                    type: \"dict\",\r\n                    value: {},\r\n                    index: i,\r\n                };\r\n            }\r\n\r\n            // Add additional viewstate properties\r\n            _.each(options.updateParams, p => {\r\n                localUpdateParam.push(p);\r\n            })\r\n\r\n            //populate localUpdateParam array with added, updated, and deleted dictionaries\r\n            _.each(localUpdateParam, function(updateParam, idx) {\r\n                updateParam.index = idx;\r\n            });\r\n\r\n            //added\r\n            _.each(options.addedDict.items, function(dictItem, dictKey) {\r\n                localUpdateParam[0].value[dictKey] = {\r\n                    type: self.updateTableGetListType(options.typeConfig[dictKey], dictItem),\r\n                    value: dictItem,\r\n                };\r\n            });\r\n\r\n            //updated\r\n            _.each(options.updatedDict.items, function(dictItem, dictKey) {\r\n                localUpdateParam[1].value[dictKey] = {\r\n                    type: self.updateTableGetListType(options.typeConfig[dictKey], dictItem),\r\n                    value: dictItem,\r\n                };\r\n            });\r\n\r\n            //deleted\r\n            _.each(options.deletedDict.items, function(dictItem, dictKey) {\r\n                localUpdateParam[2].value[dictKey] = {\r\n                    type: self.updateTableGetListType(options.typeConfig[dictKey], dictItem),\r\n                    value: dictItem,\r\n                };\r\n            });\r\n\r\n            //localUpdateParam.push({\r\n            //    index: 3,\r\n            //    type: 'symbol',\r\n            //    value: options.keyColumn\r\n            //});\r\n\r\n            if (options.updateType === \"analytic\") {\r\n                if (options.updateAnalytic) {\r\n                    self.runAnalytic(\r\n                        options.updateAnalytic,\r\n                        options.connection,\r\n                        localUpdateParam,\r\n                        successCallback,\r\n                        errorCallback,\r\n                    );\r\n                }\r\n            } else {\r\n                self.getQueryData(\r\n                    \"kdb\",\r\n                    options.connection,\r\n                    options.query,\r\n                    localUpdateParam,\r\n                    successCallback,\r\n                    errorCallback,\r\n                );\r\n            }\r\n            // run stored table update query\r\n        }\r\n\r\n        public static updateTableGetListType(kdbType, item) {\r\n            let charReturnType;\r\n            //set list types for table update\r\n            switch (kdbType) {\r\n                case 0:\r\n                    if (_.isArray(item)) {\r\n                        // list of lists\r\n                        if (_.isBoolean(item[0])) {\r\n                            charReturnType = \"listlistboolean\";\r\n                        } else if (_.isString(item[0])) {\r\n                            charReturnType = \"listliststring\";\r\n                        } else {\r\n                            charReturnType = \"listlistsymbol\";\r\n                        }\r\n                    } else if (_.isString(item)) {\r\n                        // list of characters is a string\r\n                        charReturnType = \"string[]\";\r\n                    } else {\r\n                        // default\r\n                        charReturnType = \"symbol[]\";\r\n                    }\r\n\r\n                    return charReturnType;\r\n                case 1:\r\n                    return \"boolean[]\";\r\n                case 2:\r\n                    //TODO test if this should be uuid\r\n                    return \"guid[]\";\r\n                case 4:\r\n                    return \"byte[]\";\r\n                case 5:\r\n                    return \"short[]\";\r\n                case 6:\r\n                    return \"int[]\";\r\n                case 7:\r\n                    return \"long[]\";\r\n                case 8:\r\n                    return \"real[]\";\r\n                case 9:\r\n                    return \"float[]\";\r\n                case 10:\r\n                    //    return 'char[]';\r\n                    charReturnType = \"char[]\";\r\n\r\n                    _.each(item, function(i) {\r\n                        if (i.length > 1) {\r\n                            charReturnType = \"string[]\";\r\n                        }\r\n                    });\r\n                    return charReturnType;\r\n                case 11:\r\n                    return \"symbol[]\";\r\n                case 12:\r\n                    return \"timestamp[]\";\r\n                case 13:\r\n                    return \"month[]\";\r\n                case 14:\r\n                    return \"date[]\";\r\n                case 15:\r\n                    return \"datetime[]\";\r\n                case 16:\r\n                    return \"timespan[]\";\r\n                case 17:\r\n                    return \"minute[]\";\r\n                case 18:\r\n                    return \"second[]\";\r\n                case 19:\r\n                    return \"time[]\";\r\n                default:\r\n                    return \"symbol[]\";\r\n            }\r\n        }\r\n\r\n        //recursive\r\n        private static createDeltaObj(obj: any) {\r\n            let deltaObj, placeholderArray, param1, match;\r\n\r\n            const kdbDate = function(obj) {\r\n                let dateString;\r\n\r\n                if (_.has(obj, \"i\") || typeof obj !== \"string\") {\r\n                    return obj;\r\n                }\r\n\r\n                // convert kdb date, datetime & timestamps to kdb obj form\r\n                dateString = obj\r\n                    .replace(\"D\", \"T\")\r\n                    .replace(/(\\d\\d\\d\\d)\\.(\\d\\d)\\.(\\d\\d)/, \"$1-$2-$3\");\r\n\r\n                if (dateString.length > 10) {\r\n                    // add Z to datetimes and timestamps\r\n                    dateString += \"Z\";\r\n                }\r\n\r\n                return Tools.convertISODatetimeToKDBLikeObject(dateString);\r\n            };\r\n\r\n            switch (obj.type.toLowerCase()) {\r\n                case \"boolean\":\r\n                    deltaObj = new kdb.QBoolean();\r\n                    deltaObj.setValue(\r\n                        typeof obj.value === \"string\" ? obj.value == \"1b\" : obj.value,\r\n                    );\r\n                    break;\r\n                case \"guid\":\r\n                    deltaObj = new kdb.QGUID();\r\n                    match =\r\n                        typeof obj.value === \"string\" ? obj.value.match(/\"G\"\\$\"(.+)\"$/) : obj.value;\r\n                    deltaObj.value = match ? match[1] : obj.value == \"0Ng\" ? null : obj.value;\r\n                    break;\r\n                case \"symbol\":\r\n                    deltaObj = new kdb.QSymbol();\r\n                    match =\r\n                        typeof obj.value === \"string\" ? obj.value.match(/`\\$\"(.*)\"$/) : obj.value;\r\n                    deltaObj.value = match ? match[1] : obj.value;\r\n                    break;\r\n                case \"byte\":\r\n                    deltaObj = new kdb.QByte();\r\n                    deltaObj.value =\r\n                        typeof obj.value === \"string\" ? parseInt(obj.value) : obj.value;\r\n                    break;\r\n                case \"short\":\r\n                    deltaObj = new kdb.QShort();\r\n                    deltaObj.value = parseInt(obj.value, 10);\r\n                    break;\r\n                case \"int\":\r\n                case \"integer\":\r\n                    deltaObj = new kdb.QInt();\r\n                    deltaObj.value = parseInt(obj.value, 10);\r\n                    break;\r\n                case \"long\":\r\n                    deltaObj = new kdb.QLong();\r\n                    deltaObj.value =\r\n                        typeof obj.value === \"number\" ? obj.value : parseInt(obj.value, 10);\r\n                    break;\r\n                case \"real\":\r\n                    deltaObj = new kdb.QReal();\r\n                    deltaObj.value = parseFloat(obj.value);\r\n                    break;\r\n                case \"float\":\r\n                case \"double\":\r\n                    deltaObj = new kdb.QFloat();\r\n                    deltaObj.value = parseFloat(obj.value);\r\n                    break;\r\n                case \"char\":\r\n                    deltaObj = new kdb.QChar();\r\n                    deltaObj.setValue(obj.value);\r\n                    break;\r\n                case \"timestamp\":\r\n                    deltaObj = new kdb.QTimeStamp();\r\n                    if (obj.value !== null) {\r\n                        param1 = kdbDate(obj.value);\r\n                        deltaObj.setValue(param1.i);\r\n                        if (param1 && param1.n) {\r\n                            deltaObj.nanoValue = param1.n;\r\n                        }\r\n                    }\r\n                    break;\r\n                case \"month\":\r\n                    deltaObj = new kdb.QMonth();\r\n                    if (obj.value !== null) {\r\n                        deltaObj.setValue(_.has(obj.value, \"i\") ? obj.value.i : obj.value);\r\n                    }\r\n                    break;\r\n                case \"date\":\r\n                    deltaObj = new kdb.QDate();\r\n                    if (obj.value !== null) {\r\n                        deltaObj.setValue(kdbDate(obj.value).i);\r\n                    }\r\n                    break;\r\n                case \"datetime\":\r\n                    deltaObj = new kdb.QDateTime();\r\n                    if (obj.value !== null) {\r\n                        deltaObj.setValue(kdbDate(obj.value).i);\r\n                    }\r\n                    break;\r\n                case \"timespan\":\r\n                    deltaObj = new kdb.QTimeSpan();\r\n                    deltaObj.setValue(obj.value);\r\n                    break;\r\n                case \"minute\":\r\n                    deltaObj = new kdb.QMinute();\r\n                    deltaObj.setValue(_.has(obj.value, \"i\") ? obj.value.i : obj.value);\r\n                    break;\r\n                case \"second\":\r\n                    deltaObj = new kdb.QSecond();\r\n                    deltaObj.setValue(_.has(obj.value, \"i\") ? obj.value.i : obj.value);\r\n                    break;\r\n                case \"time\":\r\n                    deltaObj = new kdb.QTime();\r\n                    deltaObj.setValue(_.has(obj.value, \"i\") ? obj.value.i : obj.value);\r\n                    break;\r\n                case \"string\":\r\n                    deltaObj = new kdb.QString();\r\n                    deltaObj.setValue(obj.value);\r\n                    break;\r\n                //TODO temporary solution, modify liststring, check tags component!\r\n                case \"string[]\":\r\n                    deltaObj = new kdb.QList();\r\n                    placeholderArray = [];\r\n                    _.each(obj.value, function(item) {\r\n                        param1 = new kdb.QString();\r\n                        param1.setValue(item);\r\n                        placeholderArray.push(param1);\r\n                    });\r\n\r\n                    deltaObj.value = placeholderArray;\r\n                    break;\r\n                case \"symbol[]\":\r\n                case \"liststring\":\r\n                case \"list\":\r\n                    deltaObj = new kdb.QList();\r\n                    placeholderArray = [];\r\n                    if (typeof obj.value === \"string\") {\r\n                        match = obj.value.match(/^\\((.+)\\)$/);\r\n                        obj.value = match ? match[1].split(\";\") : [obj.value];\r\n                    }\r\n\r\n                    _.each(obj.value, function(item) {\r\n                        match = typeof item === \"string\" ? /`\\$\"(.*)\"$/.exec(item) : null;\r\n                        param1 = new kdb.QSymbol();\r\n                        param1.setValue(match ? match[1] : item);\r\n                        placeholderArray.push(param1);\r\n                    });\r\n\r\n                    deltaObj.value = placeholderArray;\r\n                    break;\r\n\r\n                case \"listobject\":\r\n                    deltaObj = new kdb.QList();\r\n                    placeholderArray = [];\r\n\r\n                    _.each(\r\n                        obj.value,\r\n                        _.bind(function(arrayItm) {\r\n                            let item;\r\n                            if (!_.isEmpty(arrayItm)) {\r\n                                //recursive\r\n                                item = this.createDeltaObj(arrayItm);\r\n                                placeholderArray.push(item);\r\n                            }\r\n                        }, this),\r\n                    );\r\n\r\n                    deltaObj.value = placeholderArray;\r\n                    break;\r\n\r\n                //TODO handle generic nested arrays other way\r\n                case \"listlistsymbol\":\r\n                    deltaObj = new kdb.QList();\r\n                    deltaObj.value = _.map(obj.value, function(arr) {\r\n                        const nestedList = new kdb.QList();\r\n                        nestedList.value = _.map(arr, function(itm) {\r\n                            const param = new kdb.QSymbol();\r\n                            param.setValue(itm);\r\n                            return param;\r\n                        });\r\n\r\n                        return nestedList;\r\n                    });\r\n                    break;\r\n\r\n                //TODO handle generic nested arrays other way\r\n                case \"listlistboolean\":\r\n                    deltaObj = new kdb.QList();\r\n                    deltaObj.value = _.map(obj.value, function(arr) {\r\n                        const nestedList = new kdb.QList();\r\n                        nestedList.value = _.map(arr, function(itm) {\r\n                            const param = new kdb.QBoolean();\r\n                            param.setValue(itm);\r\n                            return param;\r\n                        });\r\n\r\n                        return nestedList;\r\n                    });\r\n                    break;\r\n\r\n                //TODO handle generic nested arrays other way\r\n                case \"listliststring\":\r\n                    deltaObj = new kdb.QList();\r\n                    deltaObj.value = _.map(obj.value, function(arr) {\r\n                        const nestedList = new kdb.QList();\r\n                        nestedList.value = _.map(arr, function(itm) {\r\n                            const param = new kdb.QString();\r\n                            param.setValue(itm);\r\n                            return param;\r\n                        });\r\n\r\n                        return nestedList;\r\n                    });\r\n                    break;\r\n\r\n                //TODO handle generic nested arrays other way\r\n                //case 'listlistlistchar':\r\n                //    debugger;\r\n                //    deltaObj = new kdb.QList();\r\n                //    deltaObj.value = _.map(obj.value, function (arr) {\r\n                //        var nestedList = new kdb.QList();\r\n                //        nestedList.value = _.map(arr, function (itm) {\r\n                //            var listChar = new kdb.QList();\r\n                //            listChar.value = _.map(itm.split(\"\"), function (char) {\r\n                //                var ch = new kdb.QChar();\r\n                //                ch.value = char;\r\n                //            });\r\n                //            return listChar;\r\n                //        });\r\n                //        return nestedList;\r\n                //    });\r\n                //    break;\r\n\r\n                case \"listlong\":\r\n                    deltaObj = new kdb.QList();\r\n                    placeholderArray = [];\r\n\r\n                    _.each(obj.value, function(arrayItm) {\r\n                        param1 = new kdb.QLong();\r\n                        param1.setValue(arrayItm);\r\n                        placeholderArray.push(param1);\r\n                    });\r\n\r\n                    deltaObj.value = placeholderArray;\r\n                    break;\r\n                case \"listtimestamp\":\r\n                    deltaObj = new kdb.QList();\r\n                    placeholderArray = [];\r\n\r\n                    _.each(obj.value, function(arrayItm) {\r\n                        const childObj = new kdb.QTimeStamp();\r\n                        if (arrayItm === null) {\r\n                            childObj.setValue(\"0Np\");\r\n                        } else {\r\n                            param1 = kdbDate(arrayItm);\r\n                            childObj.setValue(param1.i);\r\n                            if (param1 && param1.n) {\r\n                                childObj.nanoValue = param1.n;\r\n                            }\r\n                        }\r\n                        placeholderArray.push(childObj);\r\n                    });\r\n\r\n                    deltaObj.value = placeholderArray;\r\n                    break;\r\n                case \"dict\":\r\n                    deltaObj = new kdb.QDict();\r\n\r\n                    _.each(\r\n                        obj.value,\r\n                        _.bind(function(value, key) {\r\n                            let valObj = value,\r\n                                itm;\r\n\r\n                            if (_.isString(value)) {\r\n                                valObj = {\r\n                                    type: \"symbol\",\r\n                                    value: value,\r\n                                };\r\n                            }\r\n\r\n                            itm = this.createDeltaObj(valObj);\r\n\r\n                            deltaObj.values.push(itm);\r\n                            deltaObj.fields.push(key);\r\n                        }, this),\r\n                    );\r\n                    break;\r\n                case \"table\":\r\n                    deltaObj = new kdb.QFlip();\r\n\r\n                    _.each(\r\n                        obj.value.columns,\r\n                        function(c, ix) {\r\n                            deltaObj.fields.push(c);\r\n                            deltaObj.values.push(\r\n                                // TODO test more types (tested: long string symbol boolean)\r\n                                this.createDeltaObj({\r\n                                    type: obj.value.types[ix] + \"[]\",\r\n                                    value: obj.value.values[ix],\r\n                                }),\r\n                            );\r\n                        }.bind(this),\r\n                    );\r\n                    break;\r\n                case \"nulltype\":\r\n                    deltaObj = new kdb.QDict();\r\n                    break;\r\n                case \"listdate\":\r\n                    deltaObj = new kdb.QList();\r\n                    placeholderArray = [];\r\n\r\n                    _.each(obj.value, function(arrayItm) {\r\n                        const childObj = new kdb.QDate();\r\n                        if (arrayItm === null) {\r\n                            childObj.setValue(\"0Nd\");\r\n                        } else {\r\n                            childObj.setValue(kdbDate(arrayItm).i);\r\n                        }\r\n                        placeholderArray.push(childObj);\r\n                    });\r\n\r\n                    deltaObj.value = placeholderArray;\r\n                    break;\r\n                default:\r\n                    if (obj.type.toLowerCase().indexOf(\"[]\") > -1) {\r\n                        deltaObj = new kdb.QList();\r\n                        placeholderArray = [];\r\n\r\n                        _.each(\r\n                            obj.value,\r\n                            _.bind(function(arrayValue, idx) {\r\n                                placeholderArray.push(\r\n                                    this.createDeltaObj({\r\n                                        //type: obj.type.toLowerCase().split('[]')[0],\r\n                                        type: obj.type.toLowerCase().replace(\"[]\", \"\"),\r\n                                        value: arrayValue,\r\n                                        index: idx,\r\n                                    }),\r\n                                );\r\n                            }, this),\r\n                        );\r\n                        deltaObj.value = placeholderArray;\r\n                    }\r\n                    break;\r\n            }\r\n            deltaObj.orderIndex = obj.index;\r\n\r\n            return deltaObj;\r\n        }\r\n\r\n        private static createParamsObj(deltaClientObjParam: any, jsObj: any) {\r\n            let self = this,\r\n                idx = 0,\r\n                localJsObj,\r\n                createDeltaObj;\r\n\r\n            //if (jsObj instanceof Backbone.Model) {\r\n            if (jsObj.attributes) {\r\n                localJsObj = jsObj.attributes;\r\n            } else if (jsObj) {\r\n                localJsObj = jsObj;\r\n            }\r\n\r\n            if (localJsObj) {\r\n                _.each(\r\n                    localJsObj,\r\n                    _.bind(function(obj) {\r\n                        if (obj.type && obj.type !== \"t\") {\r\n                            if (obj.type === \"symbol[]\") {\r\n                                obj.type = \"list\";\r\n                            }\r\n\r\n                            deltaClientObjParam[idx] = this.createDeltaObj(obj);\r\n                            idx += 1;\r\n                        }\r\n                    }, this),\r\n                );\r\n\r\n                deltaClientObjParam.sort(function(a, b) {\r\n                    return a.orderIndex - b.orderIndex;\r\n                });\r\n            }\r\n        }\r\n\r\n        private static createSqlParamsObj(deltaClientObjParam: any, jsObj: any) {\r\n            let placeholderArray,\r\n                param1,\r\n                idx = 0,\r\n                stringChars,\r\n                localJsObj,\r\n                createDeltaObj;\r\n\r\n            //if (jsObj instanceof Backbone.Model) {\r\n            if (jsObj.attributes) {\r\n                localJsObj = jsObj.attributes;\r\n            } else if (jsObj) {\r\n                localJsObj = jsObj;\r\n            }\r\n\r\n            createDeltaObj = function(obj) {\r\n                let deltaObj;\r\n\r\n                switch (obj.type.toLowerCase()) {\r\n                    case \"boolean\":\r\n                        deltaObj = new kdb.SQLBoolean();\r\n                        deltaObj.value = obj.value;\r\n                        break;\r\n                    case \"guid\":\r\n                        deltaObj = new kdb.SQLVarChar();\r\n                        deltaObj.value = obj.value;\r\n                        break;\r\n                    case \"symbol\":\r\n                        deltaObj = new kdb.SQLVarChar();\r\n                        deltaObj.value = obj.value;\r\n                        break;\r\n                    case \"byte\":\r\n                        deltaObj = new kdb.SQLByte();\r\n                        deltaObj.value = obj.value;\r\n                        break;\r\n                    case \"short\":\r\n                        deltaObj = new kdb.SQLShort();\r\n                        deltaObj.value = obj.value;\r\n                        break;\r\n                    case \"int\":\r\n                        deltaObj = new kdb.SQLInt();\r\n                        deltaObj.value = parseInt(obj.value, 10);\r\n                        break;\r\n                    case \"integer\":\r\n                        deltaObj = new kdb.SQLInt();\r\n                        deltaObj.value = parseInt(obj.value, 10);\r\n                        break;\r\n                    case \"long\":\r\n                        deltaObj = new kdb.SQLLong();\r\n                        deltaObj.value = obj.value;\r\n                        break;\r\n                    case \"real\":\r\n                        deltaObj = new kdb.SQLFloat();\r\n                        deltaObj.value = obj.value;\r\n                        break;\r\n                    case \"float\":\r\n                        deltaObj = new kdb.SQLFloat();\r\n                        deltaObj.value = parseFloat(obj.value);\r\n                        break;\r\n                    case \"double\":\r\n                        deltaObj = new kdb.SQLDouble();\r\n                        deltaObj.setValue(obj.value);\r\n                        break;\r\n                    case \"char\":\r\n                        deltaObj = new kdb.SQLVarChar();\r\n                        deltaObj.value = obj.value;\r\n                        break;\r\n                    case \"timestamp\":\r\n                        deltaObj = new kdb.SQLTime();\r\n                        deltaObj.setValue(obj.value);\r\n                        break;\r\n                    case \"month\":\r\n                        deltaObj = new kdb.SQLInt();\r\n                        deltaObj.setValue(obj.value);\r\n                        break;\r\n                    case \"date\":\r\n                        deltaObj = new kdb.SQLTime();\r\n                        deltaObj.setValue(new Date(obj.value));\r\n                        //deltaObj.value = obj[1];\r\n                        break;\r\n                    case \"datetime\":\r\n                        deltaObj = new kdb.SQLTime();\r\n                        deltaObj.setValue(new Date(obj.value));\r\n                        break;\r\n                    case \"timespan\":\r\n                        deltaObj = new kdb.SQLTime();\r\n                        deltaObj.setValue(obj.value);\r\n                        break;\r\n                    case \"minute\":\r\n                        deltaObj = new kdb.SQLInt();\r\n                        deltaObj.setValue(obj.value);\r\n                        break;\r\n                    case \"second\":\r\n                        deltaObj = new kdb.SQLInt();\r\n                        deltaObj.setValue(obj.value);\r\n                        break;\r\n                    case \"time\":\r\n                        deltaObj = new kdb.SQLTime();\r\n                        deltaObj.setValue(obj.value);\r\n                        break;\r\n                    case \"string\":\r\n                        deltaObj = new kdb.SQLList();\r\n                        stringChars = obj.value.split(\"\");\r\n                        placeholderArray = [];\r\n\r\n                        _.each(stringChars, function(c) {\r\n                            param1 = new kdb.SQLVarChar();\r\n                            param1.value = c;\r\n                            placeholderArray.push(param1);\r\n                        });\r\n                        deltaObj.value = placeholderArray;\r\n                        break;\r\n                    //case 'symbol[]':\r\n                    //    deltaObj = new kdb.SQLList();\r\n                    //    placeholderArray = [];\r\n\r\n                    //    _.each(obj.value, function (arrayItm) {\r\n                    //        param1 = new kdb.SQLSymbol();\r\n                    //        param1.setValue(arrayItm);\r\n                    //        placeholderArray.push(param1);\r\n                    //    });\r\n\r\n                    //    deltaObj.value = placeholderArray;\r\n                    //    break;\r\n                    case \"list\":\r\n                        deltaObj = new kdb.SQLList();\r\n                        placeholderArray = [];\r\n\r\n                        _.each(obj.value, function(arrayItm) {\r\n                            param1 = new kdb.SQLVarChar();\r\n                            param1.setValue(arrayItm);\r\n                            placeholderArray.push(param1);\r\n                        });\r\n\r\n                        deltaObj.value = placeholderArray;\r\n                        break;\r\n                    case \"symbol[]\":\r\n                        deltaObj = new kdb.SQLList();\r\n                        placeholderArray = [];\r\n\r\n                        _.each(obj.value, function(arrayItm) {\r\n                            param1 = new kdb.SQLVarChar();\r\n                            param1.setValue(arrayItm);\r\n                            placeholderArray.push(param1);\r\n                        });\r\n\r\n                        deltaObj.value = placeholderArray;\r\n                        break;\r\n                    case \"listtimestamp\":\r\n                        deltaObj = new kdb.SQLList();\r\n                        placeholderArray = [];\r\n\r\n                        _.each(obj.value, function(arrayItm) {\r\n                            param1 = new kdb.SQLTime();\r\n                            param1.setValue(arrayItm);\r\n                            placeholderArray.push(param1);\r\n                        });\r\n\r\n                        deltaObj.value = placeholderArray;\r\n                        break;\r\n                    case \"dict\":\r\n                        deltaObj = new kdb.SQLDict();\r\n\r\n                        _.each(obj.value, function(value, key) {\r\n                            const itm = createDeltaObj(value);\r\n                            deltaObj.values.push(itm);\r\n                            deltaObj.fields.push(key);\r\n                        });\r\n                        break;\r\n                    case \"nulltype\":\r\n                        deltaObj = new kdb.SQLDict();\r\n                        break;\r\n                }\r\n                deltaObj.orderIndex = obj.index;\r\n                deltaObj.setName(obj.name);\r\n\r\n                return deltaObj;\r\n            };\r\n\r\n            if (localJsObj) {\r\n                _.each(localJsObj, function(obj) {\r\n                    if (obj.type && obj.type !== \"t\") {\r\n                        if (obj.type === \"symbol[]\") {\r\n                            obj.type = \"list\";\r\n                        }\r\n\r\n                        deltaClientObjParam[idx] = createDeltaObj(obj);\r\n                        idx += 1;\r\n                    }\r\n                });\r\n\r\n                deltaClientObjParam.sort(function(a, b) {\r\n                    return a.orderIndex - b.orderIndex;\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n","/*globals Backbone,_,$,console */\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class ErrorTooltip {\r\n        public static clearAll(fade?: boolean) {\r\n            if (fade) {\r\n                $(\"body .field-error\").fadeOut();\r\n            } else {\r\n                $(\"body .field-error\").remove();\r\n            }\r\n        }\r\n\r\n        public static clear($errorTooltip: JQuery, fade?: boolean) {\r\n            if ($errorTooltip) {\r\n                if (fade) {\r\n                    $errorTooltip.fadeOut();\r\n                } else {\r\n                    $errorTooltip.remove();\r\n                }\r\n            }\r\n        }\r\n\r\n        public static show(message, element, onLeft) {\r\n            let $errorTooltip;\r\n\r\n            if (!message || !element) {\r\n                return;\r\n            }\r\n\r\n            $errorTooltip = $(\"<div/>\", {\r\n                text: message,\r\n            })\r\n                .addClass(\"field-error\")\r\n                .appendTo(\"body\");\r\n\r\n            $errorTooltip.position({\r\n                of: $(element),\r\n                my: onLeft ? \"right center\" : \"left center\",\r\n                at: onLeft ? \"left center\" : \"right center\",\r\n                collision: \"flip fit\",\r\n                using: function(obj, info) {\r\n                    if (info[\"horizontal\"] === \"right\") {\r\n                        $(this).addClass(\"error-left-side\");\r\n                    } else {\r\n                        $(this).removeClass(\"error-left-side\");\r\n                    }\r\n\r\n                    $(this).css({\r\n                        left: obj[\"left\"] + \"px\",\r\n                        top: obj[\"top\"] + \"px\",\r\n                    });\r\n                },\r\n            });\r\n\r\n            return $errorTooltip;\r\n        }\r\n    }\r\n}\r\n","/*globals Backbone,_,$,console */\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    interface TooltipPosition {\n        bottom?: number;\n        left?: number;\n        right?: number;\n        top?: number;\n    }\n\n    export interface TooltipOptions {\n        anchorEl?: HTMLElement;\n        cssClass?: string;\n        data?: any;\n        text?: string;\n        position?: TooltipPosition;\n    }\n\n    export class GenericTooltip extends Backbone.View<Backbone.Model> {\n        private static directions = [\"left\", \"right\", \"top\", \"bottom\"];\n\n        public text: string;\n\n        private cssClass: string;\n        private anchorEl: HTMLElement;\n        private data;\n        private position: TooltipPosition;\n        private templateFn?; // handlebars compiled function\n\n        constructor(options: TooltipOptions) {\n            super(options as any);\n            this.cssClass = options.cssClass;\n            this.anchorEl = options.anchorEl;\n            this.data = options.data || {};\n            this.text = options.text;\n            this.position = options.position;\n\n            this.$el.addClass(\"generic-tooltip \" + this.cssClass);\n            this.$el.appendTo(\"#appdiv\");\n\n            this.compileTemplate();\n        }\n\n        public remove(): Backbone.View {\n            return Backbone.View.prototype.remove.call(this);\n        }\n\n        public renderTemplate(data?): void {\n            try {\n                const visible =\n                    !this.anchorEl || (this.anchorEl.offsetWidth && this.anchorEl.offsetHeight);\n                // if anchor element is not visible, don't show tooltip\n                this.el.style.display = visible ? \"\" : \"none\";\n                if (visible) {\n                    this.el.innerHTML =\n                        \"<div>\" + this.templateFn(_.extend({}, this.data, data)) + \"</div>\";\n                    this.updatePosition(this.position);\n                }\n            } catch (e) {\n                console.log(this.cssClass + \" handlebars render error.\", e);\n            }\n        }\n\n        // adds props to the tooltip's inline CSS\n        public updateCSS(props): GenericTooltip {\n            this.$el.css(\n                _.reduce(\n                    props,\n                    (res, val: string, key: string) => {\n                        res[key] = val;\n                        return res;\n                    },\n                    {},\n                ),\n            );\n            return this;\n        }\n\n        // adds left, right, top, and/or bottom to the tooltip's inline CSS\n        // the anchorEl element is used as a reference to adjust the tooltip position as necessary\n        public updatePosition(props: TooltipPosition): GenericTooltip {\n            let absPos;\n            if (this.anchorEl) {\n                absPos = this.anchorEl.getBoundingClientRect();\n            }\n            return this.updateCSS(\n                _.mapValues(\n                    _.pickBy(props, v => !_.isNil(v)),\n                    (v, k) => {\n                        let pos = Math.max(0, v);\n                        // add in the component's global position\n                        pos += absPos ? absPos[k] : 0;\n                        // prevent overflow beyond window size\n                        if (\n                            (k === \"left\" || k === \"right\") &&\n                            $(window).width() < pos + this.$el.outerWidth()\n                        ) {\n                            pos = $(window).width() - this.$el.outerWidth();\n                        } else if (\n                            (k === \"top\" || k === \"bottom\") &&\n                            $(window).height() < pos + this.$el.outerHeight()\n                        ) {\n                            pos = $(window).height() - this.$el.outerHeight();\n                        }\n                        return pos + \"px\";\n                    },\n                ),\n            );\n        }\n\n        public updateTooltip(props: TooltipOptions): GenericTooltip {\n            _.each(props, (v, k) => {\n                this[k] = v;\n            });\n            return this;\n        }\n\n        private compileTemplate(): void {\n            try {\n                this.templateFn = Handlebars.compile(this.text);\n            } catch (e) {\n                console.log(this.cssClass + \" handlebars compile error.\", e);\n            }\n        }\n    }\n}\n","/*g\"obals Backbone,_,$,console,Tools,moment */ // eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class Helpers {\r\n        public static convertRollingToDate(val, type) {\r\n            let m = Tools.convertValueToMoment(null, type), // get current time in user's timezone\r\n                modifier,\r\n                regexResult,\r\n                time;\r\n\r\n            if (!val) {\r\n                val = \"NOW\";\r\n            }\r\n\r\n            if (Tools.getTypeCategory(type) === \"duration\") {\r\n                m = Tools.convertValueToDuration(m.formatNano(\"HH:mm:ss.SSS\"), type);\r\n            }\r\n\r\n            if (val === \"T\") {\r\n                if (_.includes([\"date\", \"datetime\", \"timestamp\"], type)) {\r\n                    (m as moment.Moment).set({\r\n                        hour: 0,\r\n                        minute: 0,\r\n                        second: 0,\r\n                        millisecond: 0,\r\n                    });\r\n                }\r\n            } else if (val.toString().match(RTTI.REGEX_ROLLING)) {\r\n                // handle T+x, T-x first\r\n                regexResult = val.toString().match(/^T([\\+|\\-]\\d+)/);\r\n                if (regexResult) {\r\n                    modifier = parseInt(regexResult[1], 10);\r\n                    if (modifier) {\r\n                        switch (type) {\r\n                            case \"date\":\r\n                            case \"datetime\":\r\n                            case \"timestamp\":\r\n                                (m as moment.Moment).set({\r\n                                    hour: 0,\r\n                                    minute: 0,\r\n                                    second: 0,\r\n                                    millisecond: 0,\r\n                                });\r\n                                m.add(modifier, \"days\");\r\n                                break;\r\n                            case \"time\":\r\n                            case \"minute\":\r\n                                m.add(modifier, \"minutes\");\r\n                                break;\r\n                            case \"second\":\r\n                                m.add(modifier, \"seconds\");\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // pass anything after @ to moment's parser\r\n                regexResult = val.toString().match(/(?:@)(.+)$/);\r\n                if (regexResult) {\r\n                    // T+x@hh:mm:ss.SSS etc\r\n                    time = Tools.convertUserInputToMoment(regexResult[1], \"HH:mm:ss.SSS\");\r\n                    if (time.isValid() && !moment.isDuration(m)) {\r\n                        m.set({\r\n                            hour: time.hour(),\r\n                            minute: time.minute(),\r\n                            second: time.second(),\r\n                            millisecond: time.millisecond(),\r\n                        });\r\n\r\n                        if (time.nanosecond()) {\r\n                            m.nanosecond(time.nanosecond());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return m.toDashString();\r\n        }\r\n\r\n        public static convertViewSchemaToBackbone(root) {\r\n            const self = this,\r\n                defaultProps = {};\r\n\r\n            _.each(_.keys(root), function(key) {\r\n                if (_.isObject(root[key])) {\r\n                    defaultProps[key] = self.convertViewSchemaToBackbone(root[key]);\r\n                } else {\r\n                    defaultProps[key] = root[key];\r\n                }\r\n            });\r\n\r\n            return Backbone.Model.extend({\r\n                defaults: function() {\r\n                    const defaultObj = {};\r\n                    _.each(_.keys(defaultProps), function(key) {\r\n                        if (typeof defaultProps[key] === \"function\") {\r\n                            defaultObj[key] = new defaultProps[key]();\r\n                        } else {\r\n                            defaultObj[key] = defaultProps[key];\r\n                        }\r\n                    });\r\n\r\n                    return defaultObj;\r\n                },\r\n            });\r\n        }\r\n\r\n        public static getGUID() {\r\n            const S4 = function() {\r\n                return Math.floor((1 + Math.random()) * 0x10000 /* 65536 */)\r\n                    .toString(16)\r\n                    .substring(1);\r\n            };\r\n\r\n            return S4() + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + S4() + S4();\r\n        }\r\n\r\n        public static preventBackspaceBack() {\r\n            $(document).on(\"keydown\", function(e) {\r\n                let el,\r\n                    prevent = false;\r\n\r\n                if (e.which === 8) {\r\n                    el = e[\"srcElement\"] || e.target;\r\n                    if (\r\n                        (el.tagName.toUpperCase() === \"INPUT\" &&\r\n                            !_.includes([\"RADIO\", \"CHECKBOX\"], el.type.toUpperCase())) ||\r\n                        el.tagName.toUpperCase() === \"TEXTAREA\" ||\r\n                        $(el).hasClass(\"nicEdit-main\")\r\n                    ) {\r\n                        prevent = el.readOnly || el.disabled;\r\n                    } else {\r\n                        prevent = true;\r\n                    }\r\n                }\r\n\r\n                if (prevent) {\r\n                    e.preventDefault();\r\n                }\r\n            });\r\n        }\r\n\r\n        public static validateGuid(string) {\r\n            if (_.isString(string)) {\r\n                return string.match(\r\n                    /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,\r\n                );\r\n            }\r\n\r\n            return false;\r\n        }\r\n    }\r\n}\r\n","/*global require,Handlebars*/\r\n/// <reference path=\"../classes/log.ts\"/>\r\n/// <reference path=\"../lib/tools.ts\"/>\r\n/// <reference types=\"Handlebars\"/>\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export function InitializeQuickbase(callback) {\r\n        let globalize;\r\n\r\n        // Initialize Globalize\r\n        const language = $.cookie(\"dashboard-language\") || \"en\";\r\n\r\n        // Configure require.js paths\r\n        require.config({\r\n            paths: {\r\n                cldr: \"./locale/cldr\",\r\n                \"cldr-data\": \"./locale/cldr-data\",\r\n                globalize: \"./locale/globalize\",\r\n                locales: \"./locale/locales\",\r\n            },\r\n        });\r\n\r\n        require([\r\n            //'globalize',\r\n            // CLDR content\r\n            //'json!cldr-data/supplemental/likelySubtags.json',\r\n            // Translation content\r\n            \"json!locales/messages.json\",\r\n            // Extend Globalize\r\n            //'globalize/message'\r\n        ], function(/*Globalize, likelySubtags,*/ messages) {\r\n            const dict = messages[language || \"en\"] || {};\r\n            const translateFn = function(key) {\r\n                return dict[key] || key || \"\";\r\n            };\r\n\r\n            /*\r\n            Globalize.load(likelySubtags);\r\n            Globalize.loadMessages(messages);\r\n    \r\n            globalize = Globalize(language || 'en');\r\n    \r\n            translateFn = function (key) {\r\n                if (!key) {\r\n                    return '';\r\n                }\r\n    \r\n                try {\r\n                    return globalize.formatMessage(key);\r\n                } catch (e) {\r\n                    switch (e.code) {\r\n                        case 'E_MISSING_MESSAGE':\r\n                            //console.log('Missing Translation for \"' + e.path + '\"');\r\n                            break;\r\n                        default:\r\n                            Log.Error('Globalize error: \"' + e.message + '\"');\r\n                            break;\r\n                    }\r\n                }\r\n                return key;\r\n            };*/\r\n\r\n            // Attach translateFn to window and Handlebars\r\n            window[\"t\"] = translateFn;\r\n\r\n            Handlebars.registerHelper(\"moment\", function(str: string, pattern: any, options: any) {\r\n                if (str == null && pattern) {\r\n                    return;\r\n                }\r\n\r\n                // if no args are passed, return a formatted date\r\n                if (str == null && pattern == null) {\r\n                    moment.locale(\"en\");\r\n                    return moment().format(\"MMMM DD, YYYY\");\r\n                }\r\n\r\n                // options may be passed in arg1 or arg2, merge args to object\r\n                let opts: any = { lang: \"en\", date: new Date() };\r\n                opts = _.extend({}, opts, str, pattern, options);\r\n                opts = _.extend({}, opts, opts.hash);\r\n                // set the language to use\r\n                moment.locale(opts.lang);\r\n\r\n                // if both args are strings, this could apply to either lib.\r\n                // so instead of doing magic we'll just ask the user to tell\r\n                // us if the args should be passed to date.js or moment.\r\n                if (typeof str === \"string\" && typeof pattern === \"string\") {\r\n                    return moment(str).format(pattern);\r\n                }\r\n\r\n                if (Tools.isKDBTemporal(str)) {\r\n                    const m = Tools.convertKDBTemporalToMoment(str);\r\n                    if (moment.isDuration(m)) {\r\n                        return m.formatNano(pattern);\r\n                    }\r\n                    return m.format(pattern);\r\n                }\r\n\r\n                // If handlebars, expose moment methods as hash properties\r\n                if (opts.hash) {\r\n                    if (opts.context) {\r\n                        _.extend(opts.hash, opts.context);\r\n                    }\r\n                    const res = moment(str);\r\n                    for (const key in opts.hash) {\r\n                        if (res[key]) {\r\n                            return res[key](opts.hash[key]);\r\n                        } else {\r\n                            console.log('moment.js does not support \"' + key + '\"');\r\n                        }\r\n                    }\r\n                }\r\n                if (typeof str === \"object\") {\r\n                    return moment(str).format(pattern);\r\n                }\r\n                // if only a string is passed, assume it's a date pattern ('YYYY')\r\n                if (typeof str === \"string\" && !pattern) {\r\n                    return moment().format(str);\r\n                }\r\n\r\n                return moment(str).format(pattern);\r\n            });\r\n\r\n            Handlebars.registerHelper(\"t\", function(key) {\r\n                return translateFn(key);\r\n            });\r\n            /**\r\n             * Get the native type of the given `value`\r\n             *  Adapted version of kind-Of module https://github.com/jonschlinkert/kind-of\r\n             *  common type sets replaced by lodash function\r\n             *  this is used in typeOf helper in handlebars.helpers v0.9.0\r\n             *\r\n             * ```handlebars\r\n             * {{typeOf 1}}\r\n             * //=> 'number'\r\n             * {{typeOf \"1\"}}\r\n             * //=> 'string'\r\n             * {{typeOf \"foo\"}}\r\n             * //=> 'string'\r\n             * ```\r\n             * @param {any} `value`\r\n             * @return {String} Returns the type of value.\r\n             */\r\n            Handlebars.registerHelper(\"typeOf\", function(val): string {\r\n                const toStringFn = Object.prototype.toString;\r\n\r\n                const ctorName = function(val) {\r\n                    return val.constructor ? val.constructor.name : null;\r\n                };\r\n\r\n                const isGeneratorFn = function(name, val?: any) {\r\n                    return ctorName(name) === \"GeneratorFunction\";\r\n                };\r\n\r\n                const isGeneratorObj = function(val) {\r\n                    return (\r\n                        typeof val.throw === \"function\" &&\r\n                        typeof val.return === \"function\" &&\r\n                        typeof val.next === \"function\"\r\n                    );\r\n                };\r\n\r\n                if (val === void 0) return \"undefined\";\r\n                if (val === null) return \"null\";\r\n\r\n                let type = typeof val as any;\r\n                if (type === \"boolean\") return \"boolean\";\r\n                if (type === \"string\") return \"string\";\r\n                if (type === \"number\") return \"number\";\r\n                if (type === \"symbol\") return \"symbol\";\r\n                if (type === \"function\") {\r\n                    return isGeneratorFn(val) ? \"generatorfunction\" : \"function\";\r\n                }\r\n                // Custom kdb Date type checker\r\n                if (Tools.isKDBTemporal(val)) {\r\n                    return Tools.Types.kdbToDashboard[val.class];\r\n                }\r\n\r\n                if (_.isArray(val)) return \"array\";\r\n                if (_.isBuffer(val)) return \"buffer\";\r\n                if (_.isArguments(val)) return \"arguments\";\r\n                if (_.isDate(val)) return \"date\";\r\n                if (_.isError(val)) return \"error\";\r\n                if (_.isRegExp(val)) return \"regexp\";\r\n\r\n                switch (ctorName(val)) {\r\n                    case \"Symbol\":\r\n                        return \"symbol\";\r\n                    case \"Promise\":\r\n                        return \"promise\";\r\n\r\n                    // Set, Map, WeakSet, WeakMap\r\n                    case \"WeakMap\":\r\n                        return \"weakmap\";\r\n                    case \"WeakSet\":\r\n                        return \"weakset\";\r\n                    case \"Map\":\r\n                        return \"map\";\r\n                    case \"Set\":\r\n                        return \"set\";\r\n\r\n                    // 8-bit typed arrays\r\n                    case \"Int8Array\":\r\n                        return \"int8array\";\r\n                    case \"Uint8Array\":\r\n                        return \"uint8array\";\r\n                    case \"Uint8ClampedArray\":\r\n                        return \"uint8clampedarray\";\r\n\r\n                    // 16-bit typed arrays\r\n                    case \"Int16Array\":\r\n                        return \"int16array\";\r\n                    case \"Uint16Array\":\r\n                        return \"uint16array\";\r\n\r\n                    // 32-bit typed arrays\r\n                    case \"Int32Array\":\r\n                        return \"int32array\";\r\n                    case \"Uint32Array\":\r\n                        return \"uint32array\";\r\n                    case \"Float32Array\":\r\n                        return \"float32array\";\r\n                    case \"Float64Array\":\r\n                        return \"float64array\";\r\n                }\r\n\r\n                if (isGeneratorObj(val)) {\r\n                    return \"generator\";\r\n                }\r\n\r\n                // Non-plain objects\r\n                type = toStringFn.call(val);\r\n\r\n                switch (type) {\r\n                    case \"[object Object]\":\r\n                        return \"object\";\r\n                    // iterators\r\n                    case \"[object Map Iterator]\":\r\n                        return \"mapiterator\";\r\n                    case \"[object Set Iterator]\":\r\n                        return \"setiterator\";\r\n                    case \"[object String Iterator]\":\r\n                        return \"stringiterator\";\r\n                    case \"[object Array Iterator]\":\r\n                        return \"arrayiterator\";\r\n                }\r\n\r\n                // other\r\n                return type\r\n                    .slice(8, -1)\r\n                    .toLowerCase()\r\n                    .replace(/\\s/g, \"\");\r\n            });\r\n\r\n            Handlebars.registerHelper(\"isNull\", function(val, strict?: boolean): boolean {\r\n                if (strict === true) {\r\n                    return _.isNull(val);\r\n                } else {\r\n                    //for strings empty string consider as null\r\n                    return _.isString(val) ? val.length === 0 : _.isNull(val);\r\n                }\r\n            });\r\n\r\n            Handlebars.registerHelper(\"encodeURI\", function(val): string {\r\n                // null or undefined\r\n                return val == null ? \"\" : encodeURI(val);\r\n            });\r\n\r\n            Handlebars.registerHelper(\"encodeURIComponent\", function(val): string {\r\n                // null or undefined\r\n                return val == null ? \"\" : encodeURIComponent(val);\r\n            });\r\n\r\n            Handlebars.registerHelper(\"toISOString\", function(val): string {\r\n                return QuickBase.Tools.convertKDBToViewstateValue(val);\r\n            });\r\n\r\n            if (_.isFunction(callback)) {\r\n                callback({\r\n                    globalize: globalize,\r\n                    language: language,\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n","// 2016.03.18 char vectors and symbols now [de]serialize [from]to utf8\r\n// 2014.03.18 Serialize date now adjusts for timezone.\r\n// 2013.04.29 Dict decodes to map, except for keyed tables.\r\n// 2013.02.13 Keyed tables were not being decoded correctly.\r\n// 2012.06.20 Fix up browser compatibility. Strings starting with ` encode as symbol type.\r\n// 2012.05.15 Provisional test release, subject to change\r\n// for use with websockets and kdb+v3.0, (de)serializing kdb+ ipc formatted data within javascript within a browser.\r\n// e.g. on kdb+ process, set .z.ws:{neg[.z.w] -8!value -9!x;}\r\n// and then within javascript websocket.send(serialize(\"10+20\"));\r\n// ws.onmessage=function(e){var arrayBuffer=e.data;if(arrayBuffer){var v=deserialize(arrayBuffer);...\r\n// note ws.binaryType = 'arraybuffer';\r\n\r\n/// <reference path=\"tools.ts\" />\r\n/// <reference path=\"moment.d.ts\" />\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    var JS_DATE_MAX = 8640000000000000;\r\n\r\n    export class rTimestampClass {\r\n        i: number;\r\n        n: number;\r\n\r\n        constructor(i: number, n: number) {\r\n            this.i = i;\r\n            this.n = n;\r\n        }\r\n\r\n        toDate(): moment.Moment {\r\n            return QuickBase.Tools.convertKDBTemporalToMoment(this) as moment.Moment;\r\n        }\r\n\r\n        toString(): string {\r\n            return this.toDate().formatNano(\"YYYY-MM-DD HH:mm:ss.SSSSSSSSS\");\r\n        }\r\n    }\r\n\r\n    export class rMonthClass {\r\n        i: number;\r\n\r\n        constructor(i: number) {\r\n            this.i = i;\r\n        }\r\n\r\n        toDate(): moment.Moment {\r\n            return Tools.convertKDBTemporalToMoment(this) as moment.Moment;\r\n        }\r\n\r\n        toString(): string {\r\n            return typeof this.i === \"number\" && !isNaN(this.i)\r\n                ? this.i === Number.POSITIVE_INFINITY\r\n                    ? \"Infinity\"\r\n                    : this.i === Number.NEGATIVE_INFINITY\r\n                    ? \"-Infinity\"\r\n                    : this.toDate().format(\"YYYY-MM\")\r\n                : \"\";\r\n        }\r\n    }\r\n\r\n    export class rDateClass {\r\n        i: number;\r\n        n: number;\r\n\r\n        constructor(i: number, n?: number) {\r\n            this.i = i;\r\n            this.n = n;\r\n        }\r\n\r\n        toDate(): moment.Moment {\r\n            return Tools.convertKDBTemporalToMoment(this) as moment.Moment;\r\n        }\r\n\r\n        toString(): string {\r\n            return typeof this.i === \"number\" && !isNaN(this.i)\r\n                ? this.i === Number.POSITIVE_INFINITY\r\n                    ? \"Infinity\"\r\n                    : this.i === Number.NEGATIVE_INFINITY\r\n                    ? \"-Infinity\"\r\n                    : moment(new Date(this.i))\r\n                          .utcOffset(0)\r\n                          .format(\"YYYY-MM-DD\")\r\n                : \"\";\r\n        }\r\n    }\r\n\r\n    export class rDateTimeClass {\r\n        i: number;\r\n\r\n        constructor(i: number) {\r\n            this.i = i;\r\n        }\r\n\r\n        toDate(): moment.Moment {\r\n            return Tools.convertKDBTemporalToMoment(this) as moment.Moment;\r\n        }\r\n\r\n        toString(): string {\r\n            return this.toDate().format(\"YYYY-MM-DD HH:mm:ss.SSS\");\r\n        }\r\n    }\r\n\r\n    export class rTimespanClass {\r\n        i: number;\r\n\r\n        constructor(i: number) {\r\n            this.i = i;\r\n        }\r\n\r\n        toDate(): moment.Duration {\r\n            return Tools.convertKDBTemporalToMoment(this) as moment.Duration;\r\n        }\r\n\r\n        toString(): string {\r\n            return this.toDate().formatNano(\"HH:mm:ss.SSSSSSSSS\", { trim: false });\r\n        }\r\n    }\r\n\r\n    export class rMinuteClass {\r\n        i: number;\r\n        n: number;\r\n\r\n        constructor(i: number) {\r\n            this.i = i;\r\n            this.n = 0;\r\n        }\r\n\r\n        toDate(): moment.Duration {\r\n            return Tools.convertKDBTemporalToMoment(this) as moment.Duration;\r\n        }\r\n\r\n        toString(): string {\r\n            return this.toDate().format(\"HH:mm\", { trim: false });\r\n        }\r\n    }\r\n\r\n    export class rSecondClass {\r\n        i: number;\r\n\r\n        constructor(i: number) {\r\n            this.i = i;\r\n        }\r\n\r\n        toDate(): moment.Duration {\r\n            return Tools.convertKDBTemporalToMoment(this) as moment.Duration;\r\n        }\r\n\r\n        toString(): string {\r\n            return this.toDate().format(\"HH:mm:ss\", { trim: false });\r\n        }\r\n    }\r\n\r\n    export class rTimeClass {\r\n        i: number;\r\n\r\n        constructor(i: number) {\r\n            this.i = i;\r\n        }\r\n\r\n        toDate(): moment.Duration {\r\n            return Tools.convertKDBTemporalToMoment(this) as moment.Duration;\r\n        }\r\n\r\n        toString(): string {\r\n            return this.toDate().format(\"HH:mm:ss.SSS\", { trim: false });\r\n        }\r\n    }\r\n\r\n    // annotate clases\r\n    rTimestampClass.prototype[\"class\"] = \"1212\";\r\n    rMonthClass.prototype[\"class\"] = \"1213\";\r\n    rDateClass.prototype[\"class\"] = \"1214\";\r\n    rDateTimeClass.prototype[\"class\"] = \"1215\";\r\n    rTimespanClass.prototype[\"class\"] = \"1216\";\r\n    rMinuteClass.prototype[\"class\"] = \"1217\";\r\n    rSecondClass.prototype[\"class\"] = \"1218\";\r\n    rTimeClass.prototype[\"class\"] = \"1219\";\r\n}\r\n","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class Long {\n        // The internal representation of a long is the two given signed, 32-bit values.\n        // We use 32-bit pieces because these are the size of integers on which\n        // Javascript performs bit-operations.  For operations like addition and\n        // multiplication, we split each number into 16 bit pieces, which can easily be\n        // multiplied within Javascript's floating-point representation without overflow\n        // or change in sign.\n        //\n        // In the algorithms below, we frequently reduce the negative case to the\n        // positive case by negating the input(s) and then post-processing the result.\n        // Note that we must ALWAYS check specially whether those values are MIN_VALUE\n        // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n        // a positive number, it overflows back into a negative).  Not handling this\n        // case would often result in infinite recursion.\n        //\n        // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n        // methods on which they depend.\n\n        /**\n         * An indicator used to reliably determine if an object is a Long or not.\n         * @type {boolean}\n         * @const\n         * @private\n         */\n        __isLong__: boolean;\n        low: number;\n        high: number;\n        unsigned: boolean;\n\n        /**\n         * wasm optimizations, to do native i64 multiplication and divide\n         */\n        static wasm = null;\n\n        constructor(low: number, high?: number, unsigned?: boolean) {\n            /**\n             * The low 32 bits as a signed value.\n             * @type {number}\n             */\n            this.low = low | 0;\n\n            /**\n             * The high 32 bits as a signed value.\n             * @type {number}\n             */\n            this.high = high | 0;\n\n            /**\n             * Whether unsigned or not.\n             * @type {boolean}\n             */\n            this.unsigned = !!unsigned;\n        }\n\n        /**\n         * @function\n         * @param {*} obj Object\n         * @returns {boolean}\n         * @inner\n         */\n        static isLong(obj: any): obj is Long {\n            return (obj && obj[\"__isLong__\"]) === true;\n        }\n\n        /**\n         * A cache of the Long representations of small integer values.\n         * @type {!Object}\n         * @inner\n         */\n        private static INT_CACHE = {};\n\n        /**\n         * A cache of the Long representations of small unsigned integer values.\n         * @type {!Object}\n         * @inner\n         */\n        private static UINT_CACHE = {};\n\n        /**\n         * Returns a Long representing the given 32 bit integer value.\n         * @function\n         * @param {number} value The 32 bit integer in question\n         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n         * @returns {!Long} The corresponding Long value\n         */\n        static fromInt(value: number, unsigned?: boolean): Long {\n            let obj, cachedObj, cache;\n            if (unsigned) {\n                value >>>= 0;\n                if ((cache = 0 <= value && value < 256)) {\n                    cachedObj = Long.UINT_CACHE[value];\n                    if (cachedObj) return cachedObj;\n                }\n                obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n                if (cache) Long.UINT_CACHE[value] = obj;\n                return obj;\n            } else {\n                value |= 0;\n                if ((cache = -128 <= value && value < 128)) {\n                    cachedObj = Long.INT_CACHE[value];\n                    if (cachedObj) return cachedObj;\n                }\n                obj = Long.fromBits(value, value < 0 ? -1 : 0, false);\n                if (cache) Long.INT_CACHE[value] = obj;\n                return obj;\n            }\n        }\n\n        /**\n         * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n         * @function\n         * @param {number} value The number in question\n         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n         * @returns {!Long} The corresponding Long value\n         */\n        static fromNumber(value: number, unsigned?: boolean): Long {\n            if (isNaN(value)) return unsigned ? Long.UZERO : Long.ZERO;\n            if (unsigned) {\n                if (value < 0) return Long.UZERO;\n                if (value >= Long.TWO_PWR_64_DBL) return Long.MAX_UNSIGNED_VALUE;\n            } else {\n                if (value <= -Long.TWO_PWR_63_DBL) return Long.MIN_VALUE;\n                if (value + 1 >= Long.TWO_PWR_63_DBL) return Long.MAX_VALUE;\n            }\n            if (value < 0) return Long.fromNumber(-value, unsigned).neg();\n            return Long.fromBits(\n                value % Long.TWO_PWR_32_DBL | 0,\n                (value / Long.TWO_PWR_32_DBL) | 0,\n                unsigned,\n            );\n        }\n\n        /**\n         * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n         *  assumed to use 32 bits.\n         * @function\n         * @param {number} lowBits The low 32 bits\n         * @param {number} highBits The high 32 bits\n         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n         * @returns {!Long} The corresponding Long value\n         */\n        static fromBits(lowBits: number, highBits: number, unsigned?: boolean): Long {\n            return new Long(lowBits, highBits, unsigned);\n        }\n\n        /**\n         * Returns a Long representation of the given string, written using the specified radix.\n         * @function\n         * @param {string} str The textual representation of the Long\n         * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n         * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n         * @returns {!Long} The corresponding Long value\n         */\n        static fromString(str: string, unsigned?: boolean | number, radix?: number): Long {\n            if (str.length === 0) throw Error(\"empty string\");\n            if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\n                return Long.ZERO;\n            if (typeof unsigned === \"number\") {\n                // For goog.math.long compatibility\n                (radix = unsigned), (unsigned = false);\n            } else {\n                unsigned = !!unsigned;\n            }\n            radix = radix || 10;\n            if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n\n            let p;\n            if ((p = str.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n            else if (p === 0) {\n                return Long.fromString(str.substring(1), unsigned, radix).neg();\n            }\n\n            // Do several (8) digits each time through the loop, so as to\n            // minimize the calls to the very expensive emulated div.\n            const radixToPower = Long.fromNumber(Math.pow(radix, 8));\n\n            let result = Long.ZERO;\n            for (let i = 0; i < str.length; i += 8) {\n                const size = Math.min(8, str.length - i),\n                    value = parseInt(str.substring(i, i + size), radix);\n                if (size < 8) {\n                    const power = Long.fromNumber(Math.pow(radix, size));\n                    result = result.mul(power).add(Long.fromNumber(value));\n                } else {\n                    result = result.mul(radixToPower);\n                    result = result.add(Long.fromNumber(value));\n                }\n            }\n            result.unsigned = unsigned;\n            return result;\n        }\n\n        /**\n         * Converts the specified value to a Long using the appropriate from* function for its type.\n         * @function\n         * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n         * @returns {!Long}\n         */\n        static fromValue(\n            val: Long | number | string | { low: number; high: number; unsigned: boolean },\n            unsigned?: boolean,\n        ): Long {\n            if (typeof val === \"number\") return Long.fromNumber(val, unsigned);\n            if (typeof val === \"string\") return Long.fromString(val, unsigned);\n            // Throws for non-objects, converts non-instanceof Long:\n            return Long.fromBits(\n                val.low,\n                val.high,\n                typeof unsigned === \"boolean\" ? unsigned : val.unsigned,\n            );\n        }\n\n        // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n        // no runtime penalty for these.\n\n        /**\n         * @type {number}\n         * @const\n         * @inner\n         */\n        static TWO_PWR_16_DBL = 1 << 16;\n\n        /**\n         * @type {number}\n         * @const\n         * @inner\n         */\n        static TWO_PWR_24_DBL = 1 << 24;\n\n        /**\n         * @type {number}\n         * @const\n         * @inner\n         */\n        static TWO_PWR_32_DBL = Long.TWO_PWR_16_DBL * Long.TWO_PWR_16_DBL;\n\n        /**\n         * @type {number}\n         * @const\n         * @inner\n         */\n        static TWO_PWR_64_DBL = Long.TWO_PWR_32_DBL * Long.TWO_PWR_32_DBL;\n\n        /**\n         * @type {number}\n         * @const\n         * @inner\n         */\n        static TWO_PWR_63_DBL = Long.TWO_PWR_64_DBL / 2;\n\n        /**\n         * @type {!Long}\n         * @const\n         * @inner\n         */\n        static TWO_PWR_24 = Long.fromInt(Long.TWO_PWR_24_DBL);\n\n        /**\n    /**\n     * Signed zero.\n     * @type {!Long}\n     */\n        static ZERO = Long.fromInt(0);\n\n        /**\n         * Unsigned zero.\n         * @type {!Long}\n         */\n        static UZERO = Long.fromInt(0, true);\n\n        /**\n         * Signed one.\n         * @type {!Long}\n         */\n        static ONE = Long.fromInt(1);\n\n        /**\n         * Unsigned one.\n         * @type {!Long}\n         */\n        static UONE = Long.fromInt(1, true);\n\n        /**\n         * Signed negative one.\n         * @type {!Long}\n         */\n        static NEG_ONE = Long.fromInt(-1);\n\n        /**\n         * Maximum signed value.\n         * @type {!Long}\n         */\n        static MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\n\n        /**\n         * Maximum unsigned value.\n         * @type {!Long}\n         */\n        static MAX_UNSIGNED_VALUE = Long.fromBits(0xffffffff | 0, 0xffffffff | 0, true);\n\n        /**\n         * Minimum signed value.\n         * @type {!Long}\n         */\n        static MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);\n\n        /**\n         * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n         * @this {!Long}\n         * @returns {number}\n         */\n        toInt(): number {\n            return this.unsigned ? this.low >>> 0 : this.low;\n        }\n\n        /**\n         * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n         * @this {!Long}\n         * @returns {number}\n         */\n        toNumber(): number {\n            if (this.unsigned) return (this.high >>> 0) * Long.TWO_PWR_32_DBL + (this.low >>> 0);\n            return this.high * Long.TWO_PWR_32_DBL + (this.low >>> 0);\n        }\n\n        /**\n         * Converts the Long to a string written in the specified radix.\n         * @this {!Long}\n         * @param {number=} radix Radix (2-36), defaults to 10\n         * @returns {string}\n         * @override\n         * @throws {RangeError} If `radix` is out of range\n         */\n        toString(radix?: number): string {\n            radix = radix || 10;\n            if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n            if (this.isZero()) return \"0\";\n            if (this.isNegative()) {\n                // Unsigned Longs are never negative\n                if (this.eq(Long.MIN_VALUE)) {\n                    // We need to change the Long value before it can be negated, so we remove\n                    // the bottom-most digit in this base and then recurse to do the rest.\n                    const radixLong = Long.fromNumber(radix),\n                        div = this.div(radixLong),\n                        rem1 = div.mul(radixLong).sub(this);\n                    return div.toString(radix) + rem1.toInt().toString(radix);\n                } else return \"-\" + this.neg().toString(radix);\n            }\n\n            // Do several (6) digits each time through the loop, so as to\n            // minimize the calls to the very expensive emulated div.\n            let radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned),\n                rem = this;\n            let result = \"\";\n            while (true) {\n                let remDiv = rem.div(radixToPower),\n                    intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\n                    digits = intval.toString(radix);\n                rem = remDiv;\n                if (rem.isZero()) return digits + result;\n                else {\n                    while (digits.length < 6) digits = \"0\" + digits;\n                    result = \"\" + digits + result;\n                }\n            }\n        }\n\n        /**\n         * Gets the high 32 bits as a signed integer.\n         * @this {!Long}\n         * @returns {number} Signed high bits\n         */\n        getHighBits(): number {\n            return this.high;\n        }\n\n        /**\n         * Gets the high 32 bits as an unsigned integer.\n         * @this {!Long}\n         * @returns {number} Unsigned high bits\n         */\n        getHighBitsUnsigned(): number {\n            return this.high >>> 0;\n        }\n\n        /**\n         * Gets the low 32 bits as a signed integer.\n         * @this {!Long}\n         * @returns {number} Signed low bits\n         */\n        getLowBits(): number {\n            return this.low;\n        }\n\n        /**\n         * Gets the low 32 bits as an unsigned integer.\n         * @this {!Long}\n         * @returns {number} Unsigned low bits\n         */\n        getLowBitsUnsigned(): number {\n            return this.low >>> 0;\n        }\n\n        /**\n         * Gets the number of bits needed to represent the absolute value of this Long.\n         * @this {!Long}\n         * @returns {number}\n         */\n        getNumBitsAbs(): number {\n            if (this.isNegative())\n                // Unsigned Longs are never negative\n                return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n            const val = this.high != 0 ? this.high : this.low;\n            for (var bit = 31; bit > 0; bit--) if ((val & (1 << bit)) != 0) break;\n            return this.high != 0 ? bit + 33 : bit + 1;\n        }\n\n        /**\n         * Tests if this Long's value equals zero.\n         * @this {!Long}\n         * @returns {boolean}\n         */\n        isZero(): boolean {\n            return this.high === 0 && this.low === 0;\n        }\n\n        /**\n         * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n         * @returns {boolean}\n         */\n        eqz = this.isZero.bind(this);\n\n        /**\n         * Tests if this Long's value is negative.\n         * @this {!Long}\n         * @returns {boolean}\n         */\n        isNegative(): boolean {\n            return !this.unsigned && this.high < 0;\n        }\n\n        /**\n         * Tests if this Long's value is positive.\n         * @this {!Long}\n         * @returns {boolean}\n         */\n        isPositive(): boolean {\n            return this.unsigned || this.high >= 0;\n        }\n\n        /**\n         * Tests if this Long's value is odd.\n         * @this {!Long}\n         * @returns {boolean}\n         */\n        isOdd(): boolean {\n            return (this.low & 1) === 1;\n        }\n\n        /**\n         * Tests if this Long's value is even.\n         * @this {!Long}\n         * @returns {boolean}\n         */\n        isEven(): boolean {\n            return (this.low & 1) === 0;\n        }\n\n        /**\n         * Tests if this Long's value equals the specified's.\n         * @this {!Long}\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        equals(other: Long | number | string): boolean {\n            if (!Long.isLong(other)) other = Long.fromValue(other);\n            if (\n                this.unsigned !== other.unsigned &&\n                this.high >>> 31 === 1 &&\n                other.high >>> 31 === 1\n            )\n                return false;\n            return this.high === other.high && this.low === other.low;\n        }\n\n        /**\n         * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n         * @function\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        eq = this.equals.bind(this);\n\n        /**\n         * Tests if this Long's value differs from the specified's.\n         * @this {!Long}\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        notEquals(other: Long | number | string): boolean {\n            return !this.eq(/* validates */ other);\n        }\n\n        /**\n         * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n         * @function\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        neq = this.notEquals.bind(this);\n\n        /**\n         * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n         * @function\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        ne = this.notEquals.bind(this);\n\n        /**\n         * Tests if this Long's value is less than the specified's.\n         * @this {!Long}\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        lessThan(other: Long | number | string): boolean {\n            return this.comp(/* validates */ other) < 0;\n        }\n\n        /**\n         * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n         * @function\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        lt = this.lessThan.bind(this);\n\n        /**\n         * Tests if this Long's value is less than or equal the specified's.\n         * @this {!Long}\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        lessThanOrEqual(other: Long | number | string): boolean {\n            return this.comp(/* validates */ other) <= 0;\n        }\n\n        /**\n         * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n         * @function\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        lte = this.lessThanOrEqual.bind(this);\n\n        /**\n         * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n         * @function\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        le = this.lessThanOrEqual.bind(this);\n\n        /**\n         * Tests if this Long's value is greater than the specified's.\n         * @this {!Long}\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        greaterThan(other: Long | number | string): boolean {\n            return this.comp(/* validates */ other) > 0;\n        }\n\n        /**\n         * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n         * @function\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        gt = this.greaterThan.bind(this);\n\n        /**\n         * Tests if this Long's value is greater than or equal the specified's.\n         * @this {!Long}\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        greaterThanOrEqual(other: Long | number | string): boolean {\n            return this.comp(/* validates */ other) >= 0;\n        }\n\n        /**\n         * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n         * @function\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        gte = this.greaterThanOrEqual.bind(this);\n\n        /**\n         * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n         * @function\n         * @param {!Long|number|string} other Other value\n         * @returns {boolean}\n         */\n        ge = this.greaterThanOrEqual.bind(this);\n\n        /**\n         * Compares this Long's value with the specified's.\n         * @this {!Long}\n         * @param {!Long|number|string} other Other value\n         * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n         *  if the given one is greater\n         */\n        compare(other: Long | number | string): number {\n            if (!Long.isLong(other)) other = Long.fromValue(other);\n            if (this.eq(other)) return 0;\n            const thisNeg = this.isNegative(),\n                otherNeg = other.isNegative();\n            if (thisNeg && !otherNeg) return -1;\n            if (!thisNeg && otherNeg) return 1;\n            // At this point the sign bits are the same\n            if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;\n            // Both are positive if at least one is unsigned\n            return other.high >>> 0 > this.high >>> 0 ||\n                (other.high === this.high && other.low >>> 0 > this.low >>> 0)\n                ? -1\n                : 1;\n        }\n\n        /**\n         * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n         * @function\n         * @param {!Long|number|string} other Other value\n         * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n         *  if the given one is greater\n         */\n        comp = this.compare.bind(this);\n\n        /**\n         * Negates this Long's value.\n         * @this {!Long}\n         * @returns {!Long} Negated Long\n         */\n        negate(): Long {\n            if (!this.unsigned && this.eq(Long.MIN_VALUE)) return Long.MIN_VALUE;\n            return this.not().add(Long.ONE);\n        }\n\n        /**\n         * Negates this Long's value. This is an alias of {@link Long#negate}.\n         * @function\n         * @returns {!Long} Negated Long\n         */\n        neg = this.negate.bind(this);\n\n        /**\n         * Returns the sum of this and the specified Long.\n         * @this {!Long}\n         * @param {!Long|number|string} addend Addend\n         * @returns {!Long} Sum\n         */\n        add(addend: Long | number | string): Long {\n            if (!Long.isLong(addend)) addend = Long.fromValue(addend);\n\n            // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n            const a48 = this.high >>> 16;\n            const a32 = this.high & 0xffff;\n            const a16 = this.low >>> 16;\n            const a00 = this.low & 0xffff;\n\n            const b48 = addend.high >>> 16;\n            const b32 = addend.high & 0xffff;\n            const b16 = addend.low >>> 16;\n            const b00 = addend.low & 0xffff;\n\n            let c48 = 0,\n                c32 = 0,\n                c16 = 0,\n                c00 = 0;\n            c00 += a00 + b00;\n            c16 += c00 >>> 16;\n            c00 &= 0xffff;\n            c16 += a16 + b16;\n            c32 += c16 >>> 16;\n            c16 &= 0xffff;\n            c32 += a32 + b32;\n            c48 += c32 >>> 16;\n            c32 &= 0xffff;\n            c48 += a48 + b48;\n            c48 &= 0xffff;\n            return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n        }\n\n        /**\n         * Returns the difference of this and the specified Long.\n         * @this {!Long}\n         * @param {!Long|number|string} subtrahend Subtrahend\n         * @returns {!Long} Difference\n         */\n        subtract(subtrahend: Long | number | string): Long {\n            if (!Long.isLong(subtrahend)) subtrahend = Long.fromValue(subtrahend);\n            return this.add(subtrahend.neg());\n        }\n\n        /**\n         * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n         * @function\n         * @param {!Long|number|string} subtrahend Subtrahend\n         * @returns {!Long} Difference\n         */\n        sub = this.subtract.bind(this);\n\n        /**\n         * Returns the product of this and the specified Long.\n         * @this {!Long}\n         * @param {!Long|number|string} multiplier Multiplier\n         * @returns {!Long} Product\n         */\n        multiply(multiplier: Long | number | string): Long {\n            if (this.isZero()) return Long.ZERO;\n            if (!Long.isLong(multiplier)) multiplier = Long.fromValue(multiplier);\n\n            // use wasm support if present\n            if (Long.wasm) {\n                const low = Long.wasm[\"mul\"](this.low, this.high, multiplier.low, multiplier.high);\n                return Long.fromBits(low, Long.wasm[\"get_high\"](), this.unsigned);\n            }\n\n            if (multiplier.isZero()) return Long.ZERO;\n            if (this.eq(Long.MIN_VALUE)) return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n            if (multiplier.eq(Long.MIN_VALUE)) return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n\n            if (this.isNegative()) {\n                if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());\n                else\n                    return this.neg()\n                        .mul(multiplier)\n                        .neg();\n            } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();\n\n            // If both longs are small, use float multiplication\n            if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24))\n                return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n\n            // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n            // We can skip products that would overflow.\n\n            const a48 = this.high >>> 16;\n            const a32 = this.high & 0xffff;\n            const a16 = this.low >>> 16;\n            const a00 = this.low & 0xffff;\n\n            const b48 = multiplier.high >>> 16;\n            const b32 = multiplier.high & 0xffff;\n            const b16 = multiplier.low >>> 16;\n            const b00 = multiplier.low & 0xffff;\n\n            let c48 = 0,\n                c32 = 0,\n                c16 = 0,\n                c00 = 0;\n            c00 += a00 * b00;\n            c16 += c00 >>> 16;\n            c00 &= 0xffff;\n            c16 += a16 * b00;\n            c32 += c16 >>> 16;\n            c16 &= 0xffff;\n            c16 += a00 * b16;\n            c32 += c16 >>> 16;\n            c16 &= 0xffff;\n            c32 += a32 * b00;\n            c48 += c32 >>> 16;\n            c32 &= 0xffff;\n            c32 += a16 * b16;\n            c48 += c32 >>> 16;\n            c32 &= 0xffff;\n            c32 += a00 * b32;\n            c48 += c32 >>> 16;\n            c32 &= 0xffff;\n            c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n            c48 &= 0xffff;\n            return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n        }\n\n        /**\n         * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n         * @function\n         * @param {!Long|number|string} multiplier Multiplier\n         * @returns {!Long} Product\n         */\n        mul = this.multiply.bind(this);\n\n        /**\n         * Returns this Long divided by the specified. The result is signed if this Long is signed or\n         *  unsigned if this Long is unsigned.\n         * @this {!Long}\n         * @param {!Long|number|string} divisor Divisor\n         * @returns {!Long} Quotient\n         */\n        divide(divisor: Long | number | string): Long {\n            if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);\n            if (divisor.isZero()) throw Error(\"division by zero\");\n\n            // use wasm support if present\n            if (Long.wasm) {\n                // guard against signed division overflow: the largest\n                // negative number / -1 would be 1 larger than the largest\n                // positive number, due to two's complement.\n                if (\n                    !this.unsigned &&\n                    this.high === -0x80000000 &&\n                    divisor.low === -1 &&\n                    divisor.high === -1\n                ) {\n                    // be consistent with non-wasm code path\n                    return this;\n                }\n                const low = (this.unsigned ? Long.wasm[\"div_u\"] : Long.wasm[\"div_s\"])(\n                    this.low,\n                    this.high,\n                    divisor.low,\n                    divisor.high,\n                );\n                return Long.fromBits(low, Long.wasm[\"get_high\"](), this.unsigned);\n            }\n\n            if (this.isZero()) return this.unsigned ? Long.UZERO : Long.ZERO;\n            let approx, rem, res;\n            if (!this.unsigned) {\n                // This section is only relevant for signed longs and is derived from the\n                // closure library as a whole.\n                if (this.eq(Long.MIN_VALUE)) {\n                    if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE)) return Long.MIN_VALUE;\n                    // recall that -MIN_VALUE == MIN_VALUE\n                    else if (divisor.eq(Long.MIN_VALUE)) return Long.ONE;\n                    else {\n                        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n                        const halfThis = this.shr(1);\n                        approx = halfThis.div(divisor).shl(1);\n                        if (approx.eq(Long.ZERO)) {\n                            return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;\n                        } else {\n                            rem = this.sub(divisor.mul(approx));\n                            res = approx.add(rem.div(divisor));\n                            return res;\n                        }\n                    }\n                } else if (divisor.eq(Long.MIN_VALUE))\n                    return this.unsigned ? Long.UZERO : Long.ZERO;\n                if (this.isNegative()) {\n                    if (divisor.isNegative()) return this.neg().div(divisor.neg());\n                    return this.neg()\n                        .div(divisor)\n                        .neg();\n                } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n                res = Long.ZERO;\n            } else {\n                // The algorithm below has not been made for unsigned longs. It's therefore\n                // required to take special care of the MSB prior to running it.\n                if (!divisor.unsigned) divisor = divisor.toUnsigned();\n                if (divisor.gt(this)) return Long.UZERO;\n                if (divisor.gt(this.shru(1)))\n                    // 15 >>> 1 = 7 ; with divisor = 8 ; true\n                    return Long.UONE;\n                res = Long.UZERO;\n            }\n\n            // Repeat the following until the remainder is less than other:  find a\n            // floating-point that approximates remainder / other *from below*, add this\n            // into the result, and subtract it from the remainder.  It is critical that\n            // the approximate value is less than or equal to the real value so that the\n            // remainder never becomes negative.\n            rem = this;\n            while (rem.gte(divisor)) {\n                // Approximate the result of division. This may be a little greater or\n                // smaller than the actual value.\n                approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n\n                // We will tweak the approximate result by changing it in the 48-th digit or\n                // the smallest non-fractional digit, whichever is larger.\n                let log2 = Math.ceil(Math.log(approx) / Math.LN2),\n                    delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48),\n                    // Decrease the approximation until it is smaller than the remainder.  Note\n                    // that if it is too large, the product overflows and is negative.\n                    approxRes = Long.fromNumber(approx),\n                    approxRem = approxRes.mul(divisor);\n                while (approxRem.isNegative() || approxRem.gt(rem)) {\n                    approx -= delta;\n                    approxRes = Long.fromNumber(approx, this.unsigned);\n                    approxRem = approxRes.mul(divisor);\n                }\n\n                // We know the answer can't be zero... and actually, zero would cause\n                // infinite recursion since we would make no progress.\n                if (approxRes.isZero()) approxRes = Long.ONE;\n\n                res = res.add(approxRes);\n                rem = rem.sub(approxRem);\n            }\n            return res;\n        }\n\n        /**\n         * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n         * @function\n         * @param {!Long|number|string} divisor Divisor\n         * @returns {!Long} Quotient\n         */\n        div = this.divide.bind(this);\n\n        /**\n         * Returns this Long modulo the specified.\n         * @this {!Long}\n         * @param {!Long|number|string} divisor Divisor\n         * @returns {!Long} Remainder\n         */\n        modulo(divisor: Long | number | string): Long {\n            if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);\n\n            // use wasm support if present\n            if (Long.wasm) {\n                const low = (this.unsigned ? Long.wasm[\"rem_u\"] : Long.wasm[\"rem_s\"])(\n                    this.low,\n                    this.high,\n                    divisor.low,\n                    divisor.high,\n                );\n                return Long.fromBits(low, Long.wasm[\"get_high\"](), this.unsigned);\n            }\n\n            return this.sub(this.div(divisor).mul(divisor));\n        }\n\n        /**\n         * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n         * @function\n         * @param {!Long|number|string} divisor Divisor\n         * @returns {!Long} Remainder\n         */\n        mod = this.modulo.bind(this);\n\n        /**\n         * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n         * @function\n         * @param {!Long|number|string} divisor Divisor\n         * @returns {!Long} Remainder\n         */\n        rem = this.modulo.bind(this);\n\n        /**\n         * Returns the bitwise NOT of this Long.\n         * @this {!Long}\n         * @returns {!Long}\n         */\n        not(): Long {\n            return Long.fromBits(~this.low, ~this.high, this.unsigned);\n        }\n\n        /**\n         * Returns the bitwise AND of this Long and the specified.\n         * @this {!Long}\n         * @param {!Long|number|string} other Other Long\n         * @returns {!Long}\n         */\n        and(other: Long | number | string): Long {\n            if (!Long.isLong(other)) other = Long.fromValue(other);\n            return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n        }\n\n        /**\n         * Returns the bitwise OR of this Long and the specified.\n         * @this {!Long}\n         * @param {!Long|number|string} other Other Long\n         * @returns {!Long}\n         */\n        or(other: Long | number | string): Long {\n            if (!Long.isLong(other)) other = Long.fromValue(other);\n            return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n        }\n\n        /**\n         * Returns the bitwise XOR of this Long and the given one.\n         * @this {!Long}\n         * @param {!Long|number|string} other Other Long\n         * @returns {!Long}\n         */\n        xor(other: Long | number | string): Long {\n            if (!Long.isLong(other)) other = Long.fromValue(other);\n            return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n        }\n\n        /**\n         * Returns this Long with bits shifted to the left by the given amount.\n         * @this {!Long}\n         * @param {number|!Long} numBits Number of bits\n         * @returns {!Long} Shifted Long\n         */\n        shiftLeft(numBits: number | Long): Long {\n            if (Long.isLong(numBits)) numBits = numBits.toInt();\n            if ((numBits &= 63) === 0) return this;\n            else if (numBits < 32)\n                return Long.fromBits(\n                    this.low << numBits,\n                    (this.high << numBits) | (this.low >>> (32 - numBits)),\n                    this.unsigned,\n                );\n            else return Long.fromBits(0, this.low << (numBits - 32), this.unsigned);\n        }\n\n        /**\n         * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n         * @function\n         * @param {number|!Long} numBits Number of bits\n         * @returns {!Long} Shifted Long\n         */\n        shl = this.shiftLeft.bind(this);\n\n        /**\n         * Returns this Long with bits arithmetically shifted to the right by the given amount.\n         * @this {!Long}\n         * @param {number|!Long} numBits Number of bits\n         * @returns {!Long} Shifted Long\n         */\n        shiftRight(numBits: number | Long): Long {\n            if (Long.isLong(numBits)) numBits = numBits.toInt();\n            if ((numBits &= 63) === 0) return this;\n            else if (numBits < 32)\n                return Long.fromBits(\n                    (this.low >>> numBits) | (this.high << (32 - numBits)),\n                    this.high >> numBits,\n                    this.unsigned,\n                );\n            else\n                return Long.fromBits(\n                    this.high >> (numBits - 32),\n                    this.high >= 0 ? 0 : -1,\n                    this.unsigned,\n                );\n        }\n\n        /**\n         * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n         * @function\n         * @param {number|!Long} numBits Number of bits\n         * @returns {!Long} Shifted Long\n         */\n        shr = this.shiftRight.bind(this);\n\n        /**\n         * Returns this Long with bits logically shifted to the right by the given amount.\n         * @this {!Long}\n         * @param {number|!Long} numBits Number of bits\n         * @returns {!Long} Shifted Long\n         */\n        shiftRightUnsigned(numBits: number | Long): Long {\n            if (Long.isLong(numBits)) numBits = numBits.toInt();\n            if ((numBits &= 63) === 0) return this;\n            if (numBits < 32)\n                return Long.fromBits(\n                    (this.low >>> numBits) | (this.high << (32 - numBits)),\n                    this.high >>> numBits,\n                    this.unsigned,\n                );\n            if (numBits === 32) return Long.fromBits(this.high, 0, this.unsigned);\n            return Long.fromBits(this.high >>> (numBits - 32), 0, this.unsigned);\n        }\n\n        /**\n         * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n         * @function\n         * @param {number|!Long} numBits Number of bits\n         * @returns {!Long} Shifted Long\n         */\n        shru = this.shiftRightUnsigned.bind(this);\n\n        /**\n         * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n         * @function\n         * @param {number|!Long} numBits Number of bits\n         * @returns {!Long} Shifted Long\n         */\n        shr_u = this.shiftRightUnsigned.bind(this);\n\n        /**\n         * Returns this Long with bits rotated to the left by the given amount.\n         * @this {!Long}\n         * @param {number|!Long} numBits Number of bits\n         * @returns {!Long} Rotated Long\n         */\n        rotateLeft(numBits: number | Long): Long {\n            let b;\n            if (Long.isLong(numBits)) numBits = numBits.toInt();\n            if ((numBits &= 63) === 0) return this;\n            if (numBits === 32) return Long.fromBits(this.high, this.low, this.unsigned);\n            if (numBits < 32) {\n                b = 32 - numBits;\n                return Long.fromBits(\n                    (this.low << numBits) | (this.high >>> b),\n                    (this.high << numBits) | (this.low >>> b),\n                    this.unsigned,\n                );\n            }\n            numBits -= 32;\n            b = 32 - numBits;\n            return Long.fromBits(\n                (this.high << numBits) | (this.low >>> b),\n                (this.low << numBits) | (this.high >>> b),\n                this.unsigned,\n            );\n        }\n        /**\n         * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n         * @function\n         * @param {number|!Long} numBits Number of bits\n         * @returns {!Long} Rotated Long\n         */\n        rotl = this.rotateLeft.bind(this);\n\n        /**\n         * Returns this Long with bits rotated to the right by the given amount.\n         * @this {!Long}\n         * @param {number|!Long} numBits Number of bits\n         * @returns {!Long} Rotated Long\n         */\n        rotateRight(numBits: number | Long): Long {\n            let b;\n            if (Long.isLong(numBits)) numBits = numBits.toInt();\n            if ((numBits &= 63) === 0) return this;\n            if (numBits === 32) return Long.fromBits(this.high, this.low, this.unsigned);\n            if (numBits < 32) {\n                b = 32 - numBits;\n                return Long.fromBits(\n                    (this.high << b) | (this.low >>> numBits),\n                    (this.low << b) | (this.high >>> numBits),\n                    this.unsigned,\n                );\n            }\n            numBits -= 32;\n            b = 32 - numBits;\n            return Long.fromBits(\n                (this.low << b) | (this.high >>> numBits),\n                (this.high << b) | (this.low >>> numBits),\n                this.unsigned,\n            );\n        }\n        /**\n         * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n         * @function\n         * @param {number|!Long} numBits Number of bits\n         * @returns {!Long} Rotated Long\n         */\n        rotr = this.rotateRight.bind(this);\n\n        /**\n         * Converts this Long to signed.\n         * @this {!Long}\n         * @returns {!Long} Signed long\n         */\n        toSigned(): Long {\n            if (!this.unsigned) return this;\n            return Long.fromBits(this.low, this.high, false);\n        }\n\n        /**\n         * Converts this Long to unsigned.\n         * @this {!Long}\n         * @returns {!Long} Unsigned long\n         */\n        toUnsigned(): Long {\n            if (this.unsigned) return this;\n            return Long.fromBits(this.low, this.high, true);\n        }\n\n        /**\n         * Converts this Long to its byte representation.\n         * @param {boolean=} le Whether little or big endian, defaults to big endian\n         * @this {!Long}\n         * @returns {!Array.<number>} Byte representation\n         */\n        toBytes(le?: boolean): Array<number> {\n            return le ? this.toBytesLE() : this.toBytesBE();\n        }\n\n        /**\n         * Converts this Long to its little endian byte representation.\n         * @this {!Long}\n         * @returns {!Array.<number>} Little endian byte representation\n         */\n        toBytesLE(): Array<number> {\n            const hi = this.high,\n                lo = this.low;\n            return [\n                lo & 0xff,\n                (lo >>> 8) & 0xff,\n                (lo >>> 16) & 0xff,\n                lo >>> 24,\n                hi & 0xff,\n                (hi >>> 8) & 0xff,\n                (hi >>> 16) & 0xff,\n                hi >>> 24,\n            ];\n        }\n\n        /**\n         * Converts this Long to its big endian byte representation.\n         * @this {!Long}\n         * @returns {!Array.<number>} Big endian byte representation\n         */\n        toBytesBE(): Array<number> {\n            const hi = this.high,\n                lo = this.low;\n            return [\n                hi >>> 24,\n                (hi >>> 16) & 0xff,\n                (hi >>> 8) & 0xff,\n                hi & 0xff,\n                lo >>> 24,\n                (lo >>> 16) & 0xff,\n                (lo >>> 8) & 0xff,\n                lo & 0xff,\n            ];\n        }\n\n        /**\n         * Creates a Long from its byte representation.\n         * @param {!Array.<number>} bytes Byte representation\n         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n         * @param {boolean=} le Whether little or big endian, defaults to big endian\n         * @returns {Long} The corresponding Long value\n         */\n        static fromBytes(bytes: ArrayLike<number>, unsigned?: boolean, le?: boolean): Long {\n            return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n        }\n\n        /**\n         * Creates a Long from its little endian byte representation.\n         * @param {!Array.<number>} bytes Little endian byte representation\n         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n         * @returns {Long} The corresponding Long value\n         */\n        static fromBytesLE(bytes: ArrayLike<number>, unsigned?: boolean): Long {\n            return new Long(\n                bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24),\n                bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24),\n                unsigned,\n            );\n        }\n\n        /**\n         * Creates a Long from its big endian byte representation.\n         * @param {!Array.<number>} bytes Big endian byte representation\n         * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n         * @returns {Long} The corresponding Long value\n         */\n        static fromBytesBE(bytes: ArrayLike<number>, unsigned?: boolean): Long {\n            return new Long(\n                (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7],\n                (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3],\n                unsigned,\n            );\n        }\n    }\n\n    Object.defineProperty(Long.prototype, \"__isLong__\", { value: true });\n\n    try {\n        Long.wasm = new WebAssembly.Instance(\n            new WebAssembly.Module(\n                new Uint8Array([\n                    0,\n                    97,\n                    115,\n                    109,\n                    1,\n                    0,\n                    0,\n                    0,\n                    1,\n                    13,\n                    2,\n                    96,\n                    0,\n                    1,\n                    127,\n                    96,\n                    4,\n                    127,\n                    127,\n                    127,\n                    127,\n                    1,\n                    127,\n                    3,\n                    7,\n                    6,\n                    0,\n                    1,\n                    1,\n                    1,\n                    1,\n                    1,\n                    6,\n                    6,\n                    1,\n                    127,\n                    1,\n                    65,\n                    0,\n                    11,\n                    7,\n                    50,\n                    6,\n                    3,\n                    109,\n                    117,\n                    108,\n                    0,\n                    1,\n                    5,\n                    100,\n                    105,\n                    118,\n                    95,\n                    115,\n                    0,\n                    2,\n                    5,\n                    100,\n                    105,\n                    118,\n                    95,\n                    117,\n                    0,\n                    3,\n                    5,\n                    114,\n                    101,\n                    109,\n                    95,\n                    115,\n                    0,\n                    4,\n                    5,\n                    114,\n                    101,\n                    109,\n                    95,\n                    117,\n                    0,\n                    5,\n                    8,\n                    103,\n                    101,\n                    116,\n                    95,\n                    104,\n                    105,\n                    103,\n                    104,\n                    0,\n                    0,\n                    10,\n                    191,\n                    1,\n                    6,\n                    4,\n                    0,\n                    35,\n                    0,\n                    11,\n                    36,\n                    1,\n                    1,\n                    126,\n                    32,\n                    0,\n                    173,\n                    32,\n                    1,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    32,\n                    2,\n                    173,\n                    32,\n                    3,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    126,\n                    34,\n                    4,\n                    66,\n                    32,\n                    135,\n                    167,\n                    36,\n                    0,\n                    32,\n                    4,\n                    167,\n                    11,\n                    36,\n                    1,\n                    1,\n                    126,\n                    32,\n                    0,\n                    173,\n                    32,\n                    1,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    32,\n                    2,\n                    173,\n                    32,\n                    3,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    127,\n                    34,\n                    4,\n                    66,\n                    32,\n                    135,\n                    167,\n                    36,\n                    0,\n                    32,\n                    4,\n                    167,\n                    11,\n                    36,\n                    1,\n                    1,\n                    126,\n                    32,\n                    0,\n                    173,\n                    32,\n                    1,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    32,\n                    2,\n                    173,\n                    32,\n                    3,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    128,\n                    34,\n                    4,\n                    66,\n                    32,\n                    135,\n                    167,\n                    36,\n                    0,\n                    32,\n                    4,\n                    167,\n                    11,\n                    36,\n                    1,\n                    1,\n                    126,\n                    32,\n                    0,\n                    173,\n                    32,\n                    1,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    32,\n                    2,\n                    173,\n                    32,\n                    3,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    129,\n                    34,\n                    4,\n                    66,\n                    32,\n                    135,\n                    167,\n                    36,\n                    0,\n                    32,\n                    4,\n                    167,\n                    11,\n                    36,\n                    1,\n                    1,\n                    126,\n                    32,\n                    0,\n                    173,\n                    32,\n                    1,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    32,\n                    2,\n                    173,\n                    32,\n                    3,\n                    173,\n                    66,\n                    32,\n                    134,\n                    132,\n                    130,\n                    34,\n                    4,\n                    66,\n                    32,\n                    135,\n                    167,\n                    36,\n                    0,\n                    32,\n                    4,\n                    167,\n                    11,\n                ]),\n            ),\n            {},\n        ).exports;\n    } catch (e) {\n        // no wasm support :(\n    }\n\n    // alias\n    type BigInt = Long;\n}\n","/// <reference path=\"../cClasses.ts\" />\n/// <reference path=\"../long.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export function fromString(qType, val): any {\n        return _.isString(val) && qType.fromString\n            ? // fromString used for some types (e.g., date, time, etc.)\n              qType.fromString(val)\n            : val;\n    }\n\n    export enum TypeNum {\n        List = 0,\n        Bool = 1,\n        Guid = 2,\n        Byte = 4,\n        Short = 5,\n        Int = 6,\n        Long = 7,\n        Float = 8,\n        Double = 9,\n        Char = 10,\n        Symbol = 11,\n        Timestamp = 12,\n        Month = 13,\n        Date = 14,\n        DateTime = 15,\n        Timespan = 16,\n        Minute = 17,\n        Second = 18,\n        Time = 19,\n        Table = 98,\n        Dict = 99,\n        Unary = 101,\n    }\n\n    export abstract class TypeBase {\n        public length: number;\n        public readonly qtype: TypeNum;\n        protected offset: number;\n        protected dataView: DataView;\n\n        constructor(length: number, offset: number, qtype: number, dataView: DataView) {\n            this.length = length;\n            this.offset = offset;\n            this.qtype = qtype;\n            this.dataView = dataView;\n        }\n\n        public isAligned(): boolean {\n            return true;\n        }\n\n        public isTemporal(): boolean {\n            return 12 >= this.qtype && this.qtype <= 19;\n        }\n\n        public toLegacy(i: number): any {\n            return this.getValue(i);\n        }\n\n        public toViewState(i): any {\n            return {\n                _type: Parse.TYPE_NAMES[Math.abs(this.qtype)],\n                value: Tools.convertKDBToViewstateValue(this.toLegacy(i)),\n            };\n        }\n\n        public abstract getValue(i: number): any;\n\n        public abstract mergeIndexed(arg: TypeBase);\n\n        public abstract mergeKeyedPrimary(\n            arg: TypeBase,\n            maxRows: number,\n            insertIndices: Array<number>,\n        ): number;\n\n        public abstract mergeKeyed(\n            arg: TypeBase,\n            indices: Array<number>,\n            indexOffset: number,\n            maxRows: number,\n        );\n    }\n}\n","/// <reference path=\"TypeBase.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export abstract class Vector extends TypeBase {\n        public readonly SIZE;\n        protected bufferLength;\n        protected values: Array<number>;\n        protected indexOffset = 0;\n\n        private index: number[] = null;\n        private rangeCache: Array<number | bigint | Long> | null = null;\n\n        protected constructor(\n            length: number,\n            offset: number,\n            qtype: number,\n            dataView: DataView,\n            size: number,\n        ) {\n            super(length, offset, qtype, dataView);\n            this.SIZE = size;\n            this.bufferLength = length;\n        }\n\n        public getRange(): Array<number | bigint | Long> {\n            return !this.index || this.index.length === 0\n                ? this.rangeCache || (this.rangeCache = this.calcRange())\n                : [this.hash(this.index[0]), this.hash(this.index[this.index.length - 1])];\n        }\n\n        public mergeIndexed(arg: Vector): void {\n            if (arg.length >= this.length) throw \"Invalid Merge Size\";\n\n            this.resetRangeCache();\n\n            // todo potentially transfer\n\n            // copy flat data on top of existing buffer\n            new Uint8Array(this.dataView.buffer, this.offset, arg.length * this.SIZE).set(\n                new Uint8Array(arg.dataView.buffer, arg.offset, arg.length * this.SIZE),\n            );\n        }\n\n        public checkIndex(): boolean {\n            for (let i = 1; i < this.index.length; i++) {\n                if (this.hash(this.index[i - 1]) > this.hash(this.index[i])) return true;\n            }\n\n            return false;\n        }\n\n        public hasIndex(): boolean {\n            return !!this.index;\n        }\n\n        public getIndexFromSortedIndex(i: number): number {\n            return (this.length + this.index[i] - this.indexOffset) % this.length;\n        }\n\n        public getScalarFromSortedIndex(i: number): number | bigint | Long {\n            i = (this.indexOffset + i) % this.length;\n            if (this.SIZE === 8 && Tools.isIE11 && [9, 15].indexOf(this.qtype) !== -1) {\n                return ((this as unknown) as I64).getLegacyScalar(this.index[i]);\n            } else return this.getScalar(this.index[i]);\n        }\n\n        public findIndex(value: number | bigint | Long): number {\n            let compareFn;\n            if (this.SIZE !== 8 || [9, 15].indexOf(this.qtype) !== -1) {\n                compareFn = (x: number, y): number => x - (this.hash(y) as number);\n            } else if (Tools.isIE11) {\n                compareFn = (x: Long, y): number => x.compare(this.hash(y) as Long);\n            } else {\n                compareFn = (x: bigint, y): number => Number(x - (this.hash(y) as bigint));\n            }\n\n            return Tools.binarySearch2(value, this.index, compareFn);\n        }\n\n        public mergeKeyedPrimary(\n            arg: Vector,\n            maxRows: number,\n            insertIndices: Array<number>,\n        ): number {\n            this.resetRangeCache();\n            if (!this.hasIndex()) {\n                this.generateIndex();\n            }\n            for (let i = 0; i < arg.length; i++) {\n                // get arg value and existing index\n                let indexIndex = this.findIndex(arg.hash(i));\n                // if a new item\n                if (indexIndex < 0) {\n                    let targetIndex;\n                    // if length exceeds max\n                    if (this.length === maxRows) {\n                        //debugger;\n                        // loop around using target index\n                        targetIndex = this.indexOffset % maxRows;\n                        //console.log(\"Remove: \" + this.getValue(targetIndex).toString())\n                        //console.log(\"Prior\", [0,1,2,3].map(i=>this.getValue(i).toString()))\n                        // remove old target index\n                        const targetIndexIndex = this.findIndex(this.hash(targetIndex));\n                        this.index.splice(targetIndexIndex, 1);\n                        // if(this.checkIndex()) {\n                        //     debugger;\n                        // }\n                        // if indexIndex is after target index, go back one\n                        if (-indexIndex - 1 > targetIndexIndex) {\n                            //debugger;\n                            indexIndex++;\n                        }\n                        // insert target in index\n                        this.index.splice(-indexIndex - 1, 0, targetIndex);\n                        // around we go\n                        this.indexOffset = (this.indexOffset + 1) % maxRows;\n                    } else {\n                        // add on the end\n                        targetIndex = this.length;\n                        if (targetIndex >= this.bufferLength) {\n                            this.reallocate(maxRows);\n                        }\n                        // update index\n                        this.index.splice(-indexIndex - 1, 0, targetIndex);\n                        this.length++;\n                    }\n                    // write value at targetIndex\n                    new Uint8Array(\n                        this.dataView.buffer,\n                        this.offset + targetIndex * this.SIZE,\n                        this.SIZE,\n                    ).set(\n                        new Uint8Array(arg.dataView.buffer, arg.offset + i * this.SIZE, this.SIZE),\n                    );\n                    //console.log(\"Add: \" + arg.getValue(i).toString())\n                    //console.log(\"After\", [0,1,2,3].map(i=>this.getValue(i).toString()))\n                    // if(this.checkIndex()) {\n                    //     debugger;\n                    // }\n                    insertIndices.push(targetIndex);\n                } else {\n                    const valueIndex = this.index[indexIndex];\n                    insertIndices.push(valueIndex);\n                }\n            }\n            //console.log(\"+\" + arg.length + \":\" + JSON.stringify(_.times(arg.length, i=>arg.getValue(i))));\n            //console.log(\"=\" + this.length +\"(\"+this.indexOffset+\"):\" + JSON.stringify(_.times(this.length, i=>this.getValue(i))));\n            return this.indexOffset;\n        }\n\n        public mergeKeyed(\n            arg: Vector,\n            indices: Array<number>,\n            indexOffset: number,\n            maxRows: number,\n        ): void {\n            this.resetRangeCache();\n            for (let i = 0; i < indices.length; i++) {\n                // get arg value and existing index\n                const targetIndex = indices[i];\n\n                if (targetIndex === this.length) {\n                    // re-allocate if necessary\n                    if (targetIndex >= this.bufferLength) {\n                        // TODO intelligently up buffer size not jump to max\n                        this.reallocate(maxRows);\n                    }\n\n                    // update length\n                    this.length++;\n                }\n\n                // write value at targetIndex\n                new Uint8Array(\n                    this.dataView.buffer,\n                    this.offset + targetIndex * this.SIZE,\n                    this.SIZE,\n                ).set(new Uint8Array(arg.dataView.buffer, arg.offset + i * this.SIZE, this.SIZE));\n            }\n\n            this.indexOffset = indexOffset;\n\n            //console.log(\"+\" + arg.length + \":\" + JSON.stringify(_.times(arg.length, i=>arg.getValue(i))));\n            //console.log(\"=\" + this.length +\"():\" + JSON.stringify(_.times(this.length, i=>this.getValue(i))));\n        }\n\n        public reallocate(extLength?: number): void {\n            this.bufferLength = extLength || this.bufferLength;\n            const buffer = new ArrayBuffer(this.bufferLength * this.SIZE);\n            new Uint8Array(buffer, 0, this.length * this.SIZE).set(\n                new Uint8Array(this.dataView.buffer, this.offset, this.length * this.SIZE),\n            );\n\n            this.dataView = new DataView(buffer);\n            this.offset = 0;\n        }\n\n        public toTypedArray():\n            | Uint8Array\n            | Int16Array\n            | Int32Array\n            | Float32Array\n            | Float64Array\n            | BigInt64Array {\n            this.align();\n\n            // TODO: really what we want to do is to return 2 typedarrays\n            let TA;\n            if (this.SIZE === 1) {\n                TA = Uint8Array;\n            } else if (this.SIZE === 2) {\n                TA = Int16Array;\n            } else if (this.SIZE === 4) {\n                TA = this.qtype === 8 ? Float32Array : Int32Array;\n            } else if (this.SIZE === 8) {\n                TA = [9, 15].indexOf(this.qtype) !== -1 ? Float64Array : BigInt64Array;\n            }\n\n            if (this.indexOffset === 0)\n                return new TA(this.dataView.buffer, this.offset, this.length);\n\n            const typedArray = new TA(this.length);\n\n            // copy indexOffset+ to start\n            typedArray.set(\n                new TA(\n                    this.dataView.buffer,\n                    this.indexOffset * this.SIZE,\n                    this.length - this.indexOffset,\n                ),\n            );\n\n            // copy indexOffset- to start\n            typedArray.set(\n                new TA(this.dataView.buffer, 0, this.indexOffset),\n                this.length - this.indexOffset,\n            );\n\n            return typedArray;\n        }\n\n        protected align(): void {\n            if (this.offset % this.SIZE !== 0) {\n                this.reallocate();\n            }\n        }\n\n        protected getByteLocation(i: number): number {\n            return this.offset + ((i + this.indexOffset) % this.length) * this.SIZE;\n        }\n\n        protected getHashLocation(i: number): number {\n            return this.offset + i * this.SIZE;\n        }\n\n        private generateIndex(): void {\n            this.index = new Array(this.length);\n            for (let i = 0; i < this.length; i++) {\n                this.index[i] = i;\n            }\n            // type appropriate sort\n            if (this.SIZE !== 8 || [9, 15].indexOf(this.qtype) !== -1) {\n                this.index.sort((a, b) => (this.hash(a) as number) - (this.hash(b) as number));\n            } else if (Tools.isIE11) {\n                this.index.sort((a, b) =>\n                    ((this.hash(a) as unknown) as Long).compare(this.hash(b) as Long),\n                );\n            } else {\n                this.index.sort((a, b) =>\n                    Number((this.hash(a) as bigint) - (this.hash(b) as bigint)),\n                );\n            }\n        }\n\n        private resetRangeCache(): void {\n            this.rangeCache = null;\n        }\n\n        public abstract calcRange(): Array<number | bigint | Long>;\n\n        public abstract getScalar(i: number): number | bigint;\n\n        public abstract hash(i: number): number | bigint | Long;\n    }\n}\n","/// <reference path=\"Vector.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export abstract class U8 extends Vector {\n        protected static readonly MIN = 0;\n        protected static readonly MAX = 255;\n\n        constructor(length: number, offset: number, qtype: number, dataView: DataView) {\n            super(length, offset, qtype, dataView, 1);\n        }\n\n        calcRange(): number[] {\n            let xMax = U8.MIN;\n            let xMin = U8.MAX;\n\n            for (let i = 0; i < this.length; i += 1) {\n                const x = this.getScalar(i);\n                if (x > xMax) {\n                    xMax = x;\n                }\n                if (x < xMin) {\n                    xMin = x;\n                }\n            }\n\n            return [xMin, xMax];\n        }\n\n        getScalar(i: number): number {\n            return this.dataView.getUint8(this.getByteLocation(i));\n        }\n\n        hash(i: number): number {\n            return this.dataView.getUint8(this.getHashLocation(i));\n        }\n    }\n}\n","/// <reference path=\"U8.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Boolean extends U8 {\n        static readonly TYPE_NUM = 1;\n\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Bool, dataView);\n        }\n\n        static listToIPC(values: Array<boolean>): Uint8Array {\n            const size = values.length + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(Boolean.TYPE_NUM); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => buffer.wb(v ? 1 : 0)); // values\n\n            return buffer.data;\n        }\n\n        static toIPC(value: boolean): Uint8Array {\n            const buffer = Util.createBuffer(2);\n            buffer.wb(256 - Boolean.TYPE_NUM); // type\n            buffer.wb(value ? 1 : 0); // value\n            return buffer.data;\n        }\n\n        getValue(i: number): boolean {\n            return this.getScalar(i) === 0x1;\n        }\n    }\n}\n","/// <reference path=\"U8.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Byte extends U8 {\n        static readonly TYPE_NUM = 4;\n\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Byte, dataView);\n        }\n\n        static listToIPC(values: Array<number>): Uint8Array {\n            const size = values.length + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(Byte.TYPE_NUM); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => buffer.wb(v)); // values\n\n            return buffer.data;\n        }\n\n        static toIPC(value: number): Uint8Array {\n            const buffer = Util.createBuffer(2);\n            buffer.wb(256 - Byte.TYPE_NUM); // type\n            buffer.wb(value || 0); // value\n            return buffer.data;\n        }\n\n        getValue(i: number): number {\n            return this.getScalar(i);\n        }\n    }\n}\n","/// <reference path=\"Vector.ts\" />\n/// <reference path=\"../long.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export abstract class I64 extends Vector {\n        static LONG_NULL = new QuickBase.Long(0x0, 0x80000000);\n        static LONG_INFINITY_NEGATIVE = new QuickBase.Long(0x00000001, 0x80000000);\n        static LONG_INFINITY_POSITIVE = QuickBase.Long.MAX_VALUE;\n\n        constructor(length: number, offset: number, qtype: number, dataView: DataView) {\n            super(length, offset, qtype, dataView, 8);\n        }\n\n        calcRange(): bigint[] | Long[] {\n            // @ts-ignore TS2304\n            if (typeof BigInt !== \"undefined\") {\n                let xMax = this.getScalar(0);\n                let xMin = xMax;\n                // @ts-ignore TS2304\n                const LONG_NULL = BigInt(\"-9223372036854775808\");\n                for (let i = 1; i < this.length; i++) {\n                    const x = this.getScalar(i);\n                    // @ts-ignore TS2304\n                    if (xMax === LONG_NULL || (x > xMax && x !== LONG_NULL)) {\n                        xMax = x;\n                    }\n                    // @ts-ignore TS2304\n                    if (xMin === LONG_NULL || (x < xMin && x !== LONG_NULL)) {\n                        xMin = x;\n                    }\n                }\n                return [xMin, xMax];\n            }\n            let xMax = this.getLegacyScalar(0);\n            let xMin = xMax;\n            const nullVal = I64.LONG_NULL;\n            for (let i = 1; i < this.length; i++) {\n                const x = this.getLegacyScalar(i);\n                if (xMax.eq(nullVal) || (x.gt(xMax) && !x.eq(nullVal))) {\n                    xMax = x;\n                }\n                if (xMin.eq(nullVal) || (x.lt(xMin) && !x.eq(nullVal))) {\n                    xMin = x;\n                }\n            }\n            return [xMin, xMax];\n        }\n\n        getLegacyScalar(i: number): Long {\n            const bb = new Uint8Array(this.dataView.buffer, this.getByteLocation(i), this.SIZE);\n            return Long.fromBytesLE(bb);\n        }\n\n        getScalar(i: number): bigint {\n            return this.dataView.getBigInt64(this.getByteLocation(i), true);\n        }\n\n        public hash(i: number): bigint | Long {\n            return this.dataView.getBigInt64(this.getHashLocation(i), true);\n        }\n    }\n\n    // IE11 specific function\n    if (Tools.isIE11) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        I64.prototype.hash = function(i: number) {\n            const bb = new Uint8Array(this.dataView.buffer, this.getHashLocation(i), this.SIZE);\n            return Long.fromBytesLE(bb);\n        };\n\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        I64.prototype.toTypedArray = function() {\n            this.align();\n            if (this.indexOffset === 0)\n                return new Uint8Array(this.dataView.buffer, this.offset, this.length * this.SIZE);\n\n            const typedArray = new Uint8Array(this.length * this.SIZE);\n\n            // copy indexOffset+ to start\n            typedArray.set(\n                new Uint8Array(\n                    this.dataView.buffer,\n                    this.indexOffset * this.SIZE,\n                    (this.length - this.indexOffset) * this.SIZE,\n                ),\n            );\n\n            // copy indexOffset- to start\n            typedArray.set(\n                new Uint8Array(this.dataView.buffer, 0, this.indexOffset * this.SIZE),\n                (this.length - this.indexOffset) * this.SIZE,\n            );\n\n            return typedArray;\n        };\n    }\n}\n","/// <reference path=\"I64.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Char extends U8 {\n        static readonly TYPE_NUM = 10;\n\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Char, dataView);\n        }\n\n        static listToIPC(values: Array<string>): Uint8Array {\n            const charData = values.map(v => u8u16(v && v.length ? v[0] : \" \"));\n\n            // eslint-disable-next-line prefer-spread\n            const merged = [].concat.apply([], charData);\n            const size = charData.length + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(Char.TYPE_NUM); // type\n            buffer.wb(0); // attributes\n            buffer.wi(merged.length); // vector size\n            _.each(merged, v => buffer.wb(v)); // values\n\n            return buffer.data;\n        }\n\n        static toIPC(value: string): Uint8Array {\n            const charData = u8u16(value && value.length ? value[0] : \" \");\n            const buffer = Util.createBuffer(1 + charData.length);\n            buffer.wb(256 - Char.TYPE_NUM); // type\n            charData.forEach(c => buffer.wb(c));\n            return buffer.data;\n        }\n\n        static u16u8(u8: ArrayLike<number>): string {\n            let u16 = \"\",\n                c,\n                c1,\n                c2;\n            for (let i = 0; i < u8.length; i++)\n                switch ((c = u8[i]) >> 4) {\n                    case 0:\n                    case 1:\n                    case 2:\n                    case 3:\n                    case 4:\n                    case 5:\n                    case 6:\n                    case 7:\n                        u16 += String.fromCharCode(c);\n                        break;\n                    case 12:\n                    case 13:\n                        c1 = u8[++i];\n                        u16 += String.fromCharCode(((c & 0x1f) << 6) | (c1 & 0x3f));\n                        break;\n                    case 14:\n                        c1 = u8[++i];\n                        c2 = u8[++i];\n                        u16 += String.fromCharCode(\n                            ((c & 0x0f) << 12) | ((c1 & 0x3f) << 6) | ((c2 & 0x3f) << 0),\n                        );\n                        break;\n                }\n            return u16;\n        }\n\n        getValue(i: number): string {\n            const c = this.getScalar(i);\n            return c === 0 ? \"\" : u16u8([c]);\n        }\n    }\n}\n","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export abstract class I32 extends Vector {\n        protected static readonly NULL = -2147483648;\n        protected static readonly INFINITY_NEGATIVE = -2147483647;\n        protected static readonly INFINITY_POSITIVE = 2147483647;\n\n        constructor(length: number, offset: number, qtype: number, dataView: DataView) {\n            super(length, offset, qtype, dataView, 4);\n        }\n\n        public calcRange(): number[] {\n            let xMax = Number.NEGATIVE_INFINITY;\n            let xMin = Number.POSITIVE_INFINITY;\n\n            for (let i = 0; i < this.length; i += 1) {\n                const x = this.getScalar(i);\n                if (xMax === I32.NULL || (x > xMax && x !== I32.NULL)) {\n                    xMax = x;\n                }\n                if (xMin === I32.NULL || (x < xMin && x !== I32.NULL)) {\n                    xMin = x;\n                }\n            }\n\n            return [xMin, xMax];\n        }\n\n        public getScalar(i: number): number {\n            return this.dataView.getInt32(this.getByteLocation(i), true);\n        }\n\n        public hash(i: number): number {\n            return this.dataView.getInt32(this.getHashLocation(i));\n        }\n    }\n}\n","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Constants {\n        public static readonly MSDAY = 86400000;\n        public static readonly QEPOCH = Constants.MSDAY * 10957;\n        public static readonly LONG_NULL = new QuickBase.Long(0x0, 0x80000000);\n        public static readonly LONG_INFINITY_NEGATIVE = new QuickBase.Long(0x00000001, 0x80000000);\n        public static readonly LONG_INFINITY_POSITIVE = QuickBase.Long.MAX_VALUE;\n        public static readonly JS_DATE_MIN = -8640000000000000;\n        public static readonly TIME_PARTS_RX = /(-?\\d{1,7}:\\d\\d:\\d\\d.\\d\\d\\d)(\\d\\d\\d\\d\\d\\d)/;\n        public static readonly BQEPOCH = new jsbn.BigInteger(\n            (Constants.QEPOCH * 1000000).toString(),\n        );\n    }\n}\n","/// <reference path=\"I32.ts\" />\n/// <reference path=\"Constants.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class QDate extends I32 {\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Date, dataView);\n        }\n\n        public static fromMoment(m: moment.Moment): rDateClass {\n            return m === null ? null : new rDateClass(m.valueOf());\n        }\n\n        public static fromScalar(value: number): rDateClass {\n            return value === null\n                ? null\n                : new rDateClass(Constants.QEPOCH + value * Constants.MSDAY);\n        }\n\n        public static fromString(str: string): rDateClass {\n            if (!str) return null;\n            str = str.replace(/\\./g, \"-\");\n            const m = moment.utc(str);\n            return QDate.fromMoment(m);\n        }\n\n        public static listToIPC(values: Array<rDateClass>): Uint8Array {\n            const size = values.length * 4 + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(TypeNum.Date); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => QDate.writeValue(v, buffer.wb)); // values\n\n            return buffer.data;\n        }\n\n        public static toIPC(value: rDateClass): Uint8Array {\n            const buffer = Util.createBuffer(5);\n\n            buffer.wb(256 - TypeNum.Date); // type\n            QDate.writeValue(value, buffer.wb); // value\n\n            return buffer.data;\n        }\n\n        public static writeValue(value: rDateClass, wb: (b: number) => void): void {\n            Int.writeValue(value === null ? null : QDate.toScalar(value), wb);\n        }\n\n        public static toMoment(value: rDateClass): moment.Moment {\n            return value === null ? null : moment.tz(value.toString(), \"UTC\");\n        }\n\n        public static toScalar(value: rDateClass): number {\n            return value === null ? null : (value.i - Constants.QEPOCH) / Constants.MSDAY;\n        }\n\n        public static toString(value: rDateClass, format = \"YYYY-MM-DD\"): string {\n            return value === null ? null : QDate.toMoment(value).format(format);\n        }\n\n        public getValue(i: number): number | rDateClass {\n            const s = super.getScalar(i);\n            return s === I32.NULL\n                ? null\n                : s === I32.INFINITY_NEGATIVE\n                ? -Infinity\n                : s === I32.INFINITY_POSITIVE\n                ? Infinity\n                : new rDateClass(Constants.QEPOCH + s * Constants.MSDAY);\n        }\n    }\n}\n","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export abstract class F64 extends Vector {\n        constructor(length: number, offset: number, qtype: number, dataView: DataView) {\n            super(length, offset, qtype, dataView, 8);\n        }\n\n        calcRange(): number[] {\n            let xMax = Number.NEGATIVE_INFINITY;\n            let xMin = Number.POSITIVE_INFINITY;\n\n            for (let i = 0; i < this.length; i += 1) {\n                const x = this.getScalar(i);\n                if (isNaN(xMax) || (x > xMax && !isNaN(x))) {\n                    xMax = x;\n                }\n                if (isNaN(xMin) || (x < xMin && !isNaN(x))) {\n                    xMin = x;\n                }\n            }\n\n            return [xMin, xMax];\n        }\n\n        getScalar(i: number): number {\n            return this.dataView.getFloat64(this.getByteLocation(i), true);\n        }\n\n        hash(i: number): number {\n            return this.dataView.getFloat64(this.getHashLocation(i), true);\n        }\n\n        toSplitTypedArray(): Float32Array {\n            this.align();\n            return new Float32Array(this.dataView.buffer, this.offset, this.length * 2);\n        }\n    }\n}\n","/// <reference path=\"F64.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class DateTime extends F64 {\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.DateTime, dataView);\n        }\n\n        static fromMoment(m: moment.Moment): rDateTimeClass {\n            return m === null ? null : new rDateTimeClass(m.valueOf());\n        }\n\n        static fromScalar(scalar: number): rDateTimeClass {\n            // F64's getScalar returns NaN when DateTime is null\n            return isNaN(scalar) || scalar === null\n                ? null\n                : new rDateTimeClass(Constants.QEPOCH + scalar * Constants.MSDAY);\n        }\n\n        static fromString(str: string): rDateTimeClass {\n            if (str === null) return null;\n            const dateMatch = str.match(/(.*)(D|T)(.*?)Z?$/);\n            if (!dateMatch) return null;\n            str = dateMatch[1].replace(/\\./g, \"-\") + \"T\" + dateMatch[3] + \"Z\";\n            const m = moment(str);\n            return DateTime.fromMoment(m);\n        }\n\n        static listToIPC(values: Array<rDateTimeClass>): Uint8Array {\n            const size = values.length * 8 + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(TypeNum.DateTime); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => DateTime.writeValue(v, buffer.wb)); // values\n\n            return buffer.data;\n        }\n\n        static toIPC(value: rDateTimeClass): Uint8Array {\n            const buffer = Util.createBuffer(9);\n\n            buffer.wb(256 - TypeNum.DateTime); // type\n            DateTime.writeValue(value, buffer.wb); // value\n\n            return buffer.data;\n        }\n\n        static toMoment(value: rDateTimeClass): moment.Moment {\n            if (value === null) return null;\n            const m = moment.tz(value.i, \"UTC\");\n            if (Tools.timezone && m.isValid()) m.tz(Tools.timezone);\n            return m;\n        }\n\n        static toScalar(value: rDateTimeClass): number {\n            return value === null ? null : (value.i - Constants.QEPOCH) / Constants.MSDAY;\n        }\n\n        static toString(value: rDateTimeClass, format?: string): string {\n            if (value === null) return \"\";\n            const m = DateTime.toMoment(value);\n            return format !== undefined ? m.format(format) : m.toISOString();\n        }\n\n        static writeValue(value: rDateTimeClass, wb: (b: number) => void): void {\n            Double.writeValue(DateTime.toScalar(value), wb);\n        }\n\n        getValue(i: number): rDateTimeClass | number {\n            return DateTime.fromScalar(this.getScalar(i));\n        }\n    }\n}\n","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Dict {\n        public length: number;\n        public qtype: number;\n        protected keys: TypeBase;\n        protected values: TypeBase;\n\n        constructor(length: number, keys: TypeBase, values: TypeBase, qtype?: number) {\n            this.length = length;\n            this.keys = keys;\n            this.values = values;\n            // qtype can be table(98) or dict(99)\n            this.qtype = qtype || TypeNum.Dict;\n        }\n\n        public static toIPC(keys: Array<string>, valueData: Uint8Array): Uint8Array {\n            const size = _.sumBy(keys, k => k.length + 1) + 7 + valueData.length;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(99); // type(99 - dict)\n            buffer.wb(11); // type(11 - symbol)\n            buffer.wb(0); // attributes\n            buffer.wi(keys.length); // vector size\n            _.each(keys, k => Symbol.writeValue(k, buffer.wb)); // values\n            _.each(valueData, d => buffer.wb(d));\n            return buffer.data;\n        }\n\n        public getKey(i: number): any {\n            return this.keys.getValue(i);\n        }\n\n        public getValue(i: number): any {\n            return this.values.getValue(i);\n        }\n\n        public toObject(): object {\n            const obj = {};\n            for (let i = 0; i < this.length; i++) {\n                obj[this.getKey(i)] = this.getValue(i);\n            }\n            return obj;\n        }\n\n        public toLegacy(): DCDS {\n            const t = new Table();\n            if (this.qtype === 99) {\n                t.addParsedColumn(\"Property\", this.keys);\n                t.addParsedColumn(\"Value\", this.values);\n            } else {\n                _.times(this.keys.length, i => {\n                    t.addParsedColumn(this.keys.toLegacy(i), this.values.getValue(i));\n                });\n            }\n            return t.toLegacy();\n        }\n\n        public toViewState() {\n            const ret = {};\n            for (let i = 0; i < this.length; i++) {\n                ret[this.getKey(i)] = this.values.toViewState(i);\n            }\n\n            return {\n                _type: \"dict\",\n                value: ret,\n            };\n        }\n    }\n\n    Dict.prototype.qtype = 99;\n}\n","/// <reference path=\"F64.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Double extends F64 {\n        static TYPE_NUM = 9;\n\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Double, dataView);\n        }\n\n        static listToIPC(values: Array<number>): Uint8Array {\n            const size = values.length * 8 + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(Double.TYPE_NUM); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => Double.writeValue(v, buffer.wb)); // values\n\n            return buffer.data;\n        }\n\n        static toIPC(value: number): Uint8Array {\n            const buffer = Util.createBuffer(9);\n            buffer.wb(256 - Double.TYPE_NUM); // type\n            Double.writeValue(value, buffer.wb); // value\n            return buffer.data;\n        }\n\n        static writeValue(value: number | null, wb: (b: number) => void): void {\n            if (value !== null) {\n                const fb = new Float64Array(1);\n                fb[0] = value;\n                _.each(new Uint8Array(fb.buffer), f => wb(f));\n            } else {\n                _.each([0, 0, 0, 0, 0, 0, 248, 255], l => wb(l));\n            }\n        }\n\n        getValue(i: number): number {\n            const val = this.getScalar(i);\n            return isNaN(val) ? null : val;\n        }\n    }\n}\n","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Float extends Vector {\n        static readonly TYPE_NUM = 8;\n\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Float, dataView, 4);\n        }\n\n        static listToIPC(values: Array<number>): Uint8Array {\n            const size = values.length * 4 + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(Float.TYPE_NUM); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => Float.writeValue(v, buffer.wb)); // values\n\n            return buffer.data;\n        }\n\n        static toIPC(value: number): Uint8Array {\n            const buffer = Util.createBuffer(5);\n            buffer.wb(256 - Float.TYPE_NUM); // type\n            Float.writeValue(value, buffer.wb); // value\n            return buffer.data;\n        }\n\n        static writeValue(value: number, wb: (b: number) => void): void {\n            if (value !== null) {\n                const fb = new Float32Array(1);\n                fb[0] = value;\n                _.each(new Uint8Array(fb.buffer), f => wb(f));\n            } else {\n                _.each([0, 0, 192, 255], l => wb(l));\n            }\n        }\n\n        calcRange(): number[] {\n            let xMax = Number.NEGATIVE_INFINITY;\n            let xMin = Number.POSITIVE_INFINITY;\n\n            for (let i = 0; i < this.length; i += 1) {\n                const x = this.getScalar(i);\n                if (isNaN(xMax) || (x > xMax && !isNaN(x))) {\n                    xMax = x;\n                }\n                if (isNaN(xMin) || (x < xMin && !isNaN(x))) {\n                    xMin = x;\n                }\n            }\n\n            return [xMin, xMax];\n        }\n\n        getScalar(i: number): number {\n            return this.dataView.getFloat32(this.getByteLocation(i), true);\n        }\n\n        getValue(i: number): number {\n            const val = this.getScalar(i);\n            return isNaN(val) ? null : val;\n        }\n\n        hash(i: number): number {\n            return this.dataView.getFloat32(this.getHashLocation(i), true);\n        }\n    }\n}\n","/// <reference path=\"I32.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Int extends I32 {\n        static readonly TYPE_NUM = 6;\n\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Int, dataView);\n        }\n\n        static listToIPC(values: Array<number>): Uint8Array {\n            const size = values.length * 4 + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(Int.TYPE_NUM); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => Int.writeValue(v, buffer.wb)); // values\n\n            return buffer.data;\n        }\n\n        static toIPC(value: number | null): Uint8Array {\n            const buffer = Util.createBuffer(5);\n            buffer.wb(256 - Int.TYPE_NUM); // type\n            Int.writeValue(value, buffer.wb); // value\n            return buffer.data;\n        }\n\n        static writeValue(value: number | null, wb: (b: number) => void): void {\n            if (value !== null) {\n                const ib = new Int32Array(1);\n                ib[0] = value;\n                _.each(new Uint8Array(ib.buffer), i => wb(i));\n            } else {\n                _.each([0, 0, 0, 128], i => wb(i));\n            }\n        }\n\n        getValue(i: number): number {\n            const val = this.getScalar(i);\n            return val === -2147483648\n                ? null\n                : val === -2147483647\n                ? -Infinity\n                : val === 2147483647\n                ? Infinity\n                : val;\n        }\n    }\n}\n","/*\n* Fastest md5 implementation around (JKM md5).\n* Credits: Joseph Myers\n*\n* @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n* @see http://jsperf.com/md5-shootout/7\n*/\n\n// typescript subset of JKM md5\n\nclass SparkMD5 {\n\n    private static hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {Uint8Array} arr The array buffer\n     * @param {Boolean}     [raw] True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    public static hash(uBuffer: Uint8Array) {\n        var hash = SparkMD5.md51_array(uBuffer),\n            ret = SparkMD5.hex(hash);\n\n        return ret;\n    }\n\n    private static rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += SparkMD5.hex_chr[(n >> (j * 8 + 4)) & 0x0F] + SparkMD5.hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    private static hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = SparkMD5.rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    private static md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b = (b << 21 | b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b = (b << 21 | b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b = (b << 21 | b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    private static md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    private static md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            SparkMD5.md5cycle(state, SparkMD5.md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            SparkMD5.md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        SparkMD5.md5cycle(state, tail);\n\n        return state;\n    }\n}\n","/// <reference path=\"TypeBase.ts\" />\n/// <reference path=\"../spark-md5.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class List extends TypeBase {\n        keyIndex?: { [index: string]: number };\n        values: Array<qTyped>;\n        end: number;\n        indexOffset = 0;\n\n        constructor(values: Array<qTyped>, end: number, dataView: DataView) {\n            super(values.length, undefined, 0, dataView);\n            this.end = end;\n            this.values = values;\n        }\n\n        static toIPC(values: Array<Uint8Array>): Uint8Array {\n            const size = _.sumBy(values, v => v.length) + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(0); // type(00 - list)\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => {\n                _.each(v, vb => buffer.wb(vb));\n            });\n\n            return buffer.data;\n        }\n\n        // if you are qTyped you are one of these\n        // qAtom qVector qGenericList qSymList qDict\n        getFirstOffset(i: number): number {\n            let qStruct = this.values[i];\n\n            if (qStruct.qtype === 98 || qStruct.qtype === 99) {\n                const d = qStruct as qDict;\n                qStruct =\n                    d.keys.qtype === 98 || d.keys.qtype === 99 ? (d.keys as qDict).keys : d.keys;\n            }\n\n            if (qStruct.qtype === 0) {\n                // is a generic list\n                const l = qStruct as qGenericList;\n                return new List(l.values, l.end, this.dataView).getFirstOffset(0);\n            } else if (qStruct.qtype === 11) {\n                // is a sym list\n                const sl = qStruct as qSymList;\n                return sl.offsets[0];\n            } else if (qStruct.qtype >= 0 && qStruct.qtype <= 19) {\n                // other\n                const bl = qStruct as qVector;\n                return bl.offset;\n            }\n\n            const qa = qStruct as qAtom;\n            return qa.offset;\n        }\n\n        // if you are qTyped you are one of these\n        // qAtom qVector qGenericList qSymList qDict\n        getEndOffset(i: number): number {\n            let qStruct = this.values[i];\n\n            if (qStruct.qtype === 98 || qStruct.qtype === 99) {\n                const d = qStruct as qDict;\n                qStruct =\n                    d.values.qtype === 98 || d.values.qtype === 99\n                        ? (d.values as qDict).values\n                        : d.values;\n            }\n\n            if (qStruct.qtype === 0) {\n                // is a generic list\n                const l = qStruct as qGenericList;\n                return l.end;\n            } else if (qStruct.qtype === 11) {\n                // is a sym list\n                const sl = qStruct as qSymList;\n                let end = sl.offsets[sl.offsets.length - 1];\n                while (this.dataView.getUint8(end++) !== 0);\n                return end;\n            } else if (qStruct.qtype === -11) {\n                const qa = qStruct as qAtom;\n                let end = qa.offset;\n                while (this.dataView.getUint8(end++) !== 0);\n                return end;\n            } else if (qStruct.qtype >= 0 && qStruct.qtype <= 19) {\n                // other\n                const bl = qStruct as qVector;\n                return bl.offset + getTypeSize(bl.qtype) * bl.length;\n            }\n\n            const qa = qStruct as qAtom;\n            return qa.offset + getTypeSize(Math.abs(qa.qtype));\n        }\n\n        //getEndOffset(i: number): number {\n        //    return (i < (this.values.length - 1)) ?\n        //        this.getFirstOffset(i+1) : this.end;\n        //}\n\n        getValue(i: number): any {\n            const qCol = this.values[i];\n            //return a dictionary when qCol is a qDict\n            if (qCol.qtype === 98 || qCol.qtype === 99) {\n                return Parse.table(qCol as qDict, this.dataView);\n            } else {\n                //otherwise return a column\n                return Parse.col(qCol as qVector, this.dataView);\n            }\n        }\n\n        isolate(i: number): string | number {\n            let col;\n            const start = this.getFirstOffset(i),\n                end = this.getEndOffset(i),\n                sz = end - start,\n                buffer = new ArrayBuffer(sz);\n\n            // copying value from original buffer into new buffer\n            const uBuffer = new Uint8Array(buffer, 0, sz);\n            uBuffer.set(new Uint8Array(this.dataView.buffer, start, sz));\n\n            this.offsetItem(i, -start);\n\n            if (this.values[i].qtype === 98 || this.values[i].qtype === 99) {\n                this.values[i] = Parse.table(this.values[i] as qDict, new DataView(buffer));\n\n                // hash buffer\n                return SparkMD5.hash(uBuffer);\n            } else {\n                this.values[i] = col = Parse.col(this.values[i] as qVector, new DataView(buffer));\n\n                // string - TODO do better\n                if (col.qtype === 10) {\n                    return this.toLegacy(i);\n                }\n\n                // hash single vector values and symbols\n                if (\n                    col.length === 1 &&\n                    col.qtype > -20 &&\n                    col.qtype < 20 &&\n                    col.qtype !== 0 &&\n                    col.qtype !== 11 &&\n                    col.qtype !== -11\n                ) {\n                    debugger;\n                    const vec0 = (col as Vector).hash(0);\n                    return Long.isLong(vec0) ? vec0.toString() : (vec0 as number);\n                }\n\n                // hash buffer\n                return SparkMD5.hash(uBuffer);\n            }\n        }\n\n        offsetItem(i: number, offset: number): void {\n            let qStruct = this.values[i];\n            let dValues;\n\n            // TODO: this will be more complicated\n            if (qStruct.qtype === 98 || qStruct.qtype === 99) {\n                const d = qStruct as qDict;\n                qStruct =\n                    d.keys.qtype === 98 || d.keys.qtype === 99 ? (d.keys as qDict).keys : d.keys;\n                dValues =\n                    d.values.qtype === 98 || d.values.qtype === 99\n                        ? (d.values as qDict).values\n                        : d.values;\n\n                this.offsetQTyped(i, offset, dValues);\n            }\n\n            this.offsetQTyped(i, offset, qStruct);\n        }\n\n        offsetQTyped(i: number, offset: number, qStruct: qTyped): void {\n            if (qStruct.qtype === 0) {\n                // is a generic list\n                const l = qStruct as qGenericList;\n                const cl = new List(l.values, l.end, this.dataView);\n                for (let i = 0; i < cl.length; i++) cl.offsetItem(i, offset);\n            } else if (qStruct.qtype === 11) {\n                // is a sym list\n                const sl = qStruct as qSymList;\n                for (let i = 0; i < sl.offsets.length; i++) sl.offsets[i] += offset;\n            } else {\n                // could be atom or vector\n                (qStruct as qAtom).offset += offset;\n            }\n        }\n\n        public mergeIndexed(arg: List): void {\n            if (arg.length >= this.length) throw \"Invalid Merge Size\";\n\n            if (arg.length === 0) return;\n\n            // calculate end of arg data\n            const argOffsetStart = arg.getFirstOffset(0);\n            const argOffsetEnd = arg.end;\n\n            // calculate arg size\n            const argSize = argOffsetEnd - argOffsetStart;\n\n            // calculate new buffer size\n            const thisFirstOriginal = this.getFirstOffset(arg.values.length);\n\n            // calculate original size\n            const thisOriginalSize = this.end - thisFirstOriginal;\n\n            // calculate new totalSize\n            const totalSize = argSize + thisOriginalSize;\n\n            // TODO: new buffer creation isn't always necessary\n            // could track buffer size and copy only when necessary.\n            // store thisOffsetEnd - offset in tmpBufferSize\n\n            // create a new buffer\n            const buffer = new ArrayBuffer(totalSize);\n\n            // copy in arg data\n            new Uint8Array(buffer, 0, argSize).set(\n                new Uint8Array(arg.dataView.buffer, argOffsetStart, argSize),\n            );\n\n            // copy in original data\n            new Uint8Array(buffer, argSize, thisOriginalSize).set(\n                new Uint8Array(this.dataView.buffer, thisFirstOriginal, thisOriginalSize),\n            );\n\n            // update offset\n            for (let i = 0; i < arg.length; i++) {\n                // update each qTyped offset by -argOffsetStart to align to 0\n                this.values[i] = arg.values[i];\n                this.offsetItem(i, -argOffsetStart);\n            }\n\n            // align to zero - correcting for any move of orginal data\n            const orginalMove = argSize - thisFirstOriginal;\n            for (let i = arg.length; i < this.length; i++) this.offsetItem(i, orginalMove);\n            this.end += orginalMove;\n            //this.offset = 0;\n\n            // use new databuffer\n            this.dataView = new DataView(buffer);\n        }\n\n        public mergeKeyedPrimary(arg: List, maxRows: number, insertIndices: Array<number>): number {\n            // convert to indexed\n            if (this.keyIndex === undefined) {\n                const keyIndex = {};\n                for (let i = 0; i < this.length; i++) {\n                    const hash = this.isolate(i);\n                    keyIndex[hash] = i;\n                }\n\n                // assign keyIndex\n                this.keyIndex = keyIndex;\n\n                // free buffer;\n                delete this.dataView;\n\n                // override getValue\n                // eslint-disable-next-line @typescript-eslint/unbound-method\n                this.getValue = (i): TypeBase | qTyped | Dict =>\n                    this.values[(i + this.indexOffset) % this.length];\n            }\n\n            for (let i = 0; i < arg.length; i++) {\n                // get arg value and existing index\n                const argHash = arg.isolate(i);\n                const argValue = arg.values[i];\n                const valueIndex = this.keyIndex[argHash];\n\n                // if a new item\n                if (valueIndex === undefined) {\n                    // if length exceeds max\n                    if (this.length === maxRows) {\n                        // loop around using target index\n                        const targetIndex = this.indexOffset % maxRows;\n                        this.keyIndex[argHash] = targetIndex;\n                        this.values[targetIndex] = argValue;\n                        insertIndices.push(targetIndex);\n                        this.indexOffset++;\n                    } else {\n                        // add value\n                        this.keyIndex[argHash] = this.length;\n                        insertIndices.push(this.length);\n                        this.values.push(argValue);\n                        this.length++;\n                    }\n                } else {\n                    insertIndices.push(valueIndex);\n                }\n            }\n\n            //console.log(\"+\" + arg.length + \":\" + JSON.stringify(_.times(arg.length, i=>arg.getValue(i))));\n            //console.log(\"=\" + this.length +\"(\"+this.indexOffset+\"):\" + JSON.stringify(_.times(this.length, i=>this.getValue(i))));\n            return this.indexOffset;\n        }\n\n        public mergeKeyed(\n            arg: List,\n            indices: Array<number>,\n            indexOffset: number,\n            maxRows: number,\n        ): void {\n            // convert to indexed\n            if (this.values === undefined) {\n                const values = [];\n                for (let i = 0; i < this.length; i++) {\n                    const str = this.getValue(i);\n                    values.push(str);\n                }\n\n                // assign keyIndex and values\n                this.values = values;\n\n                // free buffer and offsets;\n                delete this.dataView;\n\n                // eslint-disable-next-line @typescript-eslint/unbound-method\n                this.getValue = (i): TypeBase | qTyped | Dict =>\n                    this.values[(i + this.indexOffset) % this.length];\n            }\n\n            for (let i = 0; i < indices.length; i++) {\n                // get arg value and existing index\n                const argValue = arg.getValue(i);\n                const targetIndex = indices[i];\n\n                if (targetIndex === this.length) {\n                    this.values.push(argValue);\n                    this.length++;\n                } else if (targetIndex > this.length) {\n                    debugger;\n                } else this.values[targetIndex] = argValue;\n            }\n\n            this.indexOffset = indexOffset;\n        }\n\n        toLegacy(i: number): any {\n            const qCol = this.values[i];\n            const dataView = this.dataView;\n\n            if (qCol.qtype === 10) {\n                // string / char list\n                const bl = qCol as qVector;\n                const s = [];\n                for (i = 0; i < bl.length; i++) s.push(dataView.getUint8(bl.offset + i));\n                return Char.u16u8(s);\n            } else if (-20 < qCol.qtype && qCol.qtype < 0) {\n                // atoms\n                return Parse.col(qCol as qVector, dataView).toLegacy(0);\n            } else if (0 <= qCol.qtype && qCol.qtype < 20) {\n                // lists\n                const col = Parse.col(qCol as qVector, dataView) as Vector;\n                return _.times(col.length).map(i => col.toLegacy(i));\n            } else if (qCol.qtype === 98 || qCol.qtype === 99) {\n                // table\n                return Parse.table(qCol as qDict, dataView).toLegacy();\n            } else if (qCol.qtype === 101) {\n                return null;\n            }\n        }\n\n        public toViewState(i) {\n            const qCol = this.values[i];\n            return qCol.qtype === 99 || qCol.qtype === 98\n                ? Parse.table(qCol as qDict, this.dataView).toViewState()\n                : {\n                      _type: qCol.qtype === 10 ? \"string\" : Parse.TYPE_NAMES[Math.abs(qCol.qtype)],\n                      value: Tools.convertKDBToViewstateValue(this.toLegacy(i)),\n                  };\n        }\n    }\n}\n","/// <reference path=\"I64.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class QLong extends I64 {\n        static readonly TYPE_NUM = 7;\n\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Long, dataView);\n        }\n\n        static listToIPC(values: Array<string>): Uint8Array {\n            const size = values.length * 8 + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(QLong.TYPE_NUM); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => QLong.writeValue(v, buffer.wb)); // values\n\n            return buffer.data;\n        }\n\n        static toIPC(value: string): Uint8Array {\n            const buffer = Util.createBuffer(9);\n            buffer.wb(256 - QLong.TYPE_NUM); // type\n            QLong.writeValue(value, buffer.wb); // value\n            return buffer.data;\n        }\n\n        static writeValue(value: string, wb: (b: number) => void): void {\n            if (value !== null) {\n                const long = Long.fromString(\"\" + value);\n                _.each(long.toBytesLE(), l => wb(l));\n            } else {\n                _.each([0, 0, 0, 0, 0, 0, 0, 128], l => wb(l));\n            }\n        }\n\n        getValue(i: number): string | number {\n            const l = this.getLegacyScalar(i);\n            if (l.equals(I64.LONG_INFINITY_NEGATIVE)) {\n                return -Infinity;\n            } else if (l.equals(I64.LONG_INFINITY_POSITIVE)) {\n                return Infinity;\n            }\n            return l.equals(I64.LONG_NULL) ? null : l.toString();\n        }\n    }\n}\n","/// <reference path=\"I32.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Minute extends I32 {\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Minute, dataView);\n        }\n\n        public static fromMoment(m: moment.Duration): rMinuteClass {\n            return Minute.fromScalar(m.asMinutes());\n        }\n\n        public static fromScalar(s: number): rMinuteClass {\n            return s === null ? null : new rMinuteClass(s);\n        }\n\n        public static fromString(str: string): rMinuteClass {\n            str = str.replace(\"1970-01-01T\", \"\").replace(\"Z\", \"\");\n            const timeParts = str.match(Constants.TIME_PARTS_RX);\n            const m = moment.duration(timeParts && timeParts[1] ? timeParts[1] : str);\n            return Minute.fromMoment(m);\n        }\n\n        public static listToIPC(values: Array<rMinuteClass>): Uint8Array {\n            const size = values.length * 4 + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(TypeNum.Minute); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => Minute.writeValue(v, buffer.wb)); // values\n\n            return buffer.data;\n        }\n\n        public static toMoment(value: rMinuteClass): moment.Duration {\n            return value === null ? null : moment.duration(value.i * 60 * 1000);\n        }\n\n        public static toScalar(value: rMinuteClass): number {\n            return value === null ? null : value.i;\n        }\n\n        public static toString(\n            value: rMinuteClass,\n            format = \"HH:mm:ss.SSS\",\n            options = { trim: false },\n        ): string {\n            return value === null ? \"\" : Minute.toMoment(value).format(format, options);\n        }\n\n        public static toIPC(value: rMinuteClass): Uint8Array {\n            const buffer = Util.createBuffer(5);\n\n            buffer.wb(256 - TypeNum.Minute); // type\n            Minute.writeValue(value, buffer.wb); // value\n\n            return buffer.data;\n        }\n\n        private static writeValue(value: rMinuteClass, wb: (b: number) => void): void {\n            Int.writeValue(Minute.toScalar(value), wb);\n        }\n\n        public getValue(i: number): rMinuteClass {\n            const s = super.getScalar(i);\n            return s === I32.NULL ? null : new rMinuteClass(s);\n        }\n    }\n}\n","/// <reference path=\"I32.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Month extends I32 {\n        static readonly TYPE_NUM = 13;\n\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Month, dataView);\n        }\n\n        public static fromMoment(m: moment.Moment): rMonthClass {\n            // i is the number of months since 2000-01\n            return m === null\n                ? null\n                : new rMonthClass(Math.round(m.diff(moment([2000]), \"months\", true)));\n        }\n\n        public static fromScalar(value: number): rMonthClass {\n            return value === null ? null : new rMonthClass(value);\n        }\n\n        public static fromString(str: string): rMonthClass {\n            if (str === null) return null;\n            str = str.replace(/\\./g, \"-\").replace(/m$/, \"\");\n            const m = moment.utc(str);\n            return Month.fromMoment(m);\n        }\n\n        public static listToIPC(values: Array<rMonthClass>): Uint8Array {\n            const size = values.length * 4 + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(Month.TYPE_NUM); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => Month.writeValue(v, buffer.wb)); // values\n\n            return buffer.data;\n        }\n\n        public static toIPC(value: rMonthClass): Uint8Array {\n            const buffer = Util.createBuffer(5);\n\n            buffer.wb(256 - Month.TYPE_NUM); // type\n            Month.writeValue(value, buffer.wb); // value\n\n            return buffer.data;\n        }\n\n        public static toMoment(value: rMonthClass): moment.Moment {\n            if (value === null) return null;\n            const m = moment.tz(\"2000-01-01\", \"UTC\");\n            m.add(value.i, \"month\");\n            return m;\n        }\n\n        public static toScalar(value: rMonthClass): number {\n            return value === null ? null : value.i;\n        }\n\n        public static toString(value: rMonthClass, format = \"YYYY-MM\"): string {\n            return value === null ? \"\" : Month.toMoment(value).format(format);\n        }\n\n        public static writeValue(value: rMonthClass, wb: (b: number) => void): void {\n            Int.writeValue(Month.toScalar(value), wb);\n        }\n\n        getValue(i: number): number | rMonthClass {\n            const s = super.getScalar(i);\n            return s === I32.NULL ? null : new rMonthClass(s);\n        }\n    }\n}\n","/// <reference path=\"I32.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Second extends I32 {\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Second, dataView);\n        }\n\n        public static fromMoment(m: moment.Duration): rSecondClass {\n            return m === null ? null : new rSecondClass(m.asSeconds());\n        }\n\n        public static fromScalar(value: number): rSecondClass {\n            return value === null ? null : new rSecondClass(value);\n        }\n\n        public static fromString(str: string): rSecondClass {\n            str = str.replace(\"1970-01-01T\", \"\").replace(\"Z\", \"\");\n            const timeParts = str.match(Constants.TIME_PARTS_RX);\n            const m = moment.duration(timeParts && timeParts[1] ? timeParts[1] : str);\n            return Second.fromMoment(m);\n        }\n\n        public static listToIPC(values: Array<rSecondClass>): Uint8Array {\n            const size = values.length * 4 + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(TypeNum.Second); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => Second.writeValue(v, buffer.wb)); // values\n\n            return buffer.data;\n        }\n\n        public static toIPC(value: rSecondClass): Uint8Array {\n            const buffer = Util.createBuffer(5);\n\n            buffer.wb(256 - TypeNum.Second); // type\n            Second.writeValue(value, buffer.wb); // value\n\n            return buffer.data;\n        }\n\n        public static toMoment(value: rSecondClass): moment.Duration {\n            return value === null ? null : moment.duration(value.i * 1000);\n        }\n\n        public static toScalar(value: rSecondClass): number {\n            return value === null ? null : value.i;\n        }\n\n        public static toString(\n            value: rSecondClass,\n            format = \"HH:mm:ss.SSS\",\n            options = { trim: false },\n        ): string {\n            return value === null ? \"\" : Second.toMoment(value).format(format, options);\n        }\n\n        private static writeValue(value: rSecondClass, wb: (b: number) => void): void {\n            Int.writeValue(Second.toScalar(value), wb);\n        }\n\n        public getValue(i: number): rSecondClass {\n            const s = super.getScalar(i);\n            return s === I32.NULL ? null : new rSecondClass(s);\n        }\n    }\n}\n","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Short extends Vector {\n        static readonly TYPE_NUM = 5;\n        static readonly SHORT_NULL = -32768;\n\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Short, dataView, 2);\n        }\n\n        static listToIPC(values: Array<number>): Uint8Array {\n            const size = values.length * 2 + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(Short.TYPE_NUM); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => Short.writeValue(v, buffer.wb)); // values\n\n            return buffer.data;\n        }\n\n        static toIPC(value: number): Uint8Array {\n            const buffer = Util.createBuffer(3);\n            buffer.wb(256 - Short.TYPE_NUM); // type\n            Short.writeValue(value, buffer.wb); // value\n            return buffer.data;\n        }\n\n        static writeValue(value: number, wb: (b: number) => void): void {\n            if (value !== null) {\n                const ib = new Int16Array(1);\n                ib[0] = value;\n                _.each(new Uint8Array(ib.buffer), i => wb(i));\n            } else {\n                _.each([0, 128], i => wb(i));\n            }\n        }\n\n        public getValue(i: number): number {\n            const val = this.getScalar(i);\n            return val === -32768\n                ? null\n                : val === -32767\n                ? -Infinity\n                : val === 32767\n                ? Infinity\n                : val;\n        }\n\n        public calcRange(): number[] {\n            let xMax = Number.NEGATIVE_INFINITY;\n            let xMin = Number.POSITIVE_INFINITY;\n\n            for (let i = 0; i < this.length; i += 1) {\n                const x = this.getScalar(i);\n                if (xMax === Short.SHORT_NULL || (x > xMax && x !== Short.SHORT_NULL)) {\n                    xMax = x;\n                }\n                if (xMin === Short.SHORT_NULL || (x < xMin && x !== Short.SHORT_NULL)) {\n                    xMin = x;\n                }\n            }\n\n            return [xMin, xMax];\n        }\n\n        public getScalar(i): number {\n            return this.dataView.getInt16(this.getByteLocation(i), true);\n        }\n\n        public hash(i: number): number {\n            return this.dataView.getInt16(this.getHashLocation(i));\n        }\n    }\n}\n","/// <reference path=\"TypeBase.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Symbol extends TypeBase {\n        offsets: Array<number>;\n\n        // keyed data\n        keyIndex?: { [index: string]: number };\n        values?: Array<string>;\n        indexOffset = 0;\n\n        constructor(length: number, offsets: Array<number>, dataView: DataView) {\n            super(length, length ? offsets[0] : undefined, TypeNum.Symbol, dataView);\n            this.offsets = offsets;\n        }\n\n        static listToIPC(values: Array<string>): Uint8Array {\n            const size = _.sumBy(values, v => v.length + 1) + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(11); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => Symbol.writeValue(v, buffer.wb)); // values\n\n            return buffer.data;\n        }\n\n        static toIPC(value?: string): Uint8Array {\n            const size = value ? value.length + 2 : 2;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(256 - 11); // type\n            if (value !== null || value !== undefined) {\n                Symbol.writeValue(value, buffer.wb); // value\n            }\n\n            return buffer.data;\n        }\n\n        static writeValue(value: string, wb: (b: number) => void): void {\n            if (value !== null && value !== undefined) {\n                _.each(\"\" + value, v => wb(v.charCodeAt(0)));\n            }\n\n            wb(0); // null terminated\n        }\n\n        getValue(i: number): string {\n            if (this.values) {\n                return this.values[(i + this.indexOffset) % this.length];\n            } else {\n                let c,\n                    pos = this.offsets[(i + this.indexOffset) % this.length];\n                const s = [];\n                while ((c = this.dataView.getUint8(pos++)) !== 0) s.push(c);\n                return u16u8(s);\n            }\n        }\n\n        hash(i: number): string {\n            return this.getValue(i);\n        }\n\n        public mergeIndexed(arg: ipc.Symbol): void {\n            if (arg.length >= this.length) throw \"Invalid Merge Size\";\n\n            // todo potentially transfer\n\n            if (arg.offset === null) return;\n\n            // calculate end of arg data\n            let argOffsetEnd = _.last(arg.offsets);\n            while (arg.dataView.getUint8(argOffsetEnd++) !== 0);\n\n            // calculate arg size\n            const argSize = argOffsetEnd - arg.offset;\n\n            // calculate new buffer size\n            const thisFirstOriginal = this.offsets[arg.length];\n\n            // calculate end of this data\n            let thisOffsetEnd = _.last(this.offsets);\n            while (this.dataView.getUint8(thisOffsetEnd++) !== 0);\n\n            // calculate original size\n            const thisOriginalSize = thisOffsetEnd - thisFirstOriginal;\n\n            // calculate new totalSize\n            const totalSize = argSize + thisOriginalSize;\n\n            // TODO: new buffer creation isn't always necessary\n            // could track buffer size and copy only when necessary.\n            // store thisOffsetEnd - offset in tmpBufferSize\n\n            // create a new buffer\n            const buffer = new ArrayBuffer(totalSize);\n\n            // copy in arg data\n            new Uint8Array(buffer, 0, argSize).set(\n                new Uint8Array(arg.dataView.buffer, arg.offset, argSize),\n            );\n\n            // copy in original data\n            new Uint8Array(buffer, argSize, thisOriginalSize).set(\n                new Uint8Array(this.dataView.buffer, thisFirstOriginal, thisOriginalSize),\n            );\n\n            // update offset\n            for (let i = 0; i < arg.length; i++) this.offsets[i] = arg.offsets[i] - arg.offset; // align to zero\n\n            // align to zero - correcting for any move of orginal data\n            const orginalMove = argSize - thisFirstOriginal;\n            for (let i = arg.length; i < this.length; i++)\n                this.offsets[i] = this.offsets[i] + orginalMove;\n\n            this.offset = 0;\n\n            // use new databuffer\n            this.dataView = new DataView(buffer);\n        }\n\n        public mergeKeyedPrimary(\n            arg: ipc.Symbol,\n            maxRows: number,\n            insertIndices: Array<number>,\n        ): number {\n            // convert to indexed\n            if (this.keyIndex === undefined) {\n                const keyIndex = {};\n                const values = [];\n                for (let i = 0; i < this.length; i++) {\n                    const value = this.getValue(i);\n                    keyIndex[value] = i;\n                    values.push(value);\n                }\n\n                // assign keyIndex and values\n                this.keyIndex = keyIndex;\n                this.values = values;\n\n                // free buffer and offsets;\n                delete this.offsets;\n                delete this.dataView;\n            }\n\n            for (let i = 0; i < arg.length; i++) {\n                // get arg value and existing index\n                const argValue = arg.getValue(i);\n                const valueIndex = this.keyIndex[argValue];\n\n                // if a new item\n                if (valueIndex === undefined) {\n                    // if length exceeds max\n                    if (this.length === maxRows) {\n                        // loop around using target index\n                        const targetIndex = this.indexOffset % maxRows;\n                        this.keyIndex[argValue] = targetIndex;\n                        this.values[targetIndex] = argValue;\n                        insertIndices.push(targetIndex);\n                        this.indexOffset++;\n                    } else {\n                        // add value\n                        this.keyIndex[argValue] = this.length;\n                        insertIndices.push(this.length);\n                        this.values.push(argValue);\n                        this.length++;\n                    }\n                } else {\n                    insertIndices.push(valueIndex);\n                }\n            }\n\n            //console.log(\"+\" + arg.length + \":\" + JSON.stringify(_.times(arg.length, i=>arg.getValue(i))));\n            //console.log(\"=\" + this.length +\"(\"+this.indexOffset+\"):\" + JSON.stringify(_.times(this.length, i=>this.getValue(i))));\n            return this.indexOffset;\n        }\n\n        public mergeKeyed(\n            arg: ipc.Symbol,\n            indices: Array<number>,\n            indexOffset: number,\n            maxRows: number,\n        ): void {\n            // convert to indexed\n            if (this.values === undefined) {\n                const values = [];\n                for (let i = 0; i < this.length; i++) {\n                    const str = this.getValue(i);\n                    values.push(str);\n                }\n\n                // assign keyIndex and values\n                this.values = values;\n\n                // free buffer and offsets;\n                delete this.offsets;\n                delete this.dataView;\n            }\n\n            for (let i = 0; i < indices.length; i++) {\n                // get arg value and existing index\n                const argValue = arg.getValue(i);\n                const targetIndex = indices[i];\n\n                if (targetIndex === this.length) {\n                    this.values.push(argValue);\n                    this.length++;\n                } else if (targetIndex > this.length) {\n                    debugger;\n                } else this.values[targetIndex] = argValue;\n            }\n\n            this.indexOffset = indexOffset;\n        }\n    }\n}\n","/// <reference path=\"Util.ts\" />\n/// <reference path=\"Symbol.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class QString {\n        static TYPE_NUM = 10;\n\n        static u8u16(u16: string): Array<number> {\n            const u8 = [];\n            for (let i = 0; i < u16.length; i++) {\n                let c = u16.charCodeAt(i);\n                if (c < 0x80) u8.push(c);\n                else if (c < 0x800) u8.push(0xc0 | (c >> 6), 0x80 | (c & 0x3f));\n                else if (c < 0xd800 || c >= 0xe000)\n                    u8.push(0xe0 | (c >> 12), 0x80 | ((c >> 6) & 0x3f), 0x80 | (c & 0x3f));\n                else {\n                    c = 0x10000 + (((c & 0x3ff) << 10) | (u16.charCodeAt(++i) & 0x3ff));\n                    u8.push(\n                        0xf0 | (c >> 18),\n                        0x80 | ((c >> 12) & 0x3f),\n                        0x80 | ((c >> 6) & 0x3f),\n                        0x80 | (c & 0x3f),\n                    );\n                }\n            }\n            return u8;\n        }\n\n        static listToIPC(values: Array<string>): Uint8Array {\n            return List.toIPC(values.map(v => QString.toIPC(v)));\n        }\n\n        static toIPC(value: string): Uint8Array {\n            const valEn = value ? QString.u8u16(value) : [];\n            const size = valEn.length + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(QString.TYPE_NUM); // type\n            buffer.wb(0); // attributes\n            buffer.wi(valEn.length); // vector size\n            _.each(valEn, v => buffer.wb(v)); // values\n\n            return buffer.data;\n        }\n    }\n}\n","/// <reference path=\"I32.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Time extends I32 {\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Time, dataView);\n        }\n\n        public static fromMoment(m: moment.Duration): rTimeClass {\n            return m === null ? null : new rTimeClass(m.asMilliseconds());\n        }\n\n        public static fromScalar(value: number): rTimeClass {\n            return value === null ? null : new rTimeClass(value);\n        }\n\n        public static fromString(str: string): rTimeClass {\n            str = str.replace(\"1970-01-01T\", \"\").replace(\"Z\", \"\");\n            const timeParts = str.match(Constants.TIME_PARTS_RX);\n            const m = moment.duration(timeParts && timeParts[1] ? timeParts[1] : str);\n            return Time.fromMoment(m);\n        }\n\n        public static listToIPC(values: Array<rTimeClass>): Uint8Array {\n            const size = values.length * 4 + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(TypeNum.Time); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => Time.writeValue(v, buffer.wb)); // values\n\n            return buffer.data;\n        }\n\n        public static toIPC(value: rTimeClass): Uint8Array {\n            const buffer = Util.createBuffer(5);\n\n            buffer.wb(256 - TypeNum.Time); // type\n            Time.writeValue(value, buffer.wb); // value\n\n            return buffer.data;\n        }\n\n        public static toMoment(value: rTimeClass): moment.Duration {\n            return value === null ? null : moment.duration(value.i);\n        }\n\n        public static toScalar(value: rTimeClass): number {\n            return value === null ? null : value.i;\n        }\n\n        public static toString(\n            value: rTimeClass,\n            format = \"HH:mm:ss.SSS\",\n            options = { trim: false },\n        ): string {\n            return value === null ? \"\" : Time.toMoment(value).format(format, options);\n        }\n\n        public static writeValue(value: rTimeClass, wb: (b: number) => void): void {\n            Int.writeValue(Time.toScalar(value), wb);\n        }\n\n        getValue(i: number): rTimeClass {\n            const s = super.getScalar(i);\n            return s === I32.NULL ? null : new rTimeClass(s);\n        }\n    }\n}\n","/// <reference path=\"I64.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Timespan extends I64 {\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Timespan, dataView);\n        }\n\n        public static fromScalar(value: number): rTimespanClass {\n            // TODO: timespan loses precision due to implementation in delta client\n            return value === null ? null : new rTimespanClass(value);\n        }\n\n        public static fromMoment(m: moment.Duration): rTimespanClass {\n            return m === null ? null : new rTimespanClass(m.valueOfNano());\n        }\n\n        public static fromString(str: string): rTimespanClass {\n            let m: moment.Duration;\n            str = str.replace(\"1970-01-01T\", \"\").replace(\"Z\", \"\");\n            const timeParts = str.match(Constants.TIME_PARTS_RX);\n            if (timeParts && timeParts[1]) {\n                // convert days to hours expected format 0D12:12:12.000000000\n                if (str.indexOf(\"D\") !== -1) {\n                    const dayHourArr = str.substring(0, str.indexOf(\":\")).split(\"D\"),\n                        hours = Number(dayHourArr[1]) + Number(dayHourArr[0]) * 24;\n                    if (hours) {\n                        //get substring excluding hours\n                        timeParts[1] = hours + timeParts[1].substring(2);\n                    }\n                }\n\n                m = moment.duration(timeParts[1]);\n                const nano = Number(timeParts[2] || 0);\n                if (nano && !_.isNaN(nano)) m.nanoseconds(nano);\n            } else {\n                m = moment.duration(str);\n            }\n\n            return Timespan.fromMoment(m);\n        }\n\n        public static listToIPC(values: Array<rTimespanClass>): Uint8Array {\n            const size = values.length * 8 + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(TypeNum.Timespan); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => Timespan.writeValue(v, buffer.wb)); // values\n\n            return buffer.data;\n        }\n\n        public static toIPC(value: rTimespanClass): Uint8Array {\n            const buffer = Util.createBuffer(9);\n\n            buffer.wb(256 - TypeNum.Timespan); // type\n            Timespan.writeValue(value, buffer.wb); // value\n\n            return buffer.data;\n        }\n\n        public static toMoment(value: rTimespanClass): moment.Duration {\n            if (value === null) return null;\n            const m = moment.duration((value.i > 0 ? Math.floor : Math.ceil)(value.i / 1000000));\n            m.nanoseconds(value.i % 1000000);\n            return m;\n        }\n\n        public static toScalar(value: rTimespanClass): number {\n            // TODO: timespan loses precision due to implementation in delta client\n            return value === null ? null : value.i;\n        }\n\n        public static toString(value: rTimespanClass, format?: string, options?): string {\n            if (value === null) return \"\";\n            const m = Timespan.toMoment(value);\n            const str = m.format(format || \"HH:mm:ss.SSS\", options || { trim: false });\n            return format ? str : str + _.padEnd(\"\" + m.nanoseconds(), 6, \"0\");\n        }\n\n        public static writeValue(value: rTimespanClass, wb: (b: number) => void): void {\n            QLong.writeValue(value ? Timespan.toScalar(value).toFixed(0) : null, wb);\n        }\n\n        public getValue(i: number): rTimespanClass {\n            const s = this.getLegacyScalar(i);\n            const l =\n                typeof s === \"bigint\" || typeof s === \"number\"\n                    ? Long.fromString((s as bigint | number).toString())\n                    : s;\n\n            return l.equals(I64.LONG_NULL) ? null : new rTimespanClass(Number(l.toString()));\n        }\n    }\n}\n","/// <reference path=\"I64.ts\" />\n/// <reference path=\"Constants.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Timestamp extends I64 {\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Timestamp, dataView);\n        }\n\n        public static fromMoment(m: moment.Moment): rTimestampClass {\n            return m === null\n                ? null\n                : new rTimestampClass(m.valueOf(), m.milliseconds() * 1000000 + m.nanoseconds());\n        }\n\n        public static fromScalar(value: bigint | Long | number): rTimestampClass {\n            const kdbNanos =\n                typeof value === \"bigint\" || typeof value === \"number\"\n                    ? Long.fromString(value.toString())\n                    : value;\n\n            if (kdbNanos.equals(Constants.LONG_NULL)) {\n                return null;\n            }\n\n            // todo - need the precision of jsbn\n            const jsNanos2 = new jsbn.BigInteger(kdbNanos.toString()).add(Constants.BQEPOCH);\n\n            // convert to nano\n            const jsNanosStr = jsNanos2.toString();\n            return new rTimestampClass(\n                Number(jsNanosStr.substring(0, jsNanosStr.length - 6)),\n                Number(jsNanosStr.substring(jsNanosStr.length - 9)),\n            );\n        }\n\n        public static fromString(str: string): rTimestampClass {\n            if (str === null) return null;\n            const dateMatch = str.match(/(.*)(D|T)(.*?)Z?$/);\n            if (!dateMatch) return null;\n            str = dateMatch[1].replace(/\\./g, \"-\") + \"T\" + dateMatch[3] + \"Z\";\n            const m = moment(str);\n            m.nanoseconds(Tools.extractNanos(str));\n            return Timestamp.fromMoment(m);\n        }\n\n        public static listToIPC(values: Array<rTimestampClass>): Uint8Array {\n            const size = values.length * 8 + 6;\n            const buffer = Util.createBuffer(size);\n\n            buffer.wb(TypeNum.Timestamp); // type\n            buffer.wb(0); // attributes\n            buffer.wi(values.length); // vector size\n            _.each(values, v => DateTime.writeValue(v, buffer.wb)); // values\n\n            return buffer.data;\n        }\n\n        public static toIPC(value: rTimestampClass): Uint8Array {\n            const buffer = Util.createBuffer(9);\n\n            buffer.wb(256 - TypeNum.Timestamp); // type\n            Timestamp.writeValue(value, buffer.wb); // value\n\n            return buffer.data;\n        }\n\n        public static toMoment(value: rTimestampClass): moment.Moment {\n            if (value === null) return null;\n            const m = moment.tz(value.i, \"UTC\");\n            m.nanoseconds(value.n % 1000000);\n            if (Tools.timezone && m.isValid()) m.tz(Tools.timezone);\n            return m;\n        }\n\n        public static toScalar(value: rTimestampClass): bigint {\n            return value === null ? null : BigInt(Timestamp.toScalarString(value));\n        }\n\n        public static toString(value: rTimestampClass, format?: string): string {\n            if (value === null) return \"\";\n            const m = Timestamp.toMoment(value);\n            const str = m.format(format || \"YYYY-MM-DDTHH:mm:ss.SSS\");\n            return format ? str : str.substr(0, 23) + _.padEnd(\"\" + m.nanoseconds(), 6, \"0\") + \"Z\";\n        }\n\n        private static writeValue(value: rTimestampClass, wb: (b: number) => void): void {\n            const str = Timestamp.toScalarString(value);\n            QLong.writeValue(str, wb);\n        }\n\n        private static toScalarString(value: rTimestampClass): string {\n            if (value === null) return null;\n            const nanos = _.padStart(value.n.toFixed(0), 9, \"0\");\n            const ms = value.i.toFixed(0);\n\n            // need 64-bit+ precision\n            let bignum = new jsbn.BigInteger(ms + nanos.substring(3));\n            bignum = bignum.subtract(Constants.BQEPOCH);\n            return bignum.toString();\n        }\n\n        // note: need more than 64-bit precision here so use big nums for calcs.\n        getValue(i: number): rTimestampClass {\n            const bb = new Uint8Array(this.dataView.buffer, this.getByteLocation(i), this.SIZE);\n            const kdbNanos = Long.fromBytesLE(bb);\n            if (kdbNanos.equals(Timestamp.LONG_NULL)) {\n                return null;\n            }\n\n            // need 64-bit+ precision of jsbn\n            const jsNanos2 = new jsbn.BigInteger(kdbNanos.toString()).add(Constants.BQEPOCH);\n\n            // convert to nano\n            const jsNanosStr = jsNanos2.toString();\n            return new rTimestampClass(\n                Number(jsNanosStr.substring(0, jsNanosStr.length - 6)),\n                Number(jsNanosStr.substring(jsNanosStr.length - 9)),\n            );\n        }\n    }\n}\n","/// <reference path=\"Boolean.ts\" />\n/// <reference path=\"Byte.ts\" />\n/// <reference path=\"Char.ts\" />\n/// <reference path=\"QDate.ts\" />\n/// <reference path=\"DateTime.ts\" />\n/// <reference path=\"Dict.ts\" />\n/// <reference path=\"Double.ts\" />\n/// <reference path=\"Float.ts\" />\n/// <reference path=\"Int.ts\" />\n/// <reference path=\"List.ts\" />\n/// <reference path=\"QLong.ts\" />\n/// <reference path=\"Minute.ts\" />\n/// <reference path=\"Month.ts\" />\n/// <reference path=\"Second.ts\" />\n/// <reference path=\"Short.ts\" />\n/// <reference path=\"QString.ts\" />\n/// <reference path=\"Symbol.ts\" />\n/// <reference path=\"Time.ts\" />\n/// <reference path=\"Timespan.ts\" />\n/// <reference path=\"Timestamp.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Util {\n        private static typeDict: { [index: string]: any } = {\n            \"10\": QString,\n            \"0\": List,\n            \"-1\": Boolean,\n            \"-2\": Symbol,\n            \"-4\": Byte,\n            \"-5\": Short,\n            \"-6\": Int,\n            \"-7\": QLong,\n            \"-8\": Float,\n            \"-9\": Double,\n            \"-10\": Char,\n            \"-11\": Symbol,\n            \"-12\": Timestamp,\n            \"-13\": Month,\n            \"-14\": QDate,\n            \"-15\": DateTime,\n            \"-16\": Timespan,\n            \"-17\": Minute,\n            \"-18\": Second,\n            \"-19\": Time,\n        };\n\n        static getType(typeNum: number | string): any {\n            return Util.typeDict[typeNum];\n        }\n\n        static mergeTypedArraysUnsafe(a: any, b: any) {\n            const c = new a.constructor(a.length + b.length);\n            c.set(a);\n            c.set(b, a.length);\n\n            return c;\n        }\n\n        static fromHexString(hexString: string): Uint8Array {\n            return new Uint8Array(\n                ((hexString || \"\").match(/.{1,2}/g) || []).map(byte => parseInt(byte, 16)),\n            );\n        }\n\n        static toHexString(bytes: Array<number>) {\n            let result = \"\";\n            for (let i = 0; i < bytes.length; i++) {\n                const str = bytes[i].toString(16);\n                result += str.length === 1 ? \"0\" + str : str;\n            }\n\n            return result;\n        }\n\n        static pack(bytes: Array<number>) {\n            const chars = [];\n            for (let i = 0, n = bytes.length; i < n; ) {\n                chars.push(((bytes[i++] & 0xff) << 8) | (bytes[i++] & 0xff));\n            }\n            return String.fromCharCode.apply(null, chars);\n        }\n\n        static base64(bytes: Array<number>): string {\n            return btoa(String.fromCharCode.apply(null, bytes));\n        }\n\n        static toMessage(arr: ArrayLike<number>) {\n            const header = Util.createBuffer(8);\n            header.wi(1);\n            header.wi(arr.length + 8);\n            return Util.mergeTypedArraysUnsafe(header.data, arr);\n        }\n\n        static createBuffer(size: number) {\n            const buffer = {\n                data: new Uint8Array(size),\n                i: 0,\n                wb: (b: number) => {\n                    buffer.data[buffer.i++] = b;\n                },\n                wi: (i: number) => {\n                    _.times(4, () => {\n                        buffer.wb(i & 255);\n                        i = i >> 8;\n                    });\n                },\n            };\n\n            return buffer;\n        }\n    }\n}\n","/*global _,Backbone */\r\n\r\nvar removeObsoleteWidgets = function (appKey, objectWithWidgets) {\r\n    //fix: https://issuetracker.firstderivatives.com/browse/KXAX-11462\r\n    // remove obsolete widgets (previously undeleted during copy/paste or drag&drop)\r\n    if ((appKey === \"Accordion\" || appKey === \"Popup\") &&\r\n        objectWithWidgets && objectWithWidgets.widgets && objectWithWidgets.widgets.length > 1 &&\r\n        !(objectWithWidgets.widgets instanceof Backbone.Collection)\r\n    ) {\r\n        //change array in place\r\n        if (appKey === \"Popup\") {\r\n            //use last valid widget (component is not null)\r\n            var lastValidWidget = _.findLast(objectWithWidgets.widgets, function (w) {\r\n                return w.component;\r\n            });\r\n\r\n            //clear/empty array (faster than array.splice(0))\r\n            objectWithWidgets.widgets.length = 0;\r\n            if (lastValidWidget) {\r\n                objectWithWidgets.widgets.push(lastValidWidget);\r\n            }\r\n\r\n        } else {\r\n            //accordion: remove duplicated sections\r\n            var usedSectionIds = {},\r\n                sectionId;\r\n\r\n            for (var i = objectWithWidgets.widgets.length - 1; i >= 0; i--) {\r\n                sectionId = objectWithWidgets.widgets[i].sectionId;\r\n                if (usedSectionIds[sectionId]) {\r\n                    objectWithWidgets.widgets.splice(i, 1);\r\n                } else {\r\n                    usedSectionIds[sectionId] = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};","/// <reference types=\"backbone\" />\n\n\nclass DeepModel extends Backbone.Model {\n\n    static keyPathSeparator = '.';\n\n    // Override constructor\n    // Support having nested defaults by using _.deepExtend instead of _.extend\n    constructor(attributes, options) {\n        super(attributes, options);\n        var defaults;\n        var attrs = attributes || {};\n        this.cid = _.uniqueId('c');\n        this.attributes = {};\n        if (options && options.collection) this.collection = options.collection;\n        if (options && options.parse) attrs = this.parse(attrs, options) || {};\n        if (defaults = _.result(this, 'defaults')) {\n            //<custom code>\n            // Replaced the call to _.defaults with _.deepExtend.\n            attrs = _.merge(defaults, attrs);\n            //</custom code>\n        }\n        this.set(attrs, options);\n        this.changed = {} as any[];\n        this.initialize.apply(this, arguments);\n    }\n\n\n    /**\n     * Takes a nested object and returns a shallow object keyed with the path names\n     * e.g. { \"level1.level2\": \"value\" }\n     *\n     * @param  {Object}      Nested object e.g. { level1: { level2: 'value' } }\n     * @return {Object}      Shallow object with path names e.g. { 'level1.level2': 'value' }\n     */\n    private static objToPaths(obj, flattenPath?, currentPath?) {\n        var flattenArrays = false,\n            obj2,\n            ret = {},\n            separator = DeepModel.keyPathSeparator;\n\n        for (var key in obj) {\n            var val = obj[key];\n\n            currentPath = (currentPath) ? currentPath + separator + key : key;\n\n            // flattenPath is the path that we should return in dot syntax,\n            // e.g. return { Layers.0.Visible: true } instead of\n            // Layers: [\n            //   {\n            //     Visible: true\n            //   }\n            // ]\n            // Used by ComponentApi.setProperty and allows a single deep property to be sent\n            // to a component's onSettingsChange while maintaining array order.\n            // If it is set to true then all arrays should be flattened.\n            if (flattenPath === true) {\n                flattenArrays = true;\n            } else if (flattenPath && typeof flattenPath === 'string' && flattenPath !== currentPath && flattenPath.indexOf(currentPath) === 0) {\n                flattenArrays = true;\n            }\n\n            if (val && (val.constructor === Object)) {\n                if (!_.isEmpty(val)) {\n                    if (_.has(val, '_dashboardsType')) {\n                        // Don't flatten objects with _dashboardsType key\n                        ret[key] = val;\n                    } else {\n                        //Recursion for embedded objects\n                        obj2 = this.objToPaths(val, flattenPath, currentPath);\n\n                        for (var key2 in obj2) {\n                            var val2 = obj2[key2];\n\n                            ret[key + separator + key2] = val2;\n                        }\n                    }\n                } else {\n                    ret[key] = val;\n                }\n            } else if (val && (val.constructor === Array) && flattenArrays) {\n                obj2 = this.objToPaths(val, flattenPath, currentPath);\n\n                for (var key2 in obj2) {\n                    var val2 = obj2[key2];\n\n                    ret[key + separator + key2] = val2;\n                }\n            } else {\n                ret[key] = val;\n            }\n        }\n\n        return ret;\n    }\n\n    /**\n     * [getNested description]\n     * @param  {object} obj           to fetch attribute from\n     * @param  {string} path          path e.g. 'user.name'\n     * @param  {[type]} return_exists [description]\n     * @return {mixed}                [description]\n     */\n    private static getNested(obj, path, return_exists?) {\n        var separator = DeepModel.keyPathSeparator;\n\n        var fields = path ? path.split(separator) : [];\n        var result = obj;\n        return_exists || (return_exists === false);\n        for (var i = 0, n = fields.length; i < n; i++) {\n            if (return_exists && !_.has(result, fields[i])) {\n                return false;\n            }\n            result = result[fields[i]];\n\n            if (result == null && i < n - 1) {\n                result = {};\n            }\n\n            if (typeof result === 'undefined') {\n                if (return_exists) {\n                    return true;\n                }\n                return result;\n            }\n        }\n        if (return_exists) {\n            return true;\n        }\n        return result;\n    }\n\n\n\n    /**\n     * @param {Object} obj                Object to fetch attribute from\n     * @param {String} path               Object path e.g. 'user.name'\n     * @param {Object} [options]          Options\n     * @param {Boolean} [options.unset]   Whether to delete the value\n     * @param {Mixed}                     Value to set\n     */\n    private static setNested(obj, path, val, options?) {\n        options = options || {};\n\n        var separator = DeepModel.keyPathSeparator;\n\n        var fields = path ? path.split(separator) : [];\n        var result = obj;\n        for (var i = 0, n = fields.length; i < n && result !== undefined; i++) {\n            var field = fields[i];\n\n            //If the last in the path, set the value\n            if (i === n - 1) {\n                options.unset ? delete result[field] : result[field] = val;\n            } else {\n                //Create the child object if it doesn't exist, or isn't an object\n                if (typeof result[field] === 'undefined' || !_.isObject(result[field])) {\n                    var nextField = fields[i + 1];\n\n                    // create array if next field is integer, else create object\n                    result[field] = /^\\d+$/.test(nextField) ? [] : {};\n                }\n\n                //Move onto the next part of the path\n                result = result[field];\n            }\n        }\n    }\n\n    private static deleteNested(obj, path) {\n        this.setNested(obj, path, null, {\n            unset: true\n        });\n    }\n\n    // Return a copy of the model's `attributes` object.\n    toJSON(options) {\n        return _.merge({}, this.attributes);\n    }\n\n    // Override get\n    // Supports nested attributes via the syntax 'obj.attr' e.g. 'author.user.name'\n    get(attr) {\n        return DeepModel.getNested(this.attributes, attr);\n    }\n\n    // Override set\n    // Supports nested attributes via the syntax 'obj.attr' e.g. 'author.user.name'\n    set(key: any, val: any, options?: Backbone.ModelSetOptions): Backbone.Model {\n        var attr, attrs, unset, changes, silent, changing, prev, current;\n        if (key == null) return this as unknown as Backbone.Model;\n\n        // Handle both `\"key\", value` and `{key: value}` -style arguments.\n        if (typeof key === 'object') {\n            attrs = key;\n            options = val || {};\n        } else {\n            (attrs = {})[key] = val;\n        }\n\n        options || (options = {});\n\n        // Run validation.\n        if (!this._validate(attrs, options)) return null;\n\n        // Extract attributes and options.\n        unset = options['unset'];\n        silent = options.silent;\n        changes = [];\n        changing = this._changing;\n        this._changing = true;\n\n        if (!changing) {\n            this._previousAttributes = _.merge({}, this.attributes); //<custom>: Replaced _.clone with _.deepClone\n            this.changed = {} as any[]\n        }\n        current = this.attributes, prev = this._previousAttributes;\n\n        // Check for changes of `id`.\n        if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];\n\n        //<custom code>\n        attrs = DeepModel.objToPaths(attrs);\n        //</custom code>\n\n        // For each `set` attribute, update or delete the current value.\n        for (attr in attrs) {\n            val = attrs[attr];\n\n            //<custom code>: Using getNested, setNested and deleteNested\n            if (!_.isEqual(DeepModel.getNested(current, attr), val)) changes.push(attr);\n            if (!_.isEqual(DeepModel.getNested(prev, attr), val)) {\n                DeepModel.setNested(this.changed as any, attr, val);\n            } else {\n                DeepModel.deleteNested(this.changed, attr);\n            }\n            unset ? DeepModel.deleteNested(current, attr) : DeepModel.setNested(current, attr, val);\n            //</custom code>\n        }\n\n        // Remove any top-level empty objects\n        _.each(this.changed, _.bind(function (v, k) {\n            if (_.isEmpty(v) && _.isObject(v) && !_.isArray(v)) {\n                delete this.changed[k];\n            }\n        }, this));\n\n        // Trigger all relevant attribute changes.\n        if (!silent) {\n            if (changes.length) this._pending = true;\n\n            //<custom code>\n            var separator = DeepModel.keyPathSeparator;\n            var alreadyTriggered = {}; // * @restorer\n\n            for (var i = 0, l = changes.length; i < l; i++) {\n                var key = changes[i];\n\n                if (!alreadyTriggered.hasOwnProperty(key) || !alreadyTriggered[key]) { // * @restorer\n                    alreadyTriggered[key] = true; // * @restorer\n                    this.trigger('change:' + key, this, DeepModel.getNested(current, key), options);\n                } // * @restorer\n\n                var fields = key.split(separator);\n\n                //Trigger change events for parent keys with wildcard (*) notation\n                for (var n = fields.length - 1; n > 0; n--) {\n                    var parentKey = fields.slice(0, n).join(separator),\n                        wildcardKey = parentKey + separator + '*';\n\n                    if (!alreadyTriggered.hasOwnProperty(wildcardKey) || !alreadyTriggered[wildcardKey]) { // * @restorer\n                        alreadyTriggered[wildcardKey] = true; // * @restorer\n                        this.trigger('change:' + wildcardKey, this, DeepModel.getNested(current, parentKey), options);\n                    } // * @restorer\n\n                    // + @restorer\n                    if (!alreadyTriggered.hasOwnProperty(parentKey) || !alreadyTriggered[parentKey]) {\n                        alreadyTriggered[parentKey] = true;\n                        this.trigger('change:' + parentKey, this, DeepModel.getNested(current, parentKey), options);\n                    }\n                    // - @restorer\n                }\n                //</custom code>\n            }\n        }\n\n        if (changing) return this as unknown as Backbone.Model;\n        if (!silent) {\n            while (this._pending) {\n                this._pending = false;\n                this.trigger('change', this, options);\n            }\n        }\n        this._pending = false;\n        this._changing = false;\n        return this as unknown as Backbone.Model;\n    }\n\n    // Clear all attributes on the model, firing `\"change\"` unless you choose\n    // to silence it.\n    clear(options) {\n        var attrs = {};\n        var shallowAttributes = DeepModel.objToPaths(this.attributes);\n        for (var key in shallowAttributes) attrs[key] = void 0;\n        return this.set(attrs, _.extend({}, options, {\n            unset: true\n        }));\n    }\n\n    // Determine if the model has changed since the last `\"change\"` event.\n    // If you specify an attribute name, determine if that attribute has changed.\n    hasChanged(attr?) {\n        if (attr == null) return !_.isEmpty(this.changed);\n        return DeepModel.getNested(this.changed, attr) !== undefined;\n    }\n\n    // Return an object containing all the attributes that have changed, or\n    // false if there are no changed attributes. Useful for determining what\n    // parts of a view need to be updated and/or what attributes need to be\n    // persisted to the server. Unset attributes will be set to undefined.\n    // You can also pass an attributes object to diff against the model,\n    // determining if there *would be* a change.\n    changedAttributes(diff, propertyPath?): any {\n        //<custom code>: objToPaths\n        if (!diff) return this.hasChanged() ? DeepModel.objToPaths(this.changed, propertyPath) : false;\n        //</custom code>\n\n        var old = this._changing ? this._previousAttributes : this.attributes;\n\n        //<custom code>\n        var diffFlat = DeepModel.objToPaths(diff);\n        var oldFlat = DeepModel.objToPaths(old);\n\n        var changed: any = false;\n        for (var attr in diffFlat) {\n            if (_.includes(['array', 'object'], typeof old[attr]) && diff[attr] === undefined) {\n                (changed || (changed = {}))[attr] = undefined;\n            } else if (!_.isEqual(oldFlat[attr], diffFlat[attr])) {\n                (changed || (changed = {}))[attr] = diffFlat[attr];\n            }\n        }\n        //</custom code>\n\n        return changed;\n    }\n\n    // Get the previous value of an attribute, recorded at the time the last\n    // `\"change\"` event was fired.\n    previous(attr) {\n        if (attr == null || !this._previousAttributes) return null;\n\n        //<custom code>\n        return DeepModel.getNested(this._previousAttributes, attr);\n        //</custom code>\n    }\n\n    // Get all of the attributes of the model at the time of the previous\n    // `\"change\"` event.\n    previousAttributes() {\n        //<custom code>\n        return _.merge({}, this._previousAttributes);\n        //</custom code>\n    }\n\n    toFlat(flattenArrays) {\n        return DeepModel.objToPaths(this.attributes, flattenArrays);\n    }\n}\n\nBackbone.DeepModel = DeepModel;","var deepDiff = function () {\r\n    return {\r\n        VALUE_CREATED: 'created',\r\n        VALUE_UPDATED: 'updated',\r\n        VALUE_DELETED: 'deleted',\r\n        VALUE_UNCHANGED: 'unchanged',\r\n\r\n        /*\r\n         *  Get the difference between 2 json objects\r\n         *  Remove any of the unchanged properties\r\n         */\r\n        getDiff : function(obj1, obj2){\r\n           return this.removeUnchanged(this.map(obj1,obj2));\r\n        },\r\n        map: function (obj1, obj2) {\r\n            if (this.isFunction(obj1) || this.isFunction(obj2)) {\r\n                throw 'Invalid argument. Function given, object expected.';\r\n            }\r\n            if (this.isValue(obj1) || this.isValue(obj2)) {\r\n                var o  =_.clone((obj1 === undefined) ? obj2 : obj1);\r\n                return o;\r\n            }\r\n\r\n            var diff = {};\r\n            for (var key in obj1) {\r\n                if (this.isFunction(obj1[key])) {\r\n                    continue;\r\n                }\r\n                var value2 = undefined;\r\n                if ('undefined' != typeof (obj2[key])) {\r\n                    value2 = obj2[key];\r\n                }\r\n                //always copy in Hidden properties\r\n                if (key === '_Hidden') {\r\n                    diff[key] = obj1[key];\r\n                } else if (this.compareValues(obj1[key], value2) !== 'unchanged') {\r\n                    diff[key] = this.map(obj1[key], value2);\r\n                } else {\r\n                    diff[key] = null;\r\n                }\r\n            }\r\n            for (var key in obj2) {\r\n                if (this.isFunction(obj2[key]) || ('undefined' != typeof (diff[key]))) {\r\n                    continue;\r\n                }\r\n                diff[key] = this.map(undefined, obj2[key]);\r\n            }\r\n            return diff;\r\n\r\n        },\r\n        compareValues: function (value1, value2) {\r\n            if (value1 === value2) {\r\n                return this.VALUE_UNCHANGED;\r\n            }\r\n            if (this.isDate(value1) && this.isDate(value2) && value1.getTime() === value2.getTime()) {\r\n                return this.VALUE_UNCHANGED;\r\n            }\r\n            if ('undefined' == typeof (value1)) {\r\n                return this.VALUE_CREATED;\r\n            }\r\n            if ('undefined' == typeof (value2)) {\r\n                return this.VALUE_DELETED;\r\n            }\r\n\r\n            return this.VALUE_UPDATED;\r\n        },\r\n        isFunction: function (obj) {\r\n            return {}.toString.apply(obj) === '[object Function]';\r\n        },\r\n        isArray: function (obj) {\r\n            return {}.toString.apply(obj) === '[object Array]';\r\n        },\r\n        isDate: function (obj) {\r\n            return {}.toString.apply(obj) === '[object Date]';\r\n        },\r\n        isObject: function (obj) {\r\n            return {}.toString.apply(obj) === '[object Object]';\r\n        },\r\n        isValue: function (obj) {\r\n            return !this.isObject(obj) && !this.isArray(obj);\r\n        },\r\n        removeUnchangedJSON: function (cleanObj) {\r\n            _.each(cleanObj, _.bind(function (val, key) {\r\n                if (_.isEqual(val, {}) || _.isEqual([], val) || val === null) {\r\n                    delete cleanObj[key];\r\n                } else if (! _.isArray(val) && typeof(val) !== \"string\") {                \r\n                    this.removeUnchangedJSON(cleanObj[key]);\r\n                }\r\n            }, this));\r\n        },\r\n        removeUsedKeys: function (app){\r\n            for(var key in app){\r\n                if(app[key] !== null && typeof(app[key]) === 'object'){\r\n                    this.removeUsedKeys(app[key])\r\n\r\n                    if(_.isEqual(app[key], {})) {\r\n                        delete app[key]\r\n                    }\r\n                } \r\n                if(app[key] === null){\r\n                    delete app[key]\r\n                }\r\n            }\r\n        },\r\n        removeUnchanged: function (obj) {\r\n            var cleanObj = {};\r\n            var primitiveTypes = ['string', 'number', 'boolean'];\r\n            _.each(obj, _.bind(function (val, key) {\r\n                if (_.indexOf(primitiveTypes, typeof(val)) >= 0) {\r\n                    cleanObj[key] = val;\r\n                } else if (val !== null || !_.isArray(val)) {                  \r\n                    cleanObj[key] = _.pickBy(val, function (v, k) {\r\n                        return v !== null;\r\n                    });\r\n                } else {                   \r\n                    cleanObj[key] = val;\r\n                }\r\n            }, this));           \r\n          \r\n            this.removeUsedKeys(cleanObj);\r\n            return cleanObj;\r\n        }\r\n    }\r\n}();\r\n","var getCommonDefinition = function () {\r\n    return {\r\n        'appArgs': {\r\n            \"json\": {\r\n                \"Style\": {\r\n                    \"advanced\": \"\",\r\n                    \"cssClasses\": \"\"\r\n                },\r\n                \"Alignment\": {\r\n                    \"paddingLeft\": null,\r\n                    \"paddingRight\": null,\r\n                    \"paddingTop\": null,\r\n                    \"paddingBottom\": null,\r\n                    \"innerPaddingLeft\": null,\r\n                    \"innerPaddingRight\": null,\r\n                    \"innerPaddingTop\": null,\r\n                    \"innerPaddingBottom\": null,\r\n                    // -- title moved from format\r\n                    \"titlePaddingLeft\": null,\r\n                    \"titlePaddingRight\": null,\r\n                    \"titlePaddingTop\": 7,\r\n                    \"titlePaddingBottom\": 7\r\n                },\r\n                \"format\": {\r\n                    // title\r\n                    \"widgetTitle\": null,\r\n                    \"titleFontSize\": 16,\r\n                    \"titleHorizontal\": \"Center\",\r\n                    \"titleColor\": null,\r\n                    \"titleBottomBorderWidth\": null,\r\n                    \"titleFontBold\": null,\r\n                    \"titleShadow\": false,\r\n                    \"titleBackgroundColor\": null,\r\n                    \"titleTransparentBackground\": null,\r\n                    // tile\r\n                    \"tileBorderWidth\": null,\r\n                    \"tileBorderRounding\": null,\r\n                    \"tileBorderColor\": null,\r\n                    \"tileBackgroundColor\": null,\r\n                    \"tileTransparentBackground\": null,\r\n                    \"tileShadow\": null\r\n                }\r\n            },\r\n            \"schema\": {\r\n                \"properties\": {\r\n                    \"Style\": {\r\n                        \"type\": \"object\",\r\n                        \"title\": \"Style\",\r\n                        \"options\": {\r\n                            \"collapsed\": true\r\n                        },\r\n                        \"properties\": {\r\n                            \"advanced\": {\r\n                                // \"propertyOrder\": 160,\r\n                                \"type\": \"css\",\r\n                                \"title\": \"Advanced CSS\",\r\n                                \"default\": \"\"\r\n                            },\r\n                            \"cssClasses\": {\r\n                                // \"propertyOrder\": 165,\r\n                                \"type\": \"string\",\r\n                                \"title\": \"CSS Classes\",\r\n                                \"default\": \"\"\r\n                            }\r\n                        }\r\n                    },\r\n                    \"Alignment\": {\r\n                        \"type\": \"object\",\r\n                        \"title\": \"Margins\",\r\n                        \"options\": {\r\n                            \"collapsed\": true\r\n                        },\r\n                        \"properties\": {\r\n                            \"paddingLeft\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Outer Left\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2001\r\n                            },\r\n                            \"paddingRight\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Outer Right\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2002\r\n                            },\r\n                            \"paddingTop\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Outer Top\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2003\r\n                            },\r\n                            \"paddingBottom\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Outer Bottom\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2004\r\n                            },\r\n                            \"innerPaddingLeft\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Inner Left\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2005\r\n                            },\r\n                            \"innerPaddingRight\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Inner Right\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2006\r\n                            },\r\n                            \"innerPaddingTop\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Inner Top\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2007\r\n                            },\r\n                            \"innerPaddingBottom\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Inner Bottom\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2008\r\n                            },\r\n                            \"titlePaddingLeft\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Title Left\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2009\r\n                            },\r\n                            \"titlePaddingRight\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Title Right\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2010\r\n                            },\r\n                            \"titlePaddingTop\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Title Top\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2011\r\n                            },\r\n                            \"titlePaddingBottom\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Title Bottom\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2012\r\n                            }\r\n                        }\r\n                    },\r\n                    \"format\": {\r\n                        \"type\": \"object\",\r\n                        \"title\": \"Format\",\r\n                        \"options\": {\r\n                            \"collapsed\": true\r\n                        },\r\n                        \"properties\": {\r\n                            \"widgetTitle\": {\r\n                                \"type\": \"string\",\r\n                                \"title\": \"Title\",\r\n                                \"propertyOrder\": 2001\r\n                            },\r\n                            \"titleFontSize\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Title Font Size\",\r\n                                \"propertyOrder\": 2002\r\n                            },\r\n                            \"titleColor\": {\r\n                                \"type\": \"gradient\",\r\n                                \"title\": \"Title Font Color\",\r\n                                \"options\": {\r\n                                    \"gradient\": false,\r\n                                    \"noColor\": true\r\n                                },\r\n                                \"default\": null,\r\n                                \"propertyOrder\": 2003\r\n                            },\r\n                            \"titleFontBold\": {\r\n                                \"type\": \"boolean\",\r\n                                \"title\": \"Title Bold\",\r\n                                \"default\": false,\r\n                                \"format\": \"checkbox\",\r\n                                \"propertyOrder\": 2004\r\n                            },\r\n                            \"titleShadow\": {\r\n                                \"type\": \"boolean\",\r\n                                \"title\": \"Title Shadow\",\r\n                                \"default\": false,\r\n                                \"format\": \"checkbox\",\r\n                                \"propertyOrder\": 2005\r\n                            },\r\n                            \"titleHorizontal\": {\r\n                                \"type\": \"string\",\r\n                                \"title\": \"Title Horizontal Align\",\r\n                                \"enum\": [\"Left\", \"Center\", \"Right\"],\r\n                                \"propertyOrder\": 2006\r\n                            },\r\n                            \"titleBottomBorderWidth\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Title Bottom Border Size\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2007\r\n                            },\r\n                            \"titleBackgroundColor\": {\r\n                                \"type\": \"gradient\",\r\n                                \"title\": \"Title Background Color\",\r\n                                \"default\": null,\r\n                                \"options\": {\r\n                                    \"gradient\": false,\r\n                                    \"noColor\": true\r\n                                },\r\n                                \"propertyOrder\": 2008\r\n                            },\r\n                            \"titleTransparentBackground\": {\r\n                                \"type\": \"boolean\",\r\n                                \"title\": \"Title Transparent Background\",\r\n                                \"default\": false,\r\n                                \"format\": \"checkbox\",\r\n                                \"propertyOrder\": 2009\r\n                            },\r\n                            \"tileBackgroundColor\": {\r\n                                \"type\": \"gradient\",\r\n                                \"title\": \"Background Color\",\r\n                                \"default\": null,\r\n                                \"options\": {\r\n                                    \"gradient\": false,\r\n                                    \"noColor\": true\r\n                                },\r\n                                \"propertyOrder\": 2010\r\n                            },\r\n                            \"tileTransparentBackground\": {\r\n                                \"type\": \"boolean\",\r\n                                \"title\": \"Transparent Background\",\r\n                                \"default\": false,\r\n                                \"format\": \"checkbox\",\r\n                                \"propertyOrder\": 2011\r\n                            },\r\n                            \"tileBorderWidth\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Border Size\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2012\r\n                            },\r\n                            \"tileBorderRounding\": {\r\n                                \"type\": \"number\",\r\n                                \"title\": \"Border Rounding\",\r\n                                \"default\": null,\r\n                                \"format\": \"number\",\r\n                                \"propertyOrder\": 2013\r\n                            },\r\n                            \"tileBorderColor\": {\r\n                                \"type\": \"gradient\",\r\n                                \"title\": \"Border Color\",\r\n                                \"default\": null,\r\n                                \"options\": {\r\n                                    \"gradient\": false,\r\n                                    \"noColor\": true\r\n                                },\r\n                                \"propertyOrder\": 2014\r\n                            },\r\n                            \"tileShadow\": {\r\n                                \"type\": \"boolean\",\r\n                                \"title\": \"Component Shadow\",\r\n                                \"default\": false,\r\n                                \"format\": \"checkbox\",\r\n                                \"propertyOrder\": 2015\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n};","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export enum CommandOp {\n        Add,\n        Remove,\n        Set,\n    }\n\n    export class Todo {\n        op: CommandOp;\n        key: string | number;\n        payload;\n\n        constructor(op, key, payload) {\n            this.op = op;\n            this.key = key;\n            this.payload = payload;\n        }\n    }\n\n    export class Command {\n        readonly title: string;\n        path: string[];\n        readonly todo: Array<Todo>;\n        readonly undo: Array<Todo>;\n\n        constructor(title, path, todo, undo) {\n            this.title = title;\n            this.path = path;\n            this.todo = todo;\n            this.undo = undo;\n        }\n\n        static pathArrayToText(path: string[]): string {\n            return path.reverse().join(\".\");\n        }\n\n        pathText(): string {\n            return Command.pathArrayToText(this.path);\n        }\n    }\n\n    export interface Commandable {\n        postCommand(sender: object, command: Command): void;\n        doCommand(path: Array<string>, todos: Array<Todo>): void;\n    }\n\n    export abstract class CommandoModel extends Backbone.Model implements Commandable {\n        protected parent: Commandable;\n\n        constructor(attributes, options, parent: Commandable) {\n            super(attributes, options);\n            this.parent = parent;\n        }\n\n        setParent(parent: Commandable): void {\n            this.parent = parent;\n        }\n\n        abstract postCommand(sender: object, command: Command): void;\n        abstract doCommand(path: Array<string>, todos: Array<Todo>): void;\n    }\n\n    export abstract class ComandoCollection<T extends CommandoModel> extends Backbone.Collection<T>\n        implements Commandable {\n        descriptor: string;\n        doCommandByOp;\n        parent: Commandable;\n\n        constructor(models, options, parent: Commandable) {\n            super(\n                models,\n                _.extend(options, {\n                    parent: parent,\n                }),\n            );\n\n            this.doCommandByOp = {\n                [CommandOp.Add]: this.doCommandAdd.bind(this),\n                [CommandOp.Remove]: this.doCommandRemove.bind(this),\n                [CommandOp.Set]: this.doCommandSet.bind(this),\n            };\n        }\n\n        commandAdd(models, verb?: string): void {\n            const modelsToAdd = _.isArray(models) ? models : [models];\n\n            this.postCommand(\n                this,\n                new Command(\n                    this.getCommandDescription(CommandOp.Add, models, verb || \"Add\"),\n                    [],\n                    modelsToAdd.map(\n                        m =>\n                            new Todo(CommandOp.Add, \"\", {\n                                attributes: m.toJSON(),\n                            }),\n                    ),\n                    modelsToAdd.map(m => new Todo(CommandOp.Remove, \"\", m.id)),\n                ),\n            );\n        }\n\n        commandRemove(models): void {\n            const modelsToRemove = _.isArray(models) ? models : [models];\n\n            this.postCommand(\n                this,\n                new Command(\n                    this.getCommandDescription(CommandOp.Remove, models),\n                    [],\n                    modelsToRemove.map(m => new Todo(CommandOp.Remove, \"\", m.id)),\n                    modelsToRemove.map(\n                        m =>\n                            new Todo(CommandOp.Add, \"\", {\n                                attributes: m.toJSON(),\n                                index: this.findIndex(m),\n                            }),\n                    ),\n                ),\n            );\n        }\n\n        commandSet(models): void {\n            const oldJSON = models.map((m, i) => {\n                const model = this.get(m.id) || this.at(i);\n\n                if (model) {\n                    const changedAttributes = model.changedAttributes(m);\n                    const previousAttributes = _.mapValues(changedAttributes, (value, key) =>\n                        model.previous(key),\n                    );\n\n                    if (model.id) {\n                        previousAttributes.id = model.id;\n                    }\n\n                    return previousAttributes;\n                }\n            });\n\n            this.postCommand(\n                this,\n                new Command(\n                    this.getCommandDescription(CommandOp.Set, models),\n                    [],\n                    [new Todo(CommandOp.Set, \"\", models)],\n                    [new Todo(CommandOp.Set, \"\", oldJSON)],\n                ),\n            );\n        }\n\n        doCommand(path: Array<string>, todos: Array<Todo>): void {\n            const key = path.pop();\n\n            if (key) {\n                const child = this.get(key);\n                child && child.doCommand(path, todos);\n            } else {\n                todos.forEach(t => {\n                    this.doCommandByOp[t.op](t.payload);\n                });\n            }\n        }\n\n        doCommandAdd(payload): void {\n            this.add(payload.attributes, { at: payload.index });\n        }\n\n        doCommandSet(payload): void {\n            this.set(payload, { remove: false });\n        }\n\n        doCommandRemove(payload): void {\n            this.remove(payload);\n        }\n\n        getCommandDescription(op: CommandOp, payload?, verb?: string): string {\n            let descriptor = this.getCommandDescriptor(payload);\n            verb = verb || CommandOp[op];\n\n            if (descriptor && _.isArray(payload) && payload.length > 1) {\n                descriptor = this.getPluralDescriptor(descriptor);\n            }\n\n            return verb + \" \" + descriptor;\n        }\n\n        getCommandDescriptor(payload): string {\n            return this.descriptor;\n        }\n\n        getPluralDescriptor(descriptor: string): string {\n            return descriptor + \"s\";\n        }\n\n        postCommand(sender: object, command: Command): void {\n            return this.parent.postCommand(this, command);\n        }\n\n        preinitialize(models, options): void {\n            this.parent = options.parent;\n        }\n\n        setParent(parent: Commandable): void {\n            this.parent = parent;\n        }\n\n        _prepareModel(attrs, options?): object | boolean {\n            if (this._isModel(attrs)) {\n                if (!attrs.collection) attrs.collection = this;\n                return attrs;\n            }\n            options = options ? _.clone(options) : {};\n            options.collection = this;\n\n            // gk: this line is overriden to pass-through parent\n            const model = new this.model(attrs, options, this);\n            if (!model.validationError) return model;\n            this.trigger(\"invalid\", this, model.validationError, options);\n            return false;\n        }\n    }\n}\n","/*global _,Backbone,WidgetCollection */\r\n/// <reference path=\"../classes/removeObsoleteWidgets.ts\"/>\r\n/// <reference path=\"../lib/backbone-deep-model.ts\" />\r\n/// <reference path=\"../lib/diff.ts\"/>\r\n/// <reference path=\"../classes/commonDefinitions.ts\"/>\r\n/// <reference path=\"ICommandable.ts\" />\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class ComponentOptions extends Backbone.DeepModel implements Commandable {\r\n        _templates: any;\r\n\r\n        IMMATERIAL_ATTRIBUTES = [\r\n            \"version\",\r\n\r\n            // enum sources\r\n            \"poss_sel_cols\",\r\n            \"possible_axis\",\r\n            \"possible_colors\",\r\n            \"possible_columns\",\r\n            \"possible_dashboards\",\r\n            \"possible_floats\",\r\n            \"possible_keys\",\r\n            \"possible_labels\",\r\n            \"possible_Period\",\r\n            \"possible_screens\",\r\n            \"possible_selected_columns\",\r\n            \"possible_servers\",\r\n            \"possible_shapes\",\r\n            \"possible_strings\",\r\n            \"possible_track\",\r\n            \"possible_values\",\r\n            \"possible_viewstates\",\r\n            \"possibleColumns\",\r\n            \"possibleConnections\",\r\n            \"possibleKeys\",\r\n            \"possibleLabels\",\r\n            \"possibleValues\",\r\n\r\n            // datagrid\r\n            \"datagridPossibleColumns\",\r\n            \"datagridPossibleColumnsWithItself\",\r\n            \"selectedColumnPossibleValues\",\r\n            \"highlightTargetPossibleValues\",\r\n            \"sortingPossibleValues\",\r\n\r\n            // tabs\r\n            \"Selection\",\r\n        ];\r\n\r\n        parent: Commandable;\r\n\r\n        constructor(attributes, options, parent: Commandable) {\r\n            super(attributes, options);\r\n            this.parent = parent;\r\n        }\r\n\r\n        static setDataProperties(root) {\r\n            if (root) {\r\n                for (const key in root) {\r\n                    if (root[key] && root[key].path) {\r\n                        if (root[key] instanceof DocumentDataModel) {\r\n                            root[key] = {\r\n                                _dashboardsType: \"data\",\r\n                                value: root[key].path,\r\n                            };\r\n                        } else if (root[key] instanceof DocumentViewModel) {\r\n                            root[key] = {\r\n                                _dashboardsType: \"viewstate\",\r\n                                value: root[key].path,\r\n                            };\r\n                        }\r\n                    } else if (typeof root[key] === \"object\") {\r\n                        root[key] = ComponentOptions.setDataProperties(root[key]);\r\n                    }\r\n                }\r\n                return root;\r\n            }\r\n        }\r\n\r\n        initialize() {\r\n            this.listenTo(this, \"change\", this.determineMaterialChange.bind(this));\r\n        }\r\n\r\n        clone(options?): ComponentOptions {\r\n            let previousWidgetId, widgetId, widgetIdRegex;\r\n            const copy = {},\r\n                cloneRecursive = function(original, copy): void {\r\n                    _.each(_.keys(original), function(key) {\r\n                        let i = 0;\r\n\r\n                        if (\r\n                            original[key] instanceof DocumentViewModel ||\r\n                            original[key] instanceof DocumentDataModel\r\n                        ) {\r\n                            // ref re-assign\r\n\r\n                            // assign by reference\r\n                            copy[key] = original[key];\r\n                        } else if (original[key] instanceof Array) {\r\n                            // array copy\r\n                            // create new array\r\n                            copy[key] = new Array(original[key].length);\r\n                            // copy array values\r\n                            for (i = 0; i < original[key].length; i += 1) {\r\n                                if (_.isObjectLike(original[key][i])) {\r\n                                    copy[key][i] = original[key][i] instanceof Array ? [] : {};\r\n                                    cloneRecursive(original[key][i], copy[key][i]);\r\n                                } else {\r\n                                    copy[key][i] = original[key][i];\r\n                                }\r\n                            }\r\n                        } else if (original[key] instanceof Date) {\r\n                            // date copy\r\n                            // create new date\r\n                            copy[key] = new Date();\r\n                            // copy date value\r\n                            copy[key].setTime(original[key].getTime());\r\n                        } else if (_.isObject(original[key])) {\r\n                            // object copy\r\n                            // create new object copy\r\n                            copy[key] = {};\r\n                            // recursive call\r\n                            cloneRecursive(original[key], copy[key]);\r\n                        } else if (\r\n                            key === \"advanced\" &&\r\n                            original[key].indexOf(previousWidgetId) !== -1 &&\r\n                            widgetId\r\n                        ) {\r\n                            // replace widgetId with new value\r\n                            copy[key] = original[key].replace(widgetIdRegex, widgetId);\r\n                        } else {\r\n                            // value copy, and everything else\r\n                            // try to copy like it's a simple value (?)\r\n                            copy[key] = original[key];\r\n                        }\r\n                    });\r\n                };\r\n\r\n            if (options) {\r\n                (previousWidgetId = options.previousWidgetId), (widgetId = options.widgetId);\r\n                widgetIdRegex = new RegExp(previousWidgetId, \"g\");\r\n            }\r\n\r\n            // deep copy object attributes\r\n            // replace any instances of DocumentViewModel and DocumentDataModel with original object\r\n            cloneRecursive(this.attributes, copy);\r\n\r\n            // return new component options\r\n            return new ComponentOptions(copy, {}, this.parent);\r\n        }\r\n\r\n        commandSet(json): void {\r\n            const oldJSON = _.mapValues(json, (value, key) => this.get(key));\r\n            const keys = _.keys(json);\r\n            let description = \"Set \";\r\n\r\n            if (keys[0]) {\r\n                description += _.last(keys[0].split(\".\"));\r\n            }\r\n\r\n            if (keys.length > 1) {\r\n                description += \" & \" + (keys.length - 1) + \" more\";\r\n            }\r\n\r\n            const c = new Command(\r\n                description,\r\n                [],\r\n                [new Todo(CommandOp.Set, \"\", json)],\r\n                [new Todo(CommandOp.Set, \"\", oldJSON)],\r\n            );\r\n\r\n            this.postCommand(this, c);\r\n        }\r\n\r\n        determineMaterialChange(model, value): void {\r\n            if (model.changed && !_.isEmpty(_.omit(model.changed, model.IMMATERIAL_ATTRIBUTES))) {\r\n                this.trigger(\"materialChange\");\r\n            }\r\n        }\r\n\r\n        doCommand(path: Array<string>, todos: Array<Todo>): void {\r\n            //TODO: do something its your command\r\n            todos.forEach(t => {\r\n                this.set(t.payload);\r\n            });\r\n        }\r\n\r\n        postCommand(sender: object, command: Command): void {\r\n            return this.parent && this.parent.postCommand(this, command);\r\n        }\r\n\r\n        setParent(parent: Commandable): void {\r\n            this.parent = parent;\r\n        }\r\n\r\n        /** Get the diff with the default component JSON\r\n         */\r\n        toDiff(attributes): object {\r\n            const diff = {};\r\n            const templates = this._templates;\r\n\r\n            //Check if Component Default templates are available\r\n            if (templates && templates.Defaults) {\r\n                //add alignment & format to Defaults\r\n                _.defaultsDeep(templates.Defaults, getCommonDefinition().appArgs.json);\r\n\r\n                _.each(\r\n                    attributes,\r\n                    _.bind(function(val, key) {\r\n                        const valDiff = {};\r\n                        if (templates.Defaults[key]) {\r\n                            //if the Template Value is a String\r\n                            if (typeof val === \"string\") {\r\n                                diff[key] = val;\r\n                            }\r\n                            // else if the Template Value is a Object\r\n                            else if (!_.isArray(val)) {\r\n                                const layerObj = deepDiff.getDiff(val, templates.Defaults[key]);\r\n                                if (!_.isEmpty(layerObj)) {\r\n                                    diff[key] = layerObj;\r\n                                }\r\n                            }\r\n\r\n                            //if the Template Value is a Array\r\n                            if (_.isArray(val)) {\r\n                                _.each(\r\n                                    val,\r\n                                    _.bind(function(arr, i) {\r\n                                        let v = {};\r\n                                        if (arr && arr._Hidden && arr._Hidden._Type) {\r\n                                            v = deepDiff.getDiff(\r\n                                                arr,\r\n                                                templates[key][arr._Hidden._Type],\r\n                                            );\r\n                                        } else if (\r\n                                            templates[key] !== undefined &&\r\n                                            templates[key][key]\r\n                                        ) {\r\n                                            v = deepDiff.getDiff(arr, templates[key][key]);\r\n                                        } else {\r\n                                            v = arr;\r\n                                        }\r\n                                        diff[key] = diff[key] === undefined ? [] : diff[key];\r\n                                        diff[key].push(v);\r\n                                    }, this),\r\n                                );\r\n                            }\r\n                        }\r\n                    }, this),\r\n                );\r\n            }\r\n            return diff;\r\n        }\r\n\r\n        toJSON(): object {\r\n            const attributes = $.extend(true, {}, this.attributes);\r\n            // Convert any docDataModels to their path\r\n            ComponentOptions.setDataProperties(attributes);\r\n            //Get the diff with the default component JSON if available\r\n            const diff = this.toDiff(attributes);\r\n\r\n            return _.isEmpty(diff) ? attributes : diff;\r\n        }\r\n    }\r\n\r\n    export class Component extends CommandoModel {\r\n        /**\r\n         * Converts dashboardsType objects in options to their corresponding model\r\n         * @param {String} type\r\n         * @param {Object} options Backbone.DeepModel\r\n         */\r\n        public static convertDashboardTypesToModels(\r\n            options,\r\n            getDataModelByPath: (string) => DocumentDataModel,\r\n            getViewModelByPath: (string) => DocumentViewModel,\r\n        ): void {\r\n            const separator = Backbone.DeepModel.keyPathSeparator;\r\n\r\n            if (!options) {\r\n                return;\r\n            }\r\n\r\n            const converters = {\r\n                data: getDataModelByPath,\r\n                viewstate: getViewModelByPath,\r\n            };\r\n\r\n            // convert DeepModel to list of properties in dot syntax\r\n            const properties = options.toFlat(true);\r\n\r\n            const types = _.keys(converters);\r\n\r\n            const propertyCheck = function(value, key): void {\r\n                let model, path;\r\n\r\n                // dashboardsType objects have the form\r\n                // {\r\n                //   '_dashboardsType': 'viewstate',\r\n                //   'path': 'selected'\r\n                // }\r\n\r\n                if (_.isObject(value) && _.includes(types, value[\"_dashboardsType\"])) {\r\n                    path = value[\"value\"];\r\n\r\n                    if (typeof path === \"string\") {\r\n                        model = converters[value[\"_dashboardsType\"]](path);\r\n\r\n                        if (!model) {\r\n                            model = {};\r\n                        }\r\n\r\n                        // ensure correct path is set\r\n                        model.path = path;\r\n\r\n                        // overwrite dashboardsType object with the model\r\n                        options.set(key, model, { silent: true });\r\n                    }\r\n                }\r\n            };\r\n\r\n            _.each(properties, function(value, key) {\r\n                // arrays are not converted to dot syntax by toFlat\r\n                if (_.isArray(value)) {\r\n                    _.each(value, function(arrItem, i) {\r\n                        _.each(arrItem, function(v, k) {\r\n                            // array properties can still be set using dot syntax\r\n                            propertyCheck(v, key + separator + i + separator + k);\r\n                        });\r\n                    });\r\n                } else {\r\n                    propertyCheck(value, key);\r\n                }\r\n            });\r\n        }\r\n\r\n        initialize(): void {\r\n            const appKey = this.get(\"key\");\r\n\r\n            // remove App suffix from key\r\n            // TODO: dashboard upgrade functionality, or save a flag to indicate when this has already been done\r\n            if (appKey && /App$/.test(appKey)) {\r\n                this.set(\"key\", appKey.replace(/App$/, \"\"), { silent: true });\r\n            }\r\n\r\n            this.silentCast(\"options\", ComponentOptions);\r\n            this.silentCast(\"components\", ComponentCollection);\r\n\r\n            this.listenTo(this.get(\"components\"), \"materialChange\", function() {\r\n                this.trigger(\"materialChange\");\r\n            });\r\n\r\n            removeObsoleteWidgets(this.attributes.key, this.attributes);\r\n            this.silentCast(\"widgets\", WidgetCollection);\r\n\r\n            this.listenTo(this.get(\"widgets\"), \"materialChange\", function() {\r\n                this.trigger(\"materialChange\");\r\n            });\r\n\r\n            this.listenTo(this.get(\"options\"), \"materialChange\", this.onOptionsMaterialChange);\r\n        }\r\n\r\n        clone(options?): Component {\r\n            const newComponent = new Component(\r\n                {\r\n                    definitionId: this.get(\"definitionId\"),\r\n                    key: this.get(\"key\"),\r\n                    containerId: this.get(\"containerId\"),\r\n                    components: this.get(\"components\").clone(),\r\n                    widgets: this.get(\"widgets\").clone(),\r\n                },\r\n                {},\r\n                this.parent,\r\n            );\r\n\r\n            options = options || {\r\n                previousWidgetId: this.id,\r\n                widgetId: newComponent.id,\r\n            };\r\n\r\n            newComponent.set(\"options\", this.get(\"options\").clone(options), { silent: true });\r\n\r\n            return newComponent;\r\n        }\r\n\r\n        defaults(): object {\r\n            return {\r\n                id: Helpers.getGUID(),\r\n                key: null,\r\n                options: new ComponentOptions({}, {}, this),\r\n\r\n                containerId: null,\r\n\r\n                // tabs control might have components inside\r\n                components: new ComponentCollection([], {}, this),\r\n                widgets: new WidgetCollection([], {}, this),\r\n            };\r\n        }\r\n\r\n        doCommand(path: Array<string>, todos: Array<Todo>) {\r\n            if (path.length > 0) {\r\n                const key = path.pop();\r\n                if ([\"options\", \"components\", \"widgets\"].indexOf(key) != -1) {\r\n                    return this.get(key).doCommand(path, todos);\r\n                } else {\r\n                    throw \"Unsupported command key\";\r\n                }\r\n            }\r\n\r\n            //TODO: do something its your command\r\n        }\r\n\r\n        getInnermostComponents(key: string) {\r\n            const components = this.get(\"components\");\r\n\r\n            if (components.length > 0 && components.at(0).get(\"key\") === key) {\r\n                return components.at(0).getInnermostComponents(key);\r\n            } else {\r\n                return components;\r\n            }\r\n        }\r\n\r\n        postCommand(sender: object, command: Command) {\r\n            if (sender instanceof ComponentCollection) {\r\n                command.path.push(\"components\");\r\n            } else if (sender instanceof WidgetCollection) {\r\n                command.path.push(\"widgets\");\r\n            } else if (sender instanceof Object) {\r\n                command.path.push(\"options\");\r\n            }\r\n\r\n            command.path.push(this.id);\r\n            return this.parent && this.parent.postCommand(this, command);\r\n        }\r\n\r\n        onOptionsMaterialChange(): void {\r\n            if (!this.get(\"upgrading\")) {\r\n                this.trigger(\"materialChange\");\r\n            }\r\n        }\r\n\r\n        silentCast(key, ObjType, options?): void {\r\n            if (!(this.get(key) instanceof ObjType)) {\r\n                this.set(key, new ObjType(this.get(key), options, this), { silent: true });\r\n            }\r\n        }\r\n\r\n        parseCastAndListen(data, key, ObjType, events, options?): void {\r\n            // if data and data[key] present but not of ObjType\r\n            if (data && data[key] && !(data[key] instanceof ObjType)) {\r\n                // cast\r\n                data[key] = new ObjType(data[key], options, this);\r\n\r\n                // listen to events\r\n                this.listenTo(data[key], events, e => {\r\n                    //console.log(\"document collection changed\", self.id);\r\n                    this.trigger(\"change\", this);\r\n                });\r\n            }\r\n        }\r\n\r\n        parse(data: any): any {\r\n            // cast and listen to modelswState: data['viewState'] });\r\n            this.parseCastAndListen(data, \"components\", ComponentCollection, \"change add remove\");\r\n            this.parseCastAndListen(data, \"options\", ComponentOptions, \"change\");\r\n            removeObsoleteWidgets(this.attributes.key, data);\r\n            this.parseCastAndListen(data, \"widgets\", WidgetCollection, \"change add remove\");\r\n\r\n            return data;\r\n        }\r\n\r\n        setParent(parent): void {\r\n            this.parent = parent;\r\n\r\n            if (this.get(\"components\")) this.get(\"components\").setParent(this);\r\n            if (this.get(\"options\")) this.get(\"options\").setParent(this);\r\n            if (this.get(\"widgets\")) this.get(\"widgets\").setParent(this);\r\n        }\r\n    }\r\n\r\n    class ComponentCollection extends ComandoCollection<Component> {\r\n        descriptor = \"Component\";\r\n\r\n        clone(): this {\r\n            // need to clone each component\r\n            const models = _.map(this.models, function(component) {\r\n                return component.clone();\r\n            });\r\n\r\n            return new ComponentCollection(\r\n                models,\r\n                {\r\n                    model: this.model,\r\n                    comparator: this.comparator,\r\n                },\r\n                this.parent,\r\n            ) as this;\r\n        }\r\n\r\n        getCommandDescriptor(payload?: any): string {\r\n            let descriptor = super.getCommandDescriptor(payload);\r\n            let component;\r\n\r\n            if (_.isArray(payload) && payload.length === 1) {\r\n                component = payload[0];\r\n            } else if (payload instanceof Component) {\r\n                component = payload;\r\n            }\r\n\r\n            if (component instanceof Backbone.Model) {\r\n                descriptor = component.get(\"key\");\r\n            }\r\n\r\n            return descriptor || this.descriptor;\r\n        }\r\n\r\n        setParent(parent: Commandable): void {\r\n            this.parent = parent;\r\n            this.map(c => c.setParent(this));\r\n        }\r\n    }\r\n\r\n    ComponentCollection.prototype.model = Component;\r\n}\r\n","/*global Backbone */\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class ComponentDefinition extends Backbone.Model {\r\n        defaults(): object {\r\n            return {\r\n                listViewThumb: null,\r\n                ghostViewThumb: null,\r\n                buildViewThumb: null,\r\n\r\n                appKey: null,\r\n                appArgs: null,\r\n\r\n                name: null,\r\n                description: null,\r\n            };\r\n        }\r\n    }\r\n\r\n    export class ComponentDefinitionCollection extends Backbone.Collection<ComponentDefinition> {\r\n        model = ComponentDefinition;\r\n    }\r\n}\r\n","/// <reference types=\"backbone\" />\n\nBackbone.emulateHTTP = true;\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class Connection extends Backbone.Model {\n        public get idAttribute(): string {\n            return \"name\";\n        }\n\n        defaults(): object {\n            return {\n                name: \"default\",\n                type: \"q\",\n                host: \"localhost\",\n                port: \"80\",\n                tls: \"false\",\n                user: \"\",\n                password: \"\",\n            };\n        }\n    }\n\n    export class ConnectionCollection extends Backbone.Collection<Connection> {\n        model = Connection;\n    }\n}\n","Backbone.emulateHTTP = true;\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class ConnectionGroup extends Backbone.Model {\n        public get idAttribute(): string {\n            return \"name\";\n        }\n\n        defaults(): object {\n            return {\n                name: \"default\",\n                type: \"kdb\",\n                connections: [],\n                connectionsType: [],\n            };\n        }\n    }\n\n    export class ConnectionGroupCollection extends Backbone.Collection<ConnectionGroup> {\n        model = ConnectionGroup;\n    }\n}\n","/// <reference types=\"backbone\" />\nBackbone.emulateHTTP = true;\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class Service extends Backbone.Model {\n        public get idAttribute(): string {\n            return \"name\";\n        }\n\n        defaults(): object {\n            return {\n                name: \"default\",\n                type: \"q\",\n                host: \"localhost\",\n                port: \"80\",\n                tls: \"false\",\n                user: \"\",\n                password: \"\",\n            };\n        }\n    }\n\n    export class ServiceCollection extends Backbone.Collection<Service> {\n        model = Service;\n    }\n}\n","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class Layout extends CommandoModel {\r\n        IMMATERIAL_ATTRIBUTES = [\"isGridstack\"];\r\n\r\n        constructor(attributes, options, parent: Commandable) {\r\n            super(attributes, options, parent);\r\n            this.parent = parent;\r\n            this.listenTo(this, \"change\", this.determineMaterialChange.bind(this));\r\n        }\r\n\r\n        commandSet(json): void {\r\n            this.postCommand(\r\n                this,\r\n                new Command(\r\n                    \"Set Layout\",\r\n                    [],\r\n                    [new Todo(CommandOp.Set, \"\", json)],\r\n                    [new Todo(CommandOp.Set, \"\", _.clone(this.toJSON()))],\r\n                ),\r\n            );\r\n        }\r\n\r\n        defaults(): object {\r\n            return {\r\n                row: null,\r\n                column: null,\r\n                rowSpan: 12,\r\n                colSpan: 6,\r\n            };\r\n        }\r\n\r\n        determineMaterialChange(): void {\r\n            if (this.changed && !_.isEmpty(_.omit(this.changed, this.IMMATERIAL_ATTRIBUTES))) {\r\n                this.trigger(\"materialChange\");\r\n            }\r\n        }\r\n\r\n        doCommand(path: Array<string>, todos: Array<Todo>): void {\r\n            todos.forEach(t => {\r\n                this.set(t.payload);\r\n            });\r\n            //TODO: do something its your command\r\n        }\r\n\r\n        postCommand(sender: object, command: Command): void {\r\n            return this.parent.postCommand(this, command);\r\n        }\r\n    }\r\n}\r\n","/// <reference types=\"backbone\" />\r\n/// <reference path=\"component.ts\" />\r\n/// <reference path=\"layout.ts\" />\r\n\r\n// Default options for `Collection#set`.\r\nconst setOptions = { add: true, remove: true, merge: true };\r\nconst addOptions = { add: true, remove: false };\r\n\r\n// Splices `insert` into `array` at index `at`.\r\nconst splice = function(array, insert, at) {\r\n    at = Math.min(Math.max(at, 0), array.length);\r\n    const tail = Array(array.length - at);\r\n    const length = insert.length;\r\n    let i;\r\n    for (i = 0; i < tail.length; i++) tail[i] = array[i + at];\r\n    for (i = 0; i < length; i++) array[i + at] = insert[i];\r\n    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];\r\n};\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class Widget extends CommandoModel {\r\n        readonly IMMATERIAL_ATTRIBUTES = [];\r\n\r\n        constructor(attributes, options, parent: Commandable) {\r\n            super(attributes, options, parent);\r\n\r\n            if (this.get(\"layout\") && !(this.get(\"layout\") instanceof Layout)) {\r\n                this.set({ layout: new Layout(this.get(\"layout\"), {}, this) }, { silent: true });\r\n            }\r\n\r\n            if (this.get(\"component\") && !(this.get(\"component\") instanceof Component)) {\r\n                this.set(\r\n                    { component: new Component(this.get(\"component\"), {}, this) },\r\n                    { silent: true },\r\n                );\r\n            }\r\n\r\n            if (this.get(\"component\"))\r\n                this.listenTo(\r\n                    this.get(\"component\"),\r\n                    \"materialChange\",\r\n                    this.onMaterialChange.bind(this),\r\n                );\r\n            if (this.get(\"layout\"))\r\n                this.listenTo(\r\n                    this.get(\"layout\"),\r\n                    \"materialChange\",\r\n                    this.onMaterialChange.bind(this),\r\n                );\r\n\r\n            this.listenTo(this, \"change:component\", this.onComponentChanged.bind(this));\r\n            this.onComponentChanged(this, this.get(\"component\"));\r\n        }\r\n\r\n        clone(widgetIdOverride?: string): Widget {\r\n            const newWidget = new Widget({}, {}, this.parent);\r\n            if (widgetIdOverride) {\r\n                newWidget.set(\"id\", widgetIdOverride);\r\n            }\r\n\r\n            // exclude previous id\r\n            const attributes = _.omit(this.attributes, \"id\");\r\n\r\n            // clone component and layout models\r\n            attributes[\"component\"] = this.get(\"component\").clone({\r\n                previousWidgetId: this.id,\r\n                widgetId: newWidget.id,\r\n            });\r\n            attributes[\"layout\"] = this.get(\"layout\").clone();\r\n\r\n            newWidget.set(attributes);\r\n\r\n            return newWidget;\r\n        }\r\n\r\n        defaults(): object {\r\n            return {\r\n                id: Helpers.getGUID(),\r\n                layout: new Layout({}, {}, this),\r\n                component: null,\r\n            };\r\n        }\r\n\r\n        commandSet(json): void {\r\n            const oldJSON = this.clone(this.id).toJSON();\r\n\r\n            this.postCommand(\r\n                this,\r\n                new Command(\r\n                    \"Set Widget\",\r\n                    [],\r\n                    [new Todo(CommandOp.Set, \"\", json)],\r\n                    [new Todo(CommandOp.Set, \"\", oldJSON)],\r\n                ),\r\n            );\r\n        }\r\n\r\n        doCommand(path: Array<string>, todos: Array<Todo>): void {\r\n            if (path.length > 0) {\r\n                const key = path.pop();\r\n                if ([\"layout\", \"component\"].indexOf(key) !== -1) {\r\n                    return this.get(key).doCommand(path, todos);\r\n                } else {\r\n                    throw \"Unsupported command key\";\r\n                }\r\n            } else {\r\n                todos.forEach(t => {\r\n                    // setting a new component model is the only supported operation\r\n                    if (t.payload.component) {\r\n                        if (t.payload.component instanceof Backbone.Model) {\r\n                            this.set(\"component\", t.payload.component);\r\n                        } else {\r\n                            this.set(\"component\", new Component(t.payload.component, {}, this));\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        postCommand(sender: object, command: Command): void {\r\n            if (sender instanceof Layout) {\r\n                command.path.push(\"layout\");\r\n            } else if (sender instanceof Component) {\r\n                // remove component id\r\n                command.path.pop();\r\n                command.path.push(\"component\");\r\n            }\r\n\r\n            command.path.push(this.id);\r\n            return this.parent.postCommand(this, command);\r\n        }\r\n\r\n        onComponentChanged(model, value, options?): void {\r\n            if (value) {\r\n                this.listenTo(value, \"change\", function(m, v) {\r\n                    this.trigger(\"change\", m, v);\r\n                });\r\n            }\r\n        }\r\n\r\n        onMaterialChange(): void {\r\n            this.trigger(\"materialChange\");\r\n        }\r\n\r\n        setParent(parent): void {\r\n            this.parent = parent;\r\n\r\n            if (this.get(\"component\")) {\r\n                this.get(\"component\").setParent(this);\r\n            }\r\n\r\n            if (this.get(\"layout\")) {\r\n                this.get(\"layout\").setParent(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    export class WidgetCollection extends ComandoCollection<Widget> {\r\n        commandQueue = [];\r\n        descriptor = \"Widget\";\r\n        model = Widget;\r\n\r\n        clone(): this {\r\n            // need to clone each widget\r\n            const models = _.map(this.models, function(widget) {\r\n                return widget.clone();\r\n            });\r\n\r\n            return new WidgetCollection(\r\n                models,\r\n                {\r\n                    model: Widget,\r\n                    comparator: this.comparator,\r\n                },\r\n                this.parent,\r\n            ) as this;\r\n        }\r\n\r\n        commandSet(models: Backbone.Model[]): void {\r\n            const oldJSON = models.map((m, i) => {\r\n                const model = this.get(m.id) || this.at(i);\r\n\r\n                if (model) {\r\n                    const changedAttributes = model.changedAttributes(m);\r\n\r\n                    // create previous attributes taking care to CLONE layout object\r\n                    const previousAttributes = _.mapValues(changedAttributes, (value, key) => {\r\n                        const prop = model.get(key);\r\n                        return prop instanceof Backbone.Model ? prop.toJSON() : prop;\r\n                    });\r\n\r\n                    if (model.id) {\r\n                        previousAttributes.id = model.id;\r\n                    }\r\n\r\n                    return previousAttributes;\r\n                }\r\n            });\r\n\r\n            const c = new Command(\r\n                this.getCommandDescription(CommandOp.Set, models),\r\n                [],\r\n                [new Todo(CommandOp.Set, \"\", models)],\r\n                [new Todo(CommandOp.Set, \"\", oldJSON)],\r\n            );\r\n\r\n            this.postCommand(this, c);\r\n        }\r\n\r\n        doCommandSet(payload): void {\r\n            payload.forEach(w => {\r\n                const widget = this.get(w.id);\r\n                if (widget) {\r\n                    w.component && widget.get(\"component\").set(w.component);\r\n                    w.layout && widget.get(\"layout\").set(w.layout);\r\n                }\r\n            });\r\n        }\r\n\r\n        getCommandDescriptor(payload?): string {\r\n            let descriptor = super.getCommandDescriptor(payload);\r\n            let widget;\r\n\r\n            if (_.isArray(payload) && payload.length === 1) {\r\n                widget = payload[0];\r\n            } else if (payload instanceof Widget) {\r\n                widget = payload;\r\n            }\r\n\r\n            if (widget instanceof Backbone.Model && widget.get(\"component\")) {\r\n                descriptor = widget.get(\"component\").get(\"key\");\r\n            }\r\n\r\n            return descriptor || this.descriptor;\r\n        }\r\n\r\n        setParent(parent: Commandable): void {\r\n            this.parent = parent;\r\n            this.map(w => w.setParent(this));\r\n        }\r\n    }\r\n\r\n    WidgetCollection.prototype.model = Widget;\r\n}\r\n","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Guid extends Vector {\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Guid, dataView, 16);\n        }\n\n        calcRange(): bigint[] {\n            throw \"Not implemented\";\n        }\n\n        hash(i: number): number {\n            // return this.dataView.getFloat64(this.offset + i);\n            throw \"GUID hash not implemented \" + i;\n        }\n\n        getScalar(i: number): bigint {\n            // TODO: should be 128-bit not 64\n            return this.dataView.getBigInt64(this.getByteLocation(i), true);\n        }\n\n        getValue(index: number): string {\n            const UUID_NULL = \"00000000-0000-0000-0000-000000000000\";\n            const start = this.getByteLocation(index),\n                end = start + this.SIZE,\n                x = \"0123456789abcdef\";\n            let s = \"\";\n            for (let i = start; i < end; i++) {\n                const c = this.dataView.getUint8(i);\n                const d = i - start;\n                s += d === 4 || d === 6 || d === 8 || d === 10 ? \"-\" : \"\";\n                s += x[c >> 4];\n                s += x[c & 15];\n            }\n            if (s === UUID_NULL) {\n                return null;\n            }\n\n            return s;\n        }\n    }\n}\n","/// <reference path=\"U8.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Unary extends U8 {\n        constructor(length: number, offset: number, dataView: DataView) {\n            super(length, offset, TypeNum.Unary, dataView);\n        }\n\n        getValue(i: number): number {\n            return this.getScalar(i);\n        }\n    }\n}\n","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Table implements DCDS {\n        public qtype: number;\n        public \"class\" = \"203\";\n        public \"columns\": Array<string> = [];\n        public \"meta\": { [index: string]: number } = {};\n        public \"cols\": { [index: string]: ipc.TypeBase } = {};\n\n        constructor(\n            names?: Array<string>,\n            columns?: Array<qVector | qSymList | qGenericList>,\n            dv?: DataView,\n        ) {\n            if (names !== undefined) {\n                this.columns = names;\n                names.forEach((c, i) => {\n                    this.meta[c] = columns[i].qtype;\n                    this.cols[c] = ipc.Parse.col(columns[i], dv) as Vector | ipc.Symbol;\n                });\n            }\n        }\n\n        static toLegacy(\n            meta: { [index: string]: number },\n            columns: Array<string>,\n            cols: { [index: string]: TypeBase },\n        ): DCDS {\n            const count: number = columns.length > 0 ? cols[columns[0]].length : 0;\n            const rows = new Array(count);\n\n            for (let i = 0; i < count; i++) {\n                const obj = new Object();\n                columns.forEach(c => (obj[c] = cols[c].toLegacy(i)));\n                rows[i] = obj;\n            }\n\n            return {\n                class: \"203\",\n                columns: columns.slice(0),\n                meta: _.clone(meta),\n                rows: rows,\n            };\n        }\n\n        public addColumn(name: string, col: qVector | qSymList | qGenericList, dv: DataView): void {\n            this.columns.push(name);\n            this.meta[name] = col.qtype;\n            this.cols[name] = ipc.Parse.col(col, dv) as Vector | ipc.Symbol | List;\n        }\n\n        public addParsedColumn(name: string, col: TypeBase): void {\n            this.columns.push(name);\n            this.meta[name] = col.qtype;\n            this.cols[name] = col;\n        }\n\n        public merge(table: Table): Table {\n            this.columns = this.columns.concat(table.columns);\n            table.columns.forEach(c => {\n                this.meta[c] = table.meta[c];\n                this.cols[c] = table.cols[c];\n            });\n\n            return this;\n        }\n\n        public toLegacy(): DCDS {\n            return Table.toLegacy(this.meta, this.columns, this.cols);\n        }\n\n        public toViewState(): { _type: \"table\"; value: DCDS } {\n            // TODO: not supporting tables as view states\n            return {\n                _type: \"table\",\n                value: this.toLegacy(),\n            };\n        }\n    }\n\n    Table.prototype.qtype = 98;\n}\n","/// <reference path=\"TypeBase.ts\" />\n/// <reference path=\"Vector.ts\" />\n/// <reference path=\"Byte.ts\" />\n/// <reference path=\"QDate.ts\" />\n/// <reference path=\"Float.ts\" />\n/// <reference path=\"Int.ts\" />\n/// <reference path=\"Minute.ts\" />\n/// <reference path=\"Double.ts\" />\n/// <reference path=\"Short.ts\" />\n/// <reference path=\"Time.ts\" />\n/// <reference path=\"Timestamp.ts\" />\n/// <reference path=\"Boolean.ts\" />\n/// <reference path=\"Char.ts\" />\n/// <reference path=\"DateTime.ts\" />\n/// <reference path=\"Guid.ts\" />\n/// <reference path=\"List.ts\" />\n/// <reference path=\"QLong.ts\" />\n/// <reference path=\"QString.ts\" />\n/// <reference path=\"Month.ts\" />\n/// <reference path=\"Second.ts\" />\n/// <reference path=\"Symbol.ts\" />\n/// <reference path=\"Timespan.ts\" />\n/// <reference path=\"Unary.ts\" />\n/// <reference path=\"Dict.ts\" />\n/// <reference path=\"Table.ts\" />\n/// <reference path=\"../c.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.ipc {\n    export class Parse {\n        public static readonly TYPE_NAMES = [\n            \"list\",\n            \"boolean\",\n            \"guid\",\n            undefined,\n            \"byte\",\n            \"short\",\n            \"int\",\n            \"long\",\n            \"real\",\n            \"float\",\n            \"char\",\n            \"symbol\",\n            \"timestamp\",\n            \"month\",\n            \"date\",\n            \"datetime\",\n            \"timespan\",\n            \"minute\",\n            \"second\",\n            \"time\",\n        ];\n\n        private static readonly VECTOR_COLUMN_CLASSES = [\n            null,\n            Boolean,\n            Guid,\n            null,\n            Byte,\n            Short,\n            Int,\n            QLong,\n            Float,\n            Double,\n            Char,\n            null,\n            Timestamp,\n            Month,\n            QDate,\n            DateTime,\n            Timespan,\n            Minute,\n            Second,\n            Time,\n        ];\n\n        public static col(\n            qStruct: qVector | qSymList | qGenericList | qDict,\n            dataView: DataView,\n        ): TypeBase | Table | Dict {\n            // parse symbols, mixed and unary\n            if (qStruct.qtype === -11) {\n                const qa = qStruct as qAtom;\n                return new Symbol(1, [qa.offset], dataView);\n            } else if (qStruct.qtype === 11) {\n                // is a symbol\n                const sl = qStruct as qSymList;\n                return new Symbol(sl.offsets.length, sl.offsets, dataView);\n            } else if (qStruct.qtype === 0) {\n                // is a generic list\n                const l = qStruct as qGenericList;\n                return new List(l.values, l.end, dataView);\n            } else if (qStruct.qtype === 101) {\n                const qa = qStruct as qAtom;\n                return new Unary(1, qa.offset, dataView);\n            } else if (qStruct.qtype === 98 || qStruct.qtype === 99) {\n                const qa = qStruct as qDict;\n                return Parse.table(qa, dataView);\n            } else if (qStruct.qtype === 101) {\n                const qa = qStruct as qAtom;\n                return new Unary(1, qa.offset, dataView);\n            }\n\n            // get vector class\n            const colFn = Parse.VECTOR_COLUMN_CLASSES[Math.abs(qStruct.qtype)];\n            if (colFn) {\n                if (qStruct.qtype < 0) {\n                    const qa = qStruct as qAtom;\n                    return new colFn(1, qa.offset, dataView);\n                } else {\n                    // other\n                    const bl = qStruct as qVector;\n                    return new colFn(bl.length, bl.offset, dataView);\n                }\n            }\n\n            return null;\n        }\n\n        public static dict(dict: qDict, dataView: DataView): Dict {\n            // parse dictionary\n            const keys = Parse.col(dict.keys as qVector | qSymList | qGenericList, dataView);\n            const values = Parse.col(dict.values as qVector | qSymList | qGenericList, dataView);\n            return new Dict(keys.length, keys, values, dict.qtype);\n        }\n\n        public static flipDict(data: qDict, dv: DataView): Table {\n            const keys = Parse.col(data.keys, dv) as TypeBase;\n            const values = Parse.col(data.values, dv) as TypeBase;\n            return new Table(\n                _.times(keys.length, i => keys.toLegacy(i)),\n                _.times(values.length, i => values.getValue(i)),\n                dv,\n            );\n        }\n\n        public static reshape(qObj: qTyped, buffer: ArrayBuffer): Table {\n            const t = qObj.qtype;\n            const dv = new DataView(buffer);\n\n            if (\n                qObj[\"class\"] ===\n                    \"com.fd.business.querymanager.subscriptions.StreamingSubscription\" ||\n                qObj[\"class\"] === \"210\" ||\n                qObj[\"class\"] === \"207\"\n            ) {\n                return (qObj as unknown) as Table;\n            }\n\n            // get tables out first\n            const ret = Parse.table(qObj, dv);\n            if (ret && ret.qtype === 98) {\n                return ret as Table;\n            }\n\n            const table = new Table();\n\n            // wrap atomic values in a table\n            if (-20 < t && t < 0) {\n                const colName = Parse.TYPE_NAMES[-t] || \"unknown\";\n                table.addColumn(\n                    colName,\n                    t === -11\n                        ? new qSymList(true, [(qObj as qAtom).offset])\n                        : new qVector(-t, true, 1, (qObj as qAtom).offset),\n                    dv,\n                );\n            } else if (t === 99) {\n                // dictionary to table\n                const dict = qObj as qDict;\n                // cast is safe since getRootTable above handles dictionaries\n                table.addColumn(\"Property\", dict.keys as qVector | qSymList | qGenericList, dv);\n                table.addColumn(\"Value\", dict.values as qVector | qSymList | qGenericList, dv);\n            } else if (t === 10) {\n                // string to table\n                const bl = qObj as qVector;\n                table.addColumn(\n                    \"string\",\n                    new qGenericList(true, [bl], bl.offset + bl.length * getTypeSize(bl.qtype)),\n                    dv,\n                );\n            } else if (t === 0) {\n                // generic list to table\n                const gl = qObj as qGenericList;\n                gl.values.forEach((li, i) => {\n                    if (li === null) return;\n                    const col =\n                        (li.qtype === 10\n                            ? \"string\"\n                            : Parse.TYPE_NAMES[Math.abs(li.qtype)] || \"unknown\") + i;\n\n                    // vectorize item\n                    if (li.qtype < 0) {\n                        table.addColumn(\n                            col,\n                            li.qtype === -11\n                                ? new qSymList(true, [(li as qAtom).offset])\n                                : new qVector(-li.qtype, true, 1, (li as qAtom).offset),\n                            dv,\n                        );\n                    } else\n                        table.addColumn(\n                            col,\n                            li.qtype !== 10 && li.qtype <= 19\n                                ? (li as qVector)\n                                : new qGenericList(\n                                      true,\n                                      [li],\n                                      li.qtype === 10\n                                          ? (li as qVector).offset +\n                                            getTypeSize(li.qtype) * (li as qVector).length\n                                          : (li as qAtom).offset,\n                                  ),\n                            dv,\n                        );\n                });\n            } else if (t === 11) {\n                // sym list to table\n                const sl = qObj as qSymList;\n                sl.offsets.forEach((offset, i) => {\n                    table.addColumn(\n                        (Parse.TYPE_NAMES[sl.qtype] || \"unknown\") + i,\n                        new qSymList(true, [offset]),\n                        dv,\n                    );\n                });\n            } else if (0 <= t && t < 20) {\n                // basic list to table\n                const bl = qObj as qVector;\n                const sz = getTypeSize(bl.qtype);\n                for (let i = 0; i < bl.length; i++) {\n                    table.addColumn(\n                        (Parse.TYPE_NAMES[bl.qtype] || \"unknown\") + i,\n                        new qVector(bl.qtype, true, 1, bl.offset + sz * i),\n                        dv,\n                    );\n                }\n            } else if (t === 101) {\n                return table;\n            } else {\n                throw \"Unsupported Root Object\";\n            }\n\n            return table;\n        }\n\n        public static table(qObj: qTyped, dv: DataView): Table | Dict {\n            // TODO: better not call flipDict with Dict, keys or values\n            if (qObj.qtype === 98) {\n                return Parse.flipDict(qObj as qDict, dv);\n            } else if (qObj.qtype === 99) {\n                const dict = qObj as qDict;\n                if (dict.values.qtype === 98) {\n                    if (dict.keys.qtype === 98) {\n                        const a = Parse.flipDict(dict.keys as qDict, dv);\n                        const b = Parse.flipDict(dict.values as qDict, dv);\n                        return a.merge(b);\n                    } else if (dict.keys.qtype === 11 && (dict.values as qDict).keys.qtype === 11) {\n                        const keys = Parse.col((dict.values as qDict).keys as qSymList, dv);\n                        const names = [\"key\"].concat(_.times(keys.length, i => keys.toLegacy(i)));\n                        const cols = Parse.col(\n                            (dict.values as qDict).values as qVector | qSymList | qGenericList,\n                            dv,\n                        );\n                        return new Table(\n                            names,\n                            [dict.keys as qSymList].concat(\n                                _.times(cols.length, i => cols.getValue(i)),\n                            ),\n                            dv,\n                        );\n                    } else {\n                        throw \"Unsupported nested table/dict\";\n                    }\n                } else return Parse.dict(qObj, dv);\n            }\n        }\n    }\n}\n","/// <reference types=\"sharedworker\" >\r\n/// <reference path=\"c.ts\" />\r\n/// <reference path=\"ipc/Parse.ts\" />\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class DashClient {\r\n        public static client: DashClient;\r\n        private static readonly SOCK = \"Socket \";\r\n        private static readonly WORK = \"Worker \";\r\n        private static readonly deltaNameMap: { [index: string]: any } = {\r\n            boolean: ipc.Boolean,\r\n            guid: ipc.Symbol,\r\n            byte: ipc.Byte,\r\n            short: ipc.Short,\r\n            int: ipc.Int,\r\n            long: ipc.QLong,\r\n            real: ipc.Float,\r\n            float: ipc.Double,\r\n            char: ipc.Char,\r\n            symbol: ipc.Symbol,\r\n            timestamp: ipc.Timestamp,\r\n            month: ipc.Month,\r\n            date: ipc.QDate,\r\n            datetime: ipc.DateTime,\r\n            timespan: ipc.Timespan,\r\n            minute: ipc.Minute,\r\n            second: ipc.Second,\r\n            time: ipc.Time,\r\n            string: ipc.QString,\r\n            /*\"list\":\r\n            \"dateRolling\": \r\n            \"datetimeRolling\":\r\n            \"timestampRolling\": \r\n            \"timeRolling\":\r\n            \"minuteRolling\": \r\n            \"secondRolling\": \r\n            \"dict\": \r\n            \"email\": */\r\n        };\r\n\r\n        requests: { [index: string]: DCRequest } = {};\r\n        ws: WebSocket;\r\n        requestId = 1;\r\n        // query: string;\r\n        worker: SharedWorker.SharedWorker | Worker;\r\n        httpOn = false;\r\n        debouncedHeartbeat: Function;\r\n\r\n        constructor(options) {\r\n            DashClient.client = this;\r\n\r\n            // http only means no streams\r\n            this.debouncedHeartbeat = options.httpOnly\r\n                ? _.noop.bind(this)\r\n                : _.debounce(this.heartbeat.bind(this), 15000);\r\n\r\n            // ws only - override http requests\r\n            if (options.httpOn || options.httpOnly) {\r\n                this.httpOn = true;\r\n            }\r\n\r\n            if (!options.noWorker && !options.httpOnly) {\r\n                const workerUrl = requirejs.toUrl(\"worker\") + \".js\";\r\n                Log.Log(DashClient.WORK + workerUrl);\r\n                try {\r\n                    if (window[\"SharedWorker\"] && !(\"FSBL\" in window)) {\r\n                        this.worker = new SharedWorker(workerUrl, options);\r\n                        this.worker.port.onmessage = (e): void => this.onWsMessage(e);\r\n                        this.worker.port.onmessageerror = (e): void => this.onWorkerError(e);\r\n                        this.worker.port.start();\r\n                        this.worker.onerror = (e): void => this.onWorkerError(e);\r\n                    } else {\r\n                        this.worker = new Worker(workerUrl, options);\r\n                        this.worker.onmessage = (e): void => this.onWsMessage(e);\r\n                        this.worker.onerror = (e): void => this.onWorkerError(e);\r\n                    }\r\n                } catch (e) {\r\n                    Log.Log(DashClient.WORK + \"create err\", e);\r\n                    throw e;\r\n                }\r\n            } else if (options.httpOnly) {\r\n                // TODO: yuck get rid of DeltaConnect event\r\n                _.defer(() => this.onOpen(undefined));\r\n            } else this.init();\r\n        }\r\n\r\n        public static createLog(log: string, success: () => void, fail: () => void): void {\r\n            // do nothing\r\n        }\r\n\r\n        public static getQueryData(\r\n            dataSource: string,\r\n            connection: any,\r\n            query: string,\r\n            parameters: any,\r\n            success: FnSuccess,\r\n            error: Function,\r\n            maxRows?: number,\r\n            paging?: any,\r\n            performance?: PerformanceMetrics,\r\n        ): void {\r\n            DashClient.getQueryData2(\r\n                dataSource,\r\n                connection,\r\n                query,\r\n                parameters,\r\n                DashClient.legacyRowCallback(success),\r\n                error,\r\n                maxRows,\r\n                paging,\r\n                performance,\r\n            );\r\n        }\r\n\r\n        public static getQueryData2(\r\n            dataSource: string,\r\n            connection: any,\r\n            query: string,\r\n            parameters: any,\r\n            success: FnSuccess,\r\n            error: Function,\r\n            maxRows?: number,\r\n            paging?: any,\r\n            performance?: PerformanceMetrics,\r\n        ): void {\r\n            if (paging) {\r\n                Log.Error(\"Paging not supported in lite\");\r\n            }\r\n\r\n            if (dataSource === \"sql\") {\r\n                Log.Error(\"SQL not supported in lite\");\r\n            }\r\n\r\n            const paramStr = this.parametersToString(parameters);\r\n            if (paramStr) {\r\n                query = query + \"[\" + paramStr + \"]\";\r\n            }\r\n\r\n            performance && performance.trigger(\"serverStart\");\r\n            DashClient.client.send(\r\n                Op.Query,\r\n                maxRows,\r\n                connection,\r\n                ipc.QString.toIPC(query),\r\n                (data: qTyped, buffer: ArrayBuffer, perf: number[]) => {\r\n                    if (perf && performance) {\r\n                        performance.set(\"serverStart\", perf[0]);\r\n                        performance.set(\"serverEnd\", perf[1]);\r\n                    }\r\n\r\n                    success(data, buffer);\r\n                },\r\n                error,\r\n            );\r\n        }\r\n\r\n        public static parametersToString(parameters: any): string {\r\n            let paramStr = \"\";\r\n            if (!_.isEmpty(parameters)) {\r\n                const vals = [];\r\n                _.each(parameters, (v, k) => {\r\n                    vals.push(RTTI.getByName(v.type).toKDBInput(v.value));\r\n                });\r\n\r\n                //paramStr = \"(`\"+_.keys(parameters).join(\";`\")+\")!(\" + vals.join(\";\")+\")\";\r\n                paramStr = vals.join(\";\");\r\n            }\r\n\r\n            return paramStr;\r\n        }\r\n\r\n        public static parametersToIPC(parameters: any): Uint8Array {\r\n            const params: Array<Uint8Array> = [],\r\n                paramToIPC = p => {\r\n                    const converter = DashClient.deltaNameMap[p.type];\r\n                    if (!converter) throw \"Unsupported param type: \" + p.type;\r\n                    return converter.toIPC(ipc.fromString(converter, p.value));\r\n                };\r\n\r\n            if (!_.isEmpty(parameters)) {\r\n                _.each(parameters, (v, k) => {\r\n                    if (v.type === \"dict\") {\r\n                        params.push(\r\n                            ipc.Dict.toIPC(\r\n                                _.map(v.value, (val, key) => key),\r\n                                ipc.List.toIPC(_.map(v.value, val => paramToIPC(val))),\r\n                            ),\r\n                        );\r\n                    } else if (v.type === \"list\") {\r\n                        params.push(\r\n                            ipc.Symbol.listToIPC(\r\n                                v.value.map(v => (_.isNil(v) ? \"\" : v.toString())),\r\n                            ),\r\n                        );\r\n                    } else {\r\n                        params.push(paramToIPC(v));\r\n                    }\r\n                });\r\n            }\r\n\r\n            return ipc.List.toIPC(params);\r\n        }\r\n\r\n        public static runAnalytic(\r\n            analytic: string,\r\n            connection: string,\r\n            parameters: any,\r\n            callback: Function,\r\n            errorCallback: Function,\r\n            maxRowCount?: number,\r\n            paging?: any,\r\n            perf?: any,\r\n        ): void {\r\n            DashClient.runAnalytic2(\r\n                analytic,\r\n                connection,\r\n                parameters,\r\n                (data: qTyped, buffer: ArrayBuffer) => {\r\n                    const ds = ipc.Parse.reshape(data, buffer);\r\n                    const legacyDs = ds.toLegacy();\r\n                    delete ds.cols;\r\n                    buffer = null;\r\n                    return callback(legacyDs) || {};\r\n                },\r\n                errorCallback,\r\n                maxRowCount,\r\n                null,\r\n                perf,\r\n            );\r\n        }\r\n\r\n        public static runAnalytic2(\r\n            analytic: string,\r\n            connection: string,\r\n            parameters: any,\r\n            success: Function,\r\n            errorCallback: Function,\r\n            maxRowCount?: number,\r\n            paging?: any,\r\n            performance?: PerformanceMetrics,\r\n        ): void {\r\n            if (!parameters || !_.values(parameters).length) {\r\n                parameters = [{ type: \"symbol\", value: null }];\r\n            }\r\n\r\n            const query = this.parametersToIPC(\r\n                [{ type: \"symbol\", value: analytic }].concat(_.values(parameters)),\r\n            );\r\n\r\n            DashClient.client.send(\r\n                Op.Query,\r\n                maxRowCount,\r\n                connection,\r\n                query,\r\n                (data: qTyped, buffer: ArrayBuffer, perf: number[]) => {\r\n                    if (perf && performance) {\r\n                        performance.set(\"serverStart\", perf[0]);\r\n                        performance.set(\"serverEnd\", perf[1]);\r\n                    }\r\n\r\n                    success(data, buffer);\r\n                },\r\n                errorCallback,\r\n            );\r\n        }\r\n\r\n        public static runAPI(\r\n            analytic: string,\r\n            connection: string,\r\n            parameters: any,\r\n            callback: Function,\r\n            errorCallback: Function,\r\n            maxRowCount?: number,\r\n            paging?: any,\r\n            perf?: any,\r\n        ): void {\r\n            if (!parameters || !_.values(parameters).length) {\r\n                parameters = [{ type: \"symbol\", value: null }];\r\n            }\r\n\r\n            const query = this.parametersToIPC(\r\n                [{ type: \"symbol\", value: analytic }].concat(_.values(parameters)),\r\n            );\r\n\r\n            DashClient.client.send(\r\n                Op.API,\r\n                maxRowCount,\r\n                connection,\r\n                query,\r\n                (data: qTyped, buffer: ArrayBuffer) => {\r\n                    const ds = ipc.Parse.reshape(data, buffer);\r\n                    const legacyDs = ds.toLegacy();\r\n                    delete ds.cols;\r\n                    buffer = null;\r\n                    return callback(legacyDs) || {};\r\n                },\r\n                errorCallback,\r\n            );\r\n        }\r\n\r\n        public static getDeltaAnalytics(\r\n            callback: (analytics: any) => void,\r\n            connection: string,\r\n        ): void {\r\n            DashClient.runAnalytic(\r\n                \".api.getFunctions\",\r\n                connection,\r\n                [],\r\n                (data: any) => {\r\n                    return callback(\r\n                        _.map(data.rows, (a: any) => {\r\n                            a.parameters = a.parameters.rows;\r\n                            a.name = \".api.\" + a.name;\r\n                            return a;\r\n                        }),\r\n                    );\r\n                },\r\n                () => {\r\n                    /* do nothing */\r\n                },\r\n            );\r\n        }\r\n\r\n        public static legacyRowCallback(callback) {\r\n            return function(data, bData): void {\r\n                if (callback) {\r\n                    if (bData && bData.byteLength) {\r\n                        if (data.dataSet) {\r\n                            data.dataSet = ipc.Parse.reshape(data.dataSet, bData).toLegacy();\r\n                        } else {\r\n                            data = ipc.Parse.reshape(data, bData).toLegacy();\r\n                        }\r\n\r\n                        callback(data);\r\n                    } else callback(data);\r\n                }\r\n            };\r\n        }\r\n\r\n        //call update query passing in column based dictionaries for updates, called directly from datagrid curently\r\n        // options: {\r\n        //  idCol: '',\r\n        //  addedDict: {},  <-- column based dictionary 'columnName: [LISTOFROWUPDATES]'\r\n        //  updateDict: {},  <-- column based dictionary 'columnName: [LISTOFROWUPDATES]'\r\n        //  deletedDict: {},  <-- column based dictionary 'columnName: [LISTOFROWUPDATES]'\r\n        //  query: '',\r\n        //  connection: ''\r\n        //}\r\n        public static updateTable(options, successCallback, errorCallback): void {\r\n            const localUpdateParam = [];\r\n\r\n            for (let i = 0; i < 3; i += 1) {\r\n                localUpdateParam[i] = {\r\n                    type: \"dict\",\r\n                    value: {},\r\n                    index: i,\r\n                };\r\n            }\r\n\r\n            //populate localUpdateParam array with added, updated, and deleted dictionaries\r\n            _.each(localUpdateParam, function(updateParam, idx) {\r\n                updateParam.index = idx;\r\n            });\r\n\r\n            //added\r\n            _.each(options.addedDict.items, function(dictItem, dictKey) {\r\n                localUpdateParam[0].value[dictKey] = {\r\n                    type: DashClient.updateTableGetListType(options.typeConfig[dictKey], dictItem),\r\n                    value: dictItem,\r\n                };\r\n            });\r\n\r\n            //updated\r\n            _.each(options.updatedDict.items, function(dictItem, dictKey) {\r\n                localUpdateParam[1].value[dictKey] = {\r\n                    type: DashClient.updateTableGetListType(options.typeConfig[dictKey], dictItem),\r\n                    value: dictItem,\r\n                };\r\n            });\r\n\r\n            //deleted\r\n            _.each(options.deletedDict.items, function(dictItem, dictKey) {\r\n                localUpdateParam[2].value[dictKey] = {\r\n                    type: DashClient.updateTableGetListType(options.typeConfig[dictKey], dictItem),\r\n                    value: dictItem,\r\n                };\r\n            });\r\n\r\n            //localUpdateParam.push({\r\n            //    index: 3,\r\n            //    type: 'symbol',\r\n            //    value: options.keyColumn\r\n            //});\r\n\r\n            if (options.updateType === \"analytic\") {\r\n                if (options.updateAnalytic) {\r\n                    DashClient.runAnalytic(\r\n                        options.updateAnalytic,\r\n                        options.connection,\r\n                        localUpdateParam,\r\n                        successCallback,\r\n                        errorCallback,\r\n                    );\r\n                }\r\n            } else {\r\n                DashClient.getQueryData(\r\n                    \"kdb\",\r\n                    options.connection,\r\n                    options.query,\r\n                    localUpdateParam,\r\n                    successCallback,\r\n                    errorCallback,\r\n                );\r\n            }\r\n            // run stored table update query\r\n        }\r\n\r\n        public static updateTableGetListType(kdbType, item): string {\r\n            let charReturnType;\r\n            //set list types for table update\r\n            switch (kdbType) {\r\n                case 0:\r\n                    if (_.isArray(item)) {\r\n                        // list of lists\r\n                        if (_.isBoolean(item[0])) {\r\n                            charReturnType = \"listlistboolean\";\r\n                        } else if (_.isString(item[0])) {\r\n                            charReturnType = \"listliststring\";\r\n                        } else {\r\n                            charReturnType = \"listlistsymbol\";\r\n                        }\r\n                    } else if (_.isString(item)) {\r\n                        // list of characters is a string\r\n                        charReturnType = \"string[]\";\r\n                    } else {\r\n                        // default\r\n                        charReturnType = \"symbol[]\";\r\n                    }\r\n\r\n                    return charReturnType;\r\n                case 1:\r\n                    return \"boolean[]\";\r\n                case 2:\r\n                    //TODO test if this should be uuid\r\n                    return \"guid[]\";\r\n                case 4:\r\n                    return \"byte[]\";\r\n                case 5:\r\n                    return \"short[]\";\r\n                case 6:\r\n                    return \"int[]\";\r\n                case 7:\r\n                    return \"long[]\";\r\n                case 8:\r\n                    return \"real[]\";\r\n                case 9:\r\n                    return \"float[]\";\r\n                case 10:\r\n                    //    return 'char[]';\r\n                    charReturnType = \"char[]\";\r\n\r\n                    _.each(item, function(i) {\r\n                        if (i.length > 1) {\r\n                            charReturnType = \"string[]\";\r\n                        }\r\n                    });\r\n                    return charReturnType;\r\n                case 11:\r\n                    return \"symbol[]\";\r\n                case 12:\r\n                    return \"timestamp[]\";\r\n                case 13:\r\n                    return \"month[]\";\r\n                case 14:\r\n                    return \"date[]\";\r\n                case 15:\r\n                    return \"datetime[]\";\r\n                case 16:\r\n                    return \"timespan[]\";\r\n                case 17:\r\n                    return \"minute[]\";\r\n                case 18:\r\n                    return \"second[]\";\r\n                case 19:\r\n                    return \"time[]\";\r\n                default:\r\n                    return \"symbol[]\";\r\n            }\r\n        }\r\n\r\n        public destroy(): void {\r\n            if (this.ws) {\r\n                try {\r\n                    this.ws.onopen = _.noop.bind(this);\r\n                    this.ws.onclose = _.noop.bind(this);\r\n                    this.ws.onmessage = _.noop.bind(this);\r\n                    this.ws.close();\r\n                    this.ws = null;\r\n                } catch (ex) {\r\n                    // do nothing\r\n                    this.ws = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        public send(\r\n            op: Op.API | Op.Query | Op.Subscribe,\r\n            maxRows: number,\r\n            connectionId: string,\r\n            query: Uint8Array,\r\n            success: (data: object, buffer: ArrayBuffer, perf: Array<number>) => void,\r\n            error: Function,\r\n        ): number {\r\n            return this.sendMessage(\r\n                new DCRequest(\r\n                    op,\r\n                    connectionId,\r\n                    ipc.List.toIPC([ipc.Int.toIPC(maxRows || 2147483647), query]),\r\n                    success,\r\n                    error,\r\n                ),\r\n            );\r\n        }\r\n\r\n        public subscribe(\r\n            maxRows: number,\r\n            query: string,\r\n            connectionId: string,\r\n            success: (data: object, buffer: ArrayBuffer, perf: Array<number>) => void,\r\n            error: Function,\r\n            parameters?: any,\r\n        ): number {\r\n            if (parameters === undefined) {\r\n                let symbols;\r\n                const rxA = /^\\((`\\$\"([^\"]+)\")(;`\\$\"([^\"]+)\")*\\)$/gm;\r\n                const rxB = /^(`[a-zA-Z]\\w+)+$/gm;\r\n                const symA = /`\\$\"([^\"]+)\"/g;\r\n\r\n                // if match extract symbol list or error\r\n                if (query.match(rxA)) {\r\n                    symbols = query.match(symA).map(s => s.substring(3, s.length - 1));\r\n                } else if (query.match(rxB)) {\r\n                    symbols = query.match(rxB).map(s => s.substring(1, s.length));\r\n                } else {\r\n                    error('Enter stream query as a symbol list in the form: (`$\"symA\";`$\"symB\")');\r\n                    return;\r\n                }\r\n\r\n                query = symbols[0];\r\n                parameters = (symbols.length > 1 ? symbols.slice(1) : []).map(s => {\r\n                    return { type: \"symbol\", value: s };\r\n                });\r\n            }\r\n\r\n            // only one parameter is ever specified\r\n            const parameter: any = _.first(parameters);\r\n            // stream parameter is only ever input as a sym, or symlist\r\n            // if sym is null send null\r\n            // if sym is not null or a symlist is specified send symlist\r\n            const payload = ipc.List.toIPC([\r\n                ipc.Symbol.toIPC(query),\r\n                !parameter || _.isEmpty(parameter.value)\r\n                    ? ipc.Symbol.toIPC(null)\r\n                    : parameter.type === \"list\"\r\n                    ? ipc.Symbol.listToIPC(\r\n                          parameter.value.map(v => (_.isNil(v) ? \"\" : v.toString())),\r\n                      )\r\n                    : DashClient.parametersToIPC([parameter]),\r\n            ]);\r\n\r\n            // use negative maxrows for subscription to get last rows from snapshot\r\n            return this.send(Op.Subscribe, -maxRows, connectionId, payload, success, error);\r\n        }\r\n\r\n        public unsubscribe(requestId: number): void {\r\n            delete this.requests[requestId];\r\n            this.sendMessage(\r\n                new DCRequest(Op.Unsubscribe, null, null, _.noop.bind(this), _.noop.bind(this)),\r\n                requestId,\r\n            );\r\n        }\r\n\r\n        private addOptionalRequestParams(params: any[], request: DCRequest): void {\r\n            if (request.connectionId) {\r\n                params.push(ipc.Symbol.toIPC(request.connectionId));\r\n\r\n                if (request.query) {\r\n                    params.push(\r\n                        typeof request.query === \"string\"\r\n                            ? ipc.Char.listToIPC(request.query.split(\"\"))\r\n                            : request.query instanceof Array\r\n                            ? ipc.Symbol.listToIPC(request.query)\r\n                            : (request.query as Uint8Array),\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        private heartbeat(): void {\r\n            if (this.ws) {\r\n                this.sendMessage(new DCRequest(Op.Heartbeat));\r\n            } else {\r\n                this.init();\r\n            }\r\n        }\r\n\r\n        private init(): void {\r\n            try {\r\n                const wsUrl =\r\n                    location.protocol === \"file:\"\r\n                        ? \"ws://localhost:10001/\"\r\n                        : (\"https:\" === location.protocol ? \"wss://\" : \"ws://\") +\r\n                          location.host +\r\n                          location.pathname.replace(/(\\/|\\/edit\\/?)?(index.html)?$/, \"\");\r\n\r\n                Log.Log(DashClient.SOCK + wsUrl);\r\n                this.ws = new WebSocket(wsUrl);\r\n                this.ws.binaryType = \"arraybuffer\";\r\n                this.ws.onopen = this.onWsOpen.bind(this);\r\n                this.ws.onclose = this.onWsClose.bind(this);\r\n                this.ws.onerror = this.onWsError.bind(this);\r\n                this.ws.onmessage = this.onWsMessage.bind(this);\r\n            } catch (e) {\r\n                Log.Log(DashClient.SOCK + \"Create Err\", e);\r\n            }\r\n\r\n            this.debouncedHeartbeat();\r\n        }\r\n\r\n        private sendMessage(request: DCRequest, requestId?: number): number {\r\n            requestId = requestId || this.requestId++;\r\n            this.requests[requestId] = request;\r\n\r\n            if (this.worker && !(this.httpOn && [Op.API, Op.Query].indexOf(request.op) !== -1)) {\r\n                const params = [requestId, request.op];\r\n                this.addOptionalRequestParams(params, request);\r\n                if (window[\"SharedWorker\"] && !(\"FSBL\" in window)) {\r\n                    (this.worker as SharedWorker.SharedWorker).port.postMessage(params);\r\n                } else {\r\n                    (this.worker as Worker).postMessage(params);\r\n                }\r\n            } else {\r\n                const params = [\r\n                    ipc.Int.toIPC(this.httpOn ? 0 : requestId),\r\n                    ipc.Int.toIPC(request.op),\r\n                ];\r\n\r\n                this.addOptionalRequestParams(params, request);\r\n\r\n                if (this.httpOn) {\r\n                    const xhr: XMLHttpRequest = new XMLHttpRequest();\r\n\r\n                    // progress handler\r\n                    xhr.onprogress = (oEvent): void => {\r\n                        if (oEvent.lengthComputable) {\r\n                            const percentComplete = (oEvent.loaded / oEvent.total) * 100;\r\n                            Log.Log(\"DashClient download: \" + percentComplete + \"%\");\r\n                        } else {\r\n                            // Unable to compute progress information since the total size is unknown\r\n                        }\r\n                    };\r\n\r\n                    // onload handler\r\n                    xhr.onload = (): void => {\r\n                        if (xhr.response && (xhr.response as ArrayBuffer).byteLength > 20) {\r\n                            const dv = new DataView(xhr.response);\r\n                            dv.setInt32(15, requestId, true);\r\n                            this.onWsMessage({ data: xhr.response } as MessageEvent);\r\n                        } else\r\n                            this.onWsMessage({\r\n                                data: [Op.Error, \"Invalid response\"],\r\n                            } as MessageEvent);\r\n                    };\r\n\r\n                    // open and send\r\n                    const msg = ipc.Util.toMessage(ipc.List.toIPC(params));\r\n                    if (msg.byteLength < 2048) {\r\n                        xhr.open(\r\n                            \"GET\",\r\n                            location.protocol +\r\n                                \"//\" +\r\n                                location.host +\r\n                                \"/api/\" +\r\n                                btoa(\r\n                                    msg.reduce(\r\n                                        (data, byte) => data + String.fromCharCode(byte),\r\n                                        \"\",\r\n                                    ),\r\n                                ).replace(/\\//g, \"+\"),\r\n                            true,\r\n                        );\r\n                        xhr.responseType = \"arraybuffer\";\r\n                        xhr.send();\r\n                    } else {\r\n                        xhr.open(\"POST\", location.protocol + \"//\" + location.host + \"/api/\", true);\r\n                        xhr.responseType = \"arraybuffer\";\r\n                        xhr.send(msg);\r\n                    }\r\n                } else if (this.ws && this.ws.readyState === WebSocket.OPEN) {\r\n                    this.ws.send(ipc.Util.toMessage(ipc.List.toIPC(params)));\r\n                    this.debouncedHeartbeat();\r\n                }\r\n            }\r\n\r\n            return requestId;\r\n        }\r\n\r\n        private onDisconnect(e): void {\r\n            Log.Log(\"DashClient Disconnect\", e);\r\n            $(this).trigger(\"DeltaClientDisconnect\", e);\r\n        }\r\n\r\n        private onOpen(e): void {\r\n            Log.Log(\"DashClient Connect\");\r\n            $(this).trigger(\"DeltaClientConnect\");\r\n            Log.Log(\"DashClient Login\");\r\n            $(this).trigger(\"DeltaClientLogin\");\r\n        }\r\n\r\n        private onWorkerError(e): void {\r\n            Log.Log(DashClient.WORK + \"error\", e);\r\n            this.onDisconnect(e);\r\n        }\r\n\r\n        private onWsClose(e: CloseEvent): void {\r\n            Log.Log(DashClient.SOCK + \"Closed\", e);\r\n            //this.onStateChangeFn(this.ws ? this.ws.readyState : WebSocket.CLOSED, e);\r\n            this.destroy();\r\n        }\r\n\r\n        private onWsError(e: Event): void {\r\n            Log.Log(DashClient.SOCK + \"Error\", e);\r\n            this.onDisconnect(e);\r\n            this.destroy();\r\n        }\r\n\r\n        private onWsMessage(e: MessageEvent): void {\r\n            // pick up state and connection errors from worker\r\n            if (e.data instanceof Array) {\r\n                if (e.data[0] === Op.State) {\r\n                    if (e.data[1] === WebSocket.OPEN) {\r\n                        this.onOpen(null);\r\n                    } else this.onWorkerError(e.data[2] || \"ws not open\");\r\n                    return;\r\n                } else if (e.data[0] === Op.Error) {\r\n                    return this.onWorkerError(e.data[1]);\r\n                }\r\n            }\r\n\r\n            const response = deserialize(e.data, 8, true) as Array<any>;\r\n            //console.log(x);\r\n            // kdb Q: for some strange reason the 2nd query always return error type - so destroy to start a new\r\n            //this.destroy();\r\n            const key = response[0];\r\n            const mtype = response[1];\r\n            const request = this.requests[key];\r\n\r\n            // remove request unless subscription\r\n            if (request) {\r\n                if (request.op !== Op.Subscribe) {\r\n                    delete this.requests[key];\r\n                }\r\n\r\n                if (\r\n                    request.op === Op.Query ||\r\n                    request.op === Op.API ||\r\n                    request.op === Op.Subscribe\r\n                ) {\r\n                    if (mtype === Op.Error) {\r\n                        const errData: qVector = response[2];\r\n                        debugger;\r\n                        request.error(\r\n                            u16u8(new Uint8Array(e.data, errData.offset, errData.length)),\r\n                        );\r\n                    } else {\r\n                        // if worker use timestamp from bytelocation 0\r\n                        const endTime =\r\n                            this.httpOn && request.op !== Op.Subscribe\r\n                                ? Date.now()\r\n                                : new Float64Array(e.data, 0, 1)[0];\r\n                        request.success(response[2] || {}, e.data, [request.timestamp, endTime]);\r\n                    }\r\n                }\r\n            } else {\r\n                Log.Warn('Stray Response \"' + key + '\"');\r\n            }\r\n        }\r\n\r\n        private onWsOpen(e: Event): void {\r\n            console.log(\"websocket open\", e);\r\n            if (this.ws.readyState === WebSocket.OPEN) {\r\n                Log.Log(DashClient.SOCK + \"Open\", e);\r\n                this.onOpen(e);\r\n            } else {\r\n                Log.Log(DashClient.SOCK + \"Open Error\", e);\r\n                this.onDisconnect(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class PerformanceMetrics {\n        private perf: { [index: string]: number } = {};\n\n        public trigger(trigger: string): void {\n            this.perf[trigger] = Date.now();\n        }\n\n        public set(key: string, val: number): void {\n            this.perf[key] = val;\n        }\n\n        get performance(): { [index: string]: number } {\n            return this.perf;\n        }\n    }\n}\n","/*global _,$,console */\n/// <reference path=\"../classes/log.ts\"/>\n/// <reference path=\"../classes/PerformanceMetrics.ts\"/>\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export interface Subscriber {\n        onData(meta, data, error, performanceMetrics?: PerformanceMetrics);\n    }\n\n    export class Agent {\n        private legacySubscribers: { [index: string]: Subscriber } = {};\n        private rawSubscribers: { [index: string]: Subscriber } = {};\n\n        public notifyAllLegacyChange(\n            meta: any,\n            data: any,\n            error?: any,\n            performanceMetrics?: PerformanceMetrics,\n        ): void {\n            _.each(this.legacySubscribers, s =>\n                this.notifyChange(s, meta, data, error, performanceMetrics),\n            );\n        }\n\n        public notifyAllRawChange(\n            meta: any,\n            data: any,\n            error?: any,\n            performanceMetrics?: PerformanceMetrics,\n        ): void {\n            _.each(this.rawSubscribers, s =>\n                this.notifyChange(s, meta, data, error, performanceMetrics),\n            );\n        }\n\n        public notifyChange(\n            subscriber: Subscriber,\n            meta,\n            data,\n            error?,\n            performanceMetrics?: PerformanceMetrics,\n        ): void {\n            this.callSubscriber(\n                subscriber,\n                subscriber.onData,\n                meta,\n                data,\n                error,\n                performanceMetrics,\n            );\n        }\n\n        public getSubscribers(): string[] {\n            return _.union(_.keys(this.legacySubscribers), _.keys(this.rawSubscribers)) || [];\n        }\n\n        public subscribe(key: string, subscriber: Subscriber, raw: boolean): boolean {\n            const subscribers = raw ? this.rawSubscribers : this.legacySubscribers;\n            if (!subscribers[key]) {\n                subscribers[key] = subscriber;\n                return true;\n            }\n\n            return false;\n        }\n\n        public subscriberCount(): number {\n            return this.subscriberLegacyCount() + this.subscriberRawCount();\n        }\n\n        public subscriberLegacyCount(): number {\n            return _.keys(this.legacySubscribers).length;\n        }\n\n        public subscriberRawCount(): number {\n            return _.keys(this.rawSubscribers).length;\n        }\n\n        public unsubscribe(key: string): boolean {\n            if (this.legacySubscribers[key]) {\n                delete this.legacySubscribers[key];\n                return true;\n            }\n\n            if (this.rawSubscribers[key]) {\n                delete this.rawSubscribers[key];\n                return true;\n            }\n\n            return false;\n        }\n\n        public unsubscribeAll(): boolean {\n            this.legacySubscribers = {};\n            this.rawSubscribers = {};\n            return true;\n        }\n\n        private callSubscriber(\n            subscriber: Subscriber,\n            func: Function,\n            meta: any,\n            data: any,\n            error: any,\n            performanceMetrics: PerformanceMetrics,\n        ): void {\n            if (func) {\n                try {\n                    func.apply(subscriber, Array.prototype.slice.call(arguments, 2));\n                } catch (exception) {\n                    this.onSubscriberError(subscriber, exception);\n                }\n            }\n        }\n\n        private onSubscriberError(subscriber: Subscriber, exception: any): void {\n            Log.Error(\"ERROR: Subscriber error!\", exception);\n        }\n    }\n}\n","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export interface ChangeSetInterface {\n        /**\n         * A full new set of the rows\n         */\n        reset: object[];\n\n        /**\n         * Rows that have been added in this change\n         */\n        add: object[];\n\n        /**\n         * Rows that have been changed in this change\n         */\n        change: object[];\n\n        /**\n         * Rows that have been removed in this change\n         */\n        remove: object[];\n\n        /**\n         * The columns available for this data\n         */\n        cols: { [index: string]: ipc.TypeBase };\n\n        /**\n         * Assign a collection to this changeSet\n         */\n        assign(collection: Backbone.Collection): void;\n\n        /**\n         * Get all rows\n         */\n        items(): object[];\n    }\n}\n","/// <reference path=\"../classes/Agent.ts\"/>\n\ninterface ErrorInterface {\n    /**\n     * Error message\n     */\n    error: string;\n    /**\n     * Options\n     */\n    options: object;\n    /**\n     * Type of error\n     */\n    type: string;\n}\n\ninterface PagingInfoInterface {\n    /**\n     * Lazy loading\n     */\n    _lazyLoading: boolean;\n    /**\n     * Force reset\n     */\n    _forceReset: boolean;\n    /**\n     * Number of rows per page\n     */\n    _pageSize: number;\n    /**\n     * Columns to sort by\n     */\n    _pageSort: object;\n    /**\n     * Page or offset number\n     */\n    _pagingNum: number;\n    /**\n     * Type of paging - \"OFFSET\", \"OFFSET_NOCACHE\", \"PAGENO\", \"PAGENO_NOCACHE\"\n     */\n    _pagingType: string;\n    /**\n     * Perform paging on the server\n     */\n    _serverPaging: boolean;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export interface DataModelInterface {\n        /*\n         * toJSON override is necessary to prevent all of the data\n         * contained within the data type models from being serialized.\n         * - only the definition properties prefixed with '_' are\n         *   saved\n         */\n        toJSON(): Record<string, any>;\n\n        /**\n         * Method to apply data, runs through each case: pivot, query, analytic, copy, virtual\n         */\n        apply(): void;\n\n        /**\n         * Get Meta\n         * @param callback\n         */\n        getMeta(callback): void;\n\n        /**\n         * Get viewstate\n         */\n        getViewState(): any;\n\n        /**\n         * Get datasource parameters\n         */\n        getParameters(): Record<string, any>;\n\n        /**\n         * Subscribe to data\n         * @param {String} key\n         * @param {Subscriber} listener\n         * @param {boolean} raw\n         * @param {any} pagingInfo\n         */\n        subscribe(\n            key: string,\n            listener: Subscriber,\n            raw?: boolean,\n            pagingInfo?: PagingInfoInterface,\n        ): void;\n\n        /**\n         * Unsubscribe to data\n         * @param {String} key\n         */\n        unsubscribe(key): void;\n\n        /**\n         * on Successful datasource execution\n         * @param {DCDS} data\n         * @param {boolean} forceReset\n         * @param {ArrayBuffer} buffer\n         * @param { [index: string]: number } pivotMeta\n         */\n        onExecuteSuccess(\n            data: DCDS,\n            forceReset: boolean,\n            buffer?: ArrayBuffer,\n            pivotMeta?: { [index: string]: number },\n        );\n\n        /**\n         * Begin datasource execution\n         */\n        onExecuteBegin(): void;\n\n        /**\n         *\n         * @param {String} path\n         * @returns {DocumentDataModel}\n         */\n        getByPath(path: string): DataModelInterface;\n    }\n}\n","/// <reference path=\"DataModelInterface.ts\"/>\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export interface ViewModelInterface {\n        /**\n         * @param {String} path\n         * @returns {ViewModelInterface}\n         */\n        getByPath(path: string): ViewModelInterface;\n\n        /*\n         * toJSON override is necessary to prevent all of the data\n         * contained within the data type models from being serialized.\n         * - only the definition properties prefixed with '_' are\n         *   saved\n         */\n        toJSON(withAllProperties): Record<string, any>;\n\n        /**\n         * Get viewstates\n         * @param {String} root\n         * @param {String} path\n         * @param {boolean} includeSettings\n         */\n        getViewStates(root, path?: string, includeSettings?: boolean): void;\n\n        /**\n         * Get viewstate list\n         * @param {boolean} includeSettings\n         */\n        getViewStateList(includeSettings?: boolean): void;\n\n        /**\n         * Change to viewstate\n         */\n        onChange(): void;\n\n        /**\n         * Parse data\n         * @param data\n         */\n        parse(data): Record<string, any>;\n    }\n}\n","/// <reference path=\"ChangeSetInterface.ts\"/>\n/// <reference path=\"DataModelInterface.ts\"/>\n/// <reference path=\"ViewModelInterface.ts\"/>\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export interface ComponentInterface {\n        /**\n         * Remove entry for current component in .settings\n         */\n        destroySettings(): void;\n\n        /**\n         * Execute the actions provided by the actions editor from PropertiesPanel\n         * @param {Array} actions\n         */\n        doActions(actions, propertyPath): void;\n\n        /**\n         * Export the full dataset from a datasource, using DeltaClient ExportApi.export\n         * @param {Object} source\n         * @param {Object} callback - called with url to file\n         * @param {Object} options - e.g. can include focus for pivot queries\n         */\n        exportData(\n            source: Record<string, any>,\n            callback: Record<string, any>,\n            options: Record<string, any>,\n        ): void;\n\n        /**\n         * Returns property value for a given path: onSettingsChange will keep a component updated with changes to its properties (including changes to any underlying bound view states) so getProperty is normally not necessary, assuming the component keeps a store of the changes. However, if required, a component can retrieve the current value of a property using getProperty.\n         * @param {String} path\n         * The path of the property.\n         * @returns {Object} Value of the property. If the property is bound to a view state the value of the view state will be returned instead.\n         */\n        getProperty(path: string): Record<string, any>;\n\n        /**\n     * Returns property information for a given path: If more information about a property is required, use getPropertyMeta.\n     * @param {String} path\n     * The path of the property.\n     * @returns {Object} Property information: An object containing information about the property and, if applicable, its underlying view state. The response differs depending on the value set in the property.\n\n    Generic object properties are:\n    path - path to the property\n    type - type of the property, if it contains a data source or viewstate (data, viewstate or null)\n\n    If the property is a simple property or if it is bound to a view state the object also contains:\n    value - value of the property\n\n    If the property is bound to a view state the object also contains:\n    viewstateType - type of the underlying view state (symbol, int, etc)\n    defaultValue - default value of the underlying view state\n     */\n        getPropertyMeta(path: string): Record<string, any>;\n\n        /**\n         * Get Data Source mapping\n         * @param viewStatePaths\n         * @param dataSourcePaths\n         * @param propertyViewStates\n         */\n        getDataSourceMap(viewStatePaths, dataSourcePaths, propertyViewStates);\n\n        /**\n         * Get the value of a given viewstate model\n         * @param {ViewModelInterface} viewState {@link ViewModelInterface | ViewModelInterface}\n         * : Viewstate Model\n         * @returns {String} The value of the model\n         */\n        getViewState(viewState: ViewModelInterface): string;\n\n        /**\n         * Extract view states from template and pass back their values\n         * @param {String} template\n         */\n        getTemplateViewStates(template: string): void;\n\n        /**\n         * Hides the Dashboards error message on the component\n         */\n        hideErrorMessage(): void;\n\n        /**\n         * Hide query status\n         */\n        hideQueryStatus();\n\n        /**\n         * Determines if the dashboard is in build mode\n         * @returns {Boolean} True if in build mode\n         */\n        isBuildMode(): boolean;\n\n        /**\n         * Determines if the component is selected\n         * @returns {Boolean} True if the component is selected\n         */\n        isSelected(): boolean;\n\n        /**\n         * Load a given app using requireJS and pass it a new API interface\n         * @param {String} key\n         * @param {Object} element\n         * @param {Object} settings - either a Backbone model or an object containing the new app's settings\n         * @param {Object} options - an object of options to pass to the app initialize function\n         * @returns {Object} appView\n         */\n        loadApp(\n            key: string,\n            element: Record<string, any>,\n            settings: Record<string, any>,\n            options: Record<string, any>,\n            callback,\n            namespace,\n        ): void;\n\n        /**\n         * Load a setting from the .settings viewstate\n         * @param {String} key\n         * @returns {String} Value\n         */\n        loadSetting(key: string, namespace): string;\n\n        /**\n         * Navigate to a given dashboard/screen\n         * @param {String|Object} options\n         * Either a dashboard name or an object containing target dashboard, screen and/or viewstate parameters to pass\n         * @returns {Number}\n         */\n        navigate(options: string | Record<string, any>): void;\n\n        /**\n         * Page a given data source\n         * @param {Object} source\n         */\n        page(source: Record<string, any>, options);\n\n        /**\n         * Save a setting to the .settings viewstate\n         * @param {String} key\n         * @param {String} value\n         */\n        saveSetting(key: string, value: string, namespace);\n\n        /**\n     * Set the property at path to the given value: Most properties can optionally be bound to a view state by the user. If this is done, onSettingsChange will pass the value of the view state to the component, i.e. the component does not need to check if a property has been bound to a view state or not, it simply works off the value given by onSettingsChange. If the view state value is updated elsewhere in Dashboards, the new value will be passed to the component via onSettingsChange.\n\n    To set the value of these view states, use setProperty.\n     * @param {String} path\n     * The path of the property to set. If that property has been bound to a view state by the user, then the value of that view state will be set instead.\n     * @param {*} value\n     * The value to set the property to.\n     */\n        setProperty(path: string, value: any, options?: any): void;\n\n        /**\n         * Set the value of the given viewstate model\n         * @param {ViewModelInterface} viewState {@link ViewModelInterface | ViewModelInterface}\n         * : Viewstate Model\n         * @param {*} value\n         * @returns {Boolean}\n         */\n        setViewState(viewState: ViewModelInterface, value): boolean;\n\n        /**\n         * Show a Dashboards error message on the component\n         * @param errorObj\n         * An object containing the error information: Error (description of the error) & Type (One of 'Error', 'Warning', 'Info')\n         */\n        showErrorMessage(errorObj: Record<string, any>);\n\n        /**\n         * Show notification\n         * @param visualConfig\n         * @param soundConfig\n         */\n        showNotification(visualConfig?: any, soundConfig?: any);\n\n        /**\n         * Show Query Status\n         * @param errorObj\n         */\n        showQueryStatus(errorObj);\n\n        /**\n         * Subscribe to a given source\n         * @param {DataModelInterface} source\n         * The data source to subscribe to. A data source can be retrieved from onSettingsChange as follows (this example assumes it is a data property called Data in a category called Basics)\n         * @param {ComponentApi~sourceCallback} callback\n         * callback is a function that will be called when there is a data update.\n         */\n        subscribe(\n            source: DataModelInterface,\n            callback: (\n                meta: ChangeSetInterface,\n                data: ChangeSetInterface,\n                error: ErrorInterface,\n            ) => void,\n            raw?: boolean,\n            pagingInfo?: PagingInfoInterface,\n        ): void;\n\n        /**\n         * Extract view states from template and pass their values to callback\n         * @param {String} template\n         * @param {ComponentApi~sourceCallback} callback\n         */\n        subscribeTemplateViewStates(\n            template: string,\n            callback: (viewStates: object) => void,\n        ): string;\n\n        /**\n         * Unsubscribe from a given source\n         * @param {DataModelInterface} source\n         * : Data source\n         */\n        unsubscribe(source: DataModelInterface): void;\n\n        /**\n         * @param {String} subscriptionId\n         */\n        unsubscribeTemplateViewStates(subscriptionId: string): void;\n\n        /**\n         * Updates the table in kdb\n         * @param {String} source\n         * @param {Object} options\n         * @param {Function} successFunc - success callback\n         * @param {Function} errorFunc - error callback\n         * @returns undefined\n         */\n        updateTable(\n            source: string,\n            options: Record<string, any>,\n            successFunc: Function,\n            errorFunc: Function,\n        ): void;\n    }\n}\n","/*global _,$,console,Backbone */\n/// <reference path=\"../classes/log.ts\"/>\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    var DataSet_ROW_INDEX = \"_rowIndex\";\n\n    export class DataMapper {\n        columns: Array<string>;\n        data: object;\n        mappings: Backbone.Collection<Backbone.Model>;\n        model: Backbone.Model;\n        setDataModelMappings: Function;\n        subscribe: Function;\n        subscribed: boolean;\n        unsubscribe: Function;\n        subscriptionKey: string;\n        viewState: DocumentViewModel;\n\n        trigger(eventName: string, ...args: any[]): any {\n            return;\n        }\n        listenTo(object: any, events: string, callback: Function): any {\n            return;\n        }\n        stopListening(object?: any, events?: string, callback?: Function): any {\n            return;\n        }\n\n        constructor(options) {\n            const obj = options.mappings || {};\n\n            this.setDataModelMappings = options.setMappings;\n            this.subscriptionKey = _.uniqueId(\"mapper_\");\n            this.subscribe = options.subscribe;\n            this.subscribed = false;\n            this.unsubscribe = options.unsubscribe;\n            this.viewState = options.viewState;\n\n            this.model = new Backbone.Model({\n                key: obj.key || \"\",\n                value: obj.value || \"\",\n            });\n\n            this.mappings = new Backbone.Collection(\n                _.map(obj.mappings, (viewstate, key) => {\n                    return new Backbone.Model({\n                        key: key,\n                        value: \"\",\n                        viewstate:\n                            viewstate && viewstate._dashboardsType\n                                ? this.viewState.getByPath(obj.mappings[key].value)\n                                : viewstate,\n                    });\n                }) || [],\n            );\n\n            _.extend(this, Backbone.Events);\n        }\n\n        public initialize() {\n            this.setSubscription();\n            this.initializeEvents();\n        }\n\n        private initializeEvents() {\n            this.listenTo(this.mappings, \"add reset remove\", this.onMappingsCollectionChange);\n            this.listenTo(this.mappings, \"change:key\", this.onMappingItemKeyChange);\n            this.listenTo(this.mappings, \"change:viewstate\", this.onMappingItemViewStateChange);\n            this.listenTo(this.model, \"change:key\", this.onMappingKeyChange);\n            this.listenTo(this.model, \"change:value\", this.onMappingValueChange);\n        }\n\n        public addMapping() {\n            const possibleKeys = this.getPossibleKeys();\n\n            const unusedKeys = _.difference(\n                possibleKeys,\n                this.mappings.map(mapping => {\n                    return mapping.get(\"key\");\n                }),\n            );\n\n            const key = unusedKeys ? unusedKeys[0] : possibleKeys[0] || \"\";\n\n            // try to find a viewstate with name matching the key\n            const viewState = _.isString(key) ? this.viewState.getByPath(key) : \"\";\n\n            this.mappings.add({\n                key: key,\n                value: this.getValue(key),\n                viewstate: viewState || \"\",\n            });\n        }\n\n        public cleanUp() {\n            this.stopListening();\n            this.mappings.reset();\n            this.setSubscription();\n        }\n\n        private generateValues() {\n            this.mappings.each(\n                function(model) {\n                    model.set(\"value\", this.getValue(model.get(\"key\")));\n                }.bind(this),\n            );\n        }\n\n        public getColumns() {\n            return this.columns || [];\n        }\n\n        public getPossibleKeys() {\n            return this.data ? _.keys(this.data) : [];\n        }\n\n        public getValue(key) {\n            return this.data ? this.data[key] : undefined;\n        }\n\n        onData(meta, data, buffer?) {\n            let key = this.model.get(\"key\"),\n                valKey = this.model.get(\"value\"),\n                n,\n                rows,\n                ds = {},\n                mapping = [],\n                currentMapping = this.mappings.reduce((map, model) => {\n                    map[model.get(\"key\")] = model.get(\"viewstate\");\n                    return map;\n                }, {});\n\n            // get column orientated or row dataset\n            if (data.cols) {\n                n = data.cols[key] ? data.cols[key].length : 0;\n            } else {\n                rows = data.collection.models.map(m => m.attributes);\n                n = rows.length;\n            }\n\n            this.columns = meta.columns.collection.map(\"id\");\n\n            if (this.columns.length && !_.isEqual(this.columns, [\"unknown0\"])) {\n                // set default mapping key/value\n                if (!(this.model.get(\"key\") && _.includes(this.columns, this.model.get(\"key\")))) {\n                    this.model.set(\n                        \"key\",\n                        (_.intersection(this.columns, [\"k\", \"Key\", \"key\"]) || [])[0] ||\n                            this.columns[0] ||\n                            \"\",\n                    );\n                }\n\n                if (\n                    !(this.model.get(\"value\") && _.includes(this.columns, this.model.get(\"value\")))\n                ) {\n                    this.model.set(\n                        \"value\",\n                        (_.intersection(this.columns, [\"v\", \"Val\", \"val\"]) || [])[0] ||\n                            this.columns[1] ||\n                            \"\",\n                    );\n                }\n            }\n\n            for (let i = 0; i < n; i++) {\n                const keyVal = rows ? rows[i][key] : data.cols[key].getValue(i);\n\n                ds[keyVal] = rows\n                    ? Tools.convertKDBToViewstateValue(rows[i][valKey])\n                    : (data.cols[valKey] ? data.cols[valKey].toViewState(i) || {} : {}).value;\n\n                mapping.push({\n                    Key: keyVal,\n                    Viewstate: currentMapping[keyVal],\n                });\n            }\n\n            this.data = ds;\n            this.trigger(\"on-data\");\n\n            _.each(\n                mapping,\n                function(item) {\n                    const key = item[\"Key\"],\n                        value = ds[key],\n                        viewStateModel = _.isString(item[\"Viewstate\"])\n                            ? this.viewState.getByPath(item[\"Viewstate\"])\n                            : item[\"Viewstate\"] && item[\"Viewstate\"].path\n                            ? this.viewState.getByPath(item[\"Viewstate\"].path)\n                            : null;\n\n                    if (_.isObject(value)) {\n                        _.each(value, function(v: any) {\n                            if (v && v._type) {\n                                v.type = v._type;\n                                delete v._type;\n                            }\n                        });\n                    }\n\n                    if (\n                        viewStateModel &&\n                        _.isFunction(viewStateModel.set) &&\n                        !_.isUndefined(value)\n                    ) {\n                        viewStateModel.setModelValue(value);\n                    }\n                }.bind(this),\n            );\n        }\n\n        private onMappingItemKeyChange(model) {\n            model.set(\"value\", this.getValue(model.get(\"key\")));\n            this.setDataModel();\n        }\n\n        private onMappingItemViewStateChange() {\n            this.setDataModel();\n        }\n\n        private onMappingKeyChange() {\n            this.generateValues();\n            this.setDataModel();\n            this.trigger(\"key-change\");\n        }\n\n        private onMappingsCollectionChange() {\n            this.setSubscription();\n            this.setDataModel();\n            this.trigger(\"mappings-change\");\n        }\n\n        private onMappingValueChange() {\n            this.generateValues();\n            this.setDataModel();\n            this.trigger(\"value-change\");\n        }\n\n        public removeMapping(model) {\n            this.mappings.remove(model);\n        }\n\n        public resetMappings() {\n            this.mappings.reset(\n                _.map(this.getPossibleKeys(), key => {\n                    return new Backbone.Model({\n                        key: key,\n                        value: this.getValue(key),\n                        viewstate: \"\",\n                    });\n                }),\n            );\n\n            this.onMappingsCollectionChange();\n        }\n\n        private setDataModel() {\n            this.setDataModelMappings(this.toJSON());\n        }\n\n        public setSubscription(editMode?: boolean) {\n            if (this.mappings.isEmpty() && !editMode) {\n                if (this.subscribed) {\n                    this.subscribed = false;\n                    this.unsubscribe(this.subscriptionKey);\n                }\n            } else {\n                if (!this.subscribed) {\n                    this.subscribed = true;\n                    this.subscribe(this.subscriptionKey, {\n                        onData: this.onData.bind(this),\n                    });\n                }\n            }\n        }\n\n        toJSON() {\n            return {\n                key: this.model.get(\"key\"),\n                mappings: this.mappings.reduce((map, model) => {\n                    const key = model.get(\"key\");\n                    const viewstate = model.get(\"viewstate\");\n\n                    if (viewstate instanceof DocumentViewModel) {\n                        map[key] = {\n                            _dashboardsType: \"viewstate\",\n                            value: viewstate.path,\n                        };\n                    } else {\n                        map[key] = viewstate;\n                    }\n\n                    return map;\n                }, {}),\n                value: this.model.get(\"value\"),\n            };\n        }\n    }\n}\n","interface ColumnInfo {\n    id: string;\n    index: number;\n    kdbType: number;\n}\n","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class ChangeSet {\r\n        constructor(collection) {\r\n            this.collection = collection;\r\n        }\r\n\r\n        private collection: Backbone.Collection<Backbone.Model>;\r\n        public add: Array<object>;\r\n        public change: Array<object>;\r\n        public reset: Array<object>;\r\n        public remove: Array<object>;\r\n        public cols: { [index: string]: ipc.TypeBase };\r\n\r\n        public assign(collection: Backbone.Collection) {\r\n            this.collection = collection;\r\n        }\r\n\r\n        public items() {\r\n            if (this.reset) return this.reset;\r\n            else return _.map(this.collection.models, m => m.attributes);\r\n        }\r\n    }\r\n}\r\n","/*global _,$,console,Backbone */\n/// <reference path=\"ColumnInfo.ts\"/>\n/// <reference path=\"log.ts\"/>\n/// <reference path=\"ChangeSet.ts\"/>\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    var TEMPORAL_MAP = {\n        1212: true,\n        1213: true,\n        1214: true,\n        1215: true,\n        1216: true,\n        1217: true,\n        1218: true,\n        1219: true,\n    };\n    var DataSetModel = Backbone.Model;\n\n    // A minimal version of set for better performance\n    function _set(key, val, options) {\n        if (key == null) return this;\n\n        // Handle both `\"key\", value` and `{key: value}` -style arguments.\n        let attrs;\n        if (typeof key === \"object\") {\n            attrs = key;\n            options = val;\n        } else {\n            (attrs = {})[key] = val;\n        }\n\n        // Extract attributes and options.\n        this.changed = {};\n\n        // For each `set` attribute, update or delete the current value.\n        for (const attr in attrs) {\n            const current = this.attributes[attr];\n            val = attrs[attr];\n\n            if (\n                !(current && val && typeof current === \"object\" && typeof val === \"object\"\n                    ? //is temporal\n                      TEMPORAL_MAP[current.class] && TEMPORAL_MAP[val.class]\n                        ? current.i === val.i && current.n === val.n\n                        : //array or non temporal objects\n                          _.isEqual(current, val)\n                    : // else simple comparison\n                      current == val)\n            ) {\n                this.attributes[attr] = this.changed[attr] = val;\n            }\n        }\n\n        if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);\n\n        return this;\n    }\n\n    function _changedAttributes() {\n        return this.hasChanged() ? this.changed : false;\n    }\n\n    interface IPagingMeta {\n        startRows: number;\n    }\n\n    export class DataSet {\n        public static readonly DEFAULT_ROW_INDEX = \"_rowIndex\";\n        breakdownColumns: Array<string> = [];\n        columns = new Backbone.Collection();\n        columnDict: { [index: string]: ColumnInfo } = {};\n        agent: Agent;\n        collection;\n\n        // store collectionFunc so tempDataSet can use it\n        collectionFunc;\n\n        forceReset: boolean; // used by tempDataSet\n        preferBackground = false;\n        idAttribute: string;\n        public lazyLoading: boolean;\n        maxRows: number;\n        pagingMeta: IPagingMeta;\n        primaryKey: string;\n\n        tempDataSet: DataSet;\n        visibilityChangeHandler: EventListenerObject;\n\n        noBackground: boolean;\n\n        constructor(options) {\n            this.breakdownColumns = [];\n\n            this.agent = options.agent;\n            this.collection = new options.collectionFunc();\n\n            // store collectionFunc so tempDataSet can use it\n            this.collectionFunc = options.collectionFunc;\n\n            // gk: set prototype function on model - extend apporach doesn't work\n            this.collection.model.prototype.set = _set;\n            this.collection.model.prototype.changedAttributes = _changedAttributes;\n\n            this.idAttribute = options.idAttribute;\n            this.maxRows = options.maxRows || 100;\n            this.primaryKey = options.primaryKey || DataSet.DEFAULT_ROW_INDEX;\n            this.lazyLoading = options.lazyLoading || false;\n        }\n\n        static columnsToCollection(models: any[]): Backbone.Collection {\n            const collection = new Backbone.Collection();\n            collection.models = models.map(a => {\n                const m = new Backbone.Model();\n                m.id = a.id;\n                m.attributes = a;\n                return m;\n            });\n            collection.length = models.length;\n            return collection;\n        }\n\n        static updateColumns(\n            columns: { [index: string]: ColumnInfo },\n            meta,\n            changeSet,\n            noChangeSet?: boolean,\n        ): { [index: string]: ColumnInfo } {\n            const adds = [],\n                changes = [],\n                columnInfos: ColumnInfo[] = meta.columns || [];\n            let removes = [];\n\n            if (noChangeSet || _.isEmpty(columns)) {\n                /*jshint sub:true*/\n                columns = {};\n                columnInfos.forEach(c => (columns[c.id] = c));\n                changeSet[\"reset\"] = columnInfos;\n            } else {\n                columnInfos.forEach(c => {\n                    const existing = columns[c.id];\n                    if (existing) {\n                        const diff = {};\n                        let isDiff = false;\n                        _.each(c, (v, k) => {\n                            if (existing[k] !== v) {\n                                isDiff = true;\n                                diff[k] = v;\n                            }\n                        });\n\n                        if (isDiff) {\n                            changes.push(_.extend(diff, { id: c.id }));\n                        }\n                    } else {\n                        adds.push(c);\n                    }\n                });\n\n                // if existing + added <= new length then no removes\n                const columnObjs = _.values(columns);\n                if (columnObjs.length + adds.length > columnInfos.length) {\n                    // this is costly ~On2 but it shouldn't happen often\n                    removes = _.reject(columnObjs, function(m) {\n                        return _.find(columnInfos, function(c) {\n                            return c.id === m.id;\n                        });\n                    });\n                }\n\n                // remove those added\n                removes.forEach(r => delete columns[r.id]);\n                adds.forEach(a => (columns[a.id] = a));\n\n                if (adds.length) {\n                    changeSet[\"add\"] = adds;\n                }\n\n                if (changes.length) {\n                    changeSet[\"change\"] = changes;\n                }\n\n                if (removes && removes.length) {\n                    changeSet[\"remove\"] = removes;\n                }\n            }\n\n            return columns;\n        }\n\n        addOrExtendExisting(dict, key, data): boolean {\n            //support for guid/datetime/timestamp/timespan\n            key = _.isObject(key) ? key.toString() : key;\n            const item = dict[key];\n\n            if (item) {\n                _.extend(item, data);\n                return false;\n            } else {\n                dict[key] = data;\n                return true;\n            }\n        }\n\n        // TODO: gk - must be a better way to do pivot subscriptions without heirarchy\n        addSubscribeFunctions(data: Array<any>) {\n            data.forEach(d => {\n                const row = this.collection.get(d[this.primaryKey]);\n                if (row) {\n                    if (row.subscribe) {\n                        d.subscribe = (uid, handler) => {\n                            row.subscribe(uid, handler);\n                        };\n                    }\n\n                    if (row.unsubscribe) {\n                        d.unsubscribe = uid => {\n                            row.unsubscribe(uid);\n                        };\n                    }\n                }\n            });\n\n            return data;\n        }\n\n        background(): void {\n            this.preferBackground = true;\n        }\n\n        cleanUp() {\n            this.columnDict = {};\n            this.columns = DataSet.columnsToCollection([]);\n            this.collection.reset();\n\n            if (this.visibilityChangeHandler) {\n                document.removeEventListener(\"visibilitychange\", this.visibilityChangeHandler);\n            }\n        }\n\n        flushUpdates() {\n            // get meta data\n            if (this.tempDataSet) {\n                this.onDataInternal(\n                    {\n                        breakdownColumns: this.tempDataSet.breakdownColumns,\n                        columns: _.values(this.tempDataSet.columnDict),\n                        paging: this.tempDataSet.pagingMeta,\n                    },\n                    this.tempDataSet.collection.models.map(m => m.attributes),\n                    this.tempDataSet.forceReset,\n                );\n\n                delete this.tempDataSet;\n                this.preferBackground = false;\n            }\n        }\n\n        indexArray(arrData) {\n            let i, pos;\n\n            if (this.lazyLoading) {\n                pos = this.pagingMeta.startRows;\n                for (i = 0; i < arrData.length; i += 1, pos += 1) {\n                    arrData[i][DataSet.DEFAULT_ROW_INDEX] = pos;\n                }\n            } else {\n                for (i = 0; i < arrData.length; i += 1) {\n                    arrData[i][DataSet.DEFAULT_ROW_INDEX] = i;\n                }\n            }\n        }\n\n        isBackground() {\n            return (\n                !this.noBackground &&\n                (this.preferBackground || (document.hidden && !(\"FSBL\" in window)))\n            );\n        }\n\n        isEmpty() {\n            return (\n                !(this.collection && this.collection.models && this.collection.models.length) &&\n                (!this.tempDataSet || this.tempDataSet.isEmpty())\n            );\n        }\n\n        // data  = data['rows']\n        mergeData(\n            data: Array<object>,\n            forceReset: boolean,\n            changeSet: ChangeSet,\n            noChangeSet?: boolean,\n        ) {\n            let self = this,\n                i,\n                key,\n                existingRow,\n                totalCount,\n                addedDict = {},\n                changeDict = {},\n                adds: Array<object> = [],\n                changes: Array<object> = [],\n                removeModels: Array<Backbone.Model>;\n\n            if (self.primaryKey === DataSet.DEFAULT_ROW_INDEX) {\n                self.indexArray(data);\n            }\n\n            if (self.collection.length === 0 && data.length > 0) {\n                // use reset event if not appending data\n                data.forEach(d => {\n                    if (_.isNull(d[self.primaryKey])) {\n                        d[self.primaryKey] = \"\";\n                    }\n                    adds.push(d);\n                });\n\n                changeSet.reset = adds;\n\n                // TODO: the addition of pivot defaults - requires a clone\n                if (self.collection.model && self.collection.model.prototype.defaults) {\n                    self.collection.reset(adds);\n                } else {\n                    // faster path without clone\n                    self.collection.reset(\n                        adds.map(function(m) {\n                            const model = new self.collection.model();\n                            model.attributes = m;\n                            if (model.idAttribute in m) model.id = m[model.idAttribute];\n                            return model;\n                        }),\n                    );\n                }\n\n                self.addSubscribeFunctions(adds);\n            } else {\n                // build change and added dicts\n                for (i = 0; i < data.length; i += 1) {\n                    // stringify key\n                    if (_.isNull(data[i][self.primaryKey])) {\n                        data[i][self.primaryKey] = \"\";\n                    }\n                    key = data[i][self.primaryKey];\n                    key = _.isObject(key) ? key.toString() : key;\n\n                    // check for existing defined as:\n                    // no force add AND no already added AND is existing\n                    if (!addedDict[key] && self.collection.get(key)) {\n                        self.addOrExtendExisting(changeDict, key, data[i]);\n                    } else {\n                        if (self.addOrExtendExisting(addedDict, key, data[i])) {\n                            adds.push(data[i]);\n                        }\n                    }\n                }\n\n                // create added array\n                //adds = _.values(addedDict);\n\n                removeModels = [];\n                //remove items that are no longer present\n                if (forceReset) {\n                    removeModels = self.collection.filter(function(mdl) {\n                        key = mdl.get(self.primaryKey);\n                        return !(_.has(changeDict, key) || _.has(addedDict, key));\n                    });\n                } else {\n                    // remove reduntant data - create remove array\n\n                    totalCount = self.collection.length + adds.length;\n                    if (totalCount > self.maxRows) {\n                        removeModels = self.collection.models.slice(0, totalCount - self.maxRows);\n                    }\n                    totalCount = totalCount - removeModels.length;\n                    if (totalCount > self.maxRows) {\n                        adds = adds.slice(totalCount - self.maxRows);\n                    }\n                }\n\n                if (removeModels.length) {\n                    self.collection.remove(removeModels);\n                    if (!noChangeSet) {\n                        changeSet[\"remove\"] = _.map(removeModels, function(m) {\n                            return m.attributes;\n                        });\n                    }\n                }\n\n                // apply changes and save changed array\n                _.each(changeDict, function(row) {\n                    let change;\n\n                    key = row[self.primaryKey];\n                    existingRow = self.collection.get(key);\n                    if (existingRow) {\n                        existingRow.set(row);\n                        if (!noChangeSet) {\n                            change = existingRow.changedAttributes();\n                            if (change) {\n                                change[self.primaryKey] = key;\n                                changes.push(change);\n                            }\n                        }\n                    } else {\n                        // change got removed - do nothing\n                    }\n                });\n\n                // apply adds\n                self.collection.add(adds);\n                self.addSubscribeFunctions(adds);\n\n                if (!noChangeSet) {\n                    if (adds.length) {\n                        changeSet[\"add\"] = adds;\n                    }\n\n                    if (changes.length) {\n                        changeSet[\"change\"] = changes;\n                    }\n\n                    if (\n                        forceReset &&\n                        data.length === 0 &&\n                        !(changeSet[\"add\"] || changeSet[\"change\"] || changeSet[\"remove\"])\n                    ) {\n                        changeSet[\"reset\"] = [];\n                    }\n                }\n            }\n        }\n\n        onData(\n            meta,\n            data: Array<object>,\n            forceReset: boolean,\n            error?: any,\n            performanceMetrics?: PerformanceMetrics,\n        ) {\n            if (this.isBackground()) {\n                if (!this.tempDataSet) {\n                    this.tempDataSet = new DataSet({\n                        idAttribute: this.idAttribute,\n                        collectionFunc: this.collectionFunc,\n                        agent: new Agent(),\n                        maxRows: this.maxRows,\n                        primaryKey: this.primaryKey,\n                    });\n                    this.tempDataSet.forceReset = false;\n                }\n\n                this.tempDataSet.onDataInternal(meta, data, forceReset, error, undefined, true);\n\n                if (forceReset) {\n                    this.tempDataSet.forceReset = true;\n                }\n\n                return;\n            }\n\n            this.onDataInternal(meta, data, forceReset, error, performanceMetrics);\n        }\n\n        onDataInternal(\n            meta: any,\n            data: Array<Record<string, any>>,\n            forceReset: boolean,\n            error?,\n            performanceMetrics?: PerformanceMetrics,\n            noChangeSet?: boolean,\n        ): void {\n            const dataChangeSet = new ChangeSet(this.collection);\n            const columnsChangeSet = new ChangeSet(undefined);\n\n            if (meta) {\n                if (!_.isUndefined(meta.breakdownColumns)) {\n                    this.breakdownColumns = meta.breakdownColumns;\n                }\n\n                this.columnDict = DataSet.updateColumns(\n                    this.columnDict,\n                    meta,\n                    columnsChangeSet,\n                    noChangeSet,\n                );\n\n                //Log.Info(\"Meta: \" + this.updateSetCountToString(columnsChangeSet, this.columns.models));\n\n                // columns removed - remove from collection\n                if (columnsChangeSet.remove) {\n                    const removes = columnsChangeSet.remove.map((r: any) => r.id);\n                    this.collection.models.forEach(m => {\n                        removes.forEach(r => {\n                            delete m.attributes[r];\n                            delete m.changed[r];\n                        });\n                    });\n                }\n            }\n\n            this.pagingMeta = meta[\"paging\"];\n\n            // update data\n            if (data) {\n                this.mergeData(data, forceReset, dataChangeSet, noChangeSet);\n                Log.Info(\n                    \"Data: \" + this.updateSetCountToString(dataChangeSet, this.collection.models),\n                );\n            }\n\n            // no point in calculating changeSets\n            if (noChangeSet) return;\n\n            const metaChangeSet = {\n                primaryKey: this.primaryKey,\n                columns: columnsChangeSet,\n            };\n\n            const errorObj = error || undefined;\n\n            if (this.pagingMeta) {\n                metaChangeSet[\"paging\"] = this.pagingMeta;\n            }\n\n            if (_.isArray(this.breakdownColumns)) {\n                metaChangeSet[\"breakdownColumns\"] = this.breakdownColumns;\n\n                if (metaChangeSet[\"breakdownColumns\"] instanceof Backbone.Model) {\n                    metaChangeSet[\"breakdownColumns\"] = metaChangeSet[\"breakdownColumns\"].get(\n                        \"value\",\n                    );\n                }\n            }\n\n            // notify subscribers\n            if (performanceMetrics) {\n                performanceMetrics.trigger(\"onAgentNotify\");\n            }\n\n            // gk: almost like a real collection\n            metaChangeSet.columns.assign(\n                (this.columns = DataSet.columnsToCollection(_.values(this.columnDict))),\n            );\n            this.agent.notifyAllLegacyChange(\n                metaChangeSet,\n                dataChangeSet,\n                errorObj,\n                performanceMetrics,\n            );\n        }\n\n        onDataRefresh(subscriber: Subscriber) {\n            let columnValues = _.values(this.columnDict),\n                dataChangeSet = new ChangeSet(this.collection),\n                columnsChangeSet = new ChangeSet(this.columns),\n                metaChangeSet = {};\n\n            // get meta data\n            columnsChangeSet[\"reset\"] = columnValues;\n\n            metaChangeSet = {\n                primaryKey: this.primaryKey,\n                columns: columnsChangeSet,\n            };\n\n            if (_.isArray(this.breakdownColumns)) {\n                metaChangeSet[\"breakdownColumns\"] = this.breakdownColumns;\n\n                if (metaChangeSet[\"breakdownColumns\"] instanceof Backbone.Model) {\n                    metaChangeSet[\"breakdownColumns\"] = metaChangeSet[\"breakdownColumns\"].get(\n                        \"value\",\n                    );\n                }\n            }\n\n            if (this.pagingMeta) {\n                metaChangeSet[\"paging\"] = this.pagingMeta;\n            }\n\n            // get data\n            dataChangeSet[\"reset\"] = this.addSubscribeFunctions(\n                this.collection.map(function(model) {\n                    return model.attributes;\n                }),\n            );\n\n            // if subscriber notify single or all\n            if (subscriber) {\n                this.agent.notifyChange(subscriber, metaChangeSet, dataChangeSet);\n            } else {\n                this.agent.notifyAllLegacyChange(metaChangeSet, dataChangeSet);\n            }\n        }\n\n        updateSetCountToString(set, data): string {\n            return (\n                (set[\"add\"] ? \" +\" + set[\"add\"].length : \"\") +\n                (set[\"remove\"] ? \" -\" + set[\"remove\"].length : \"\") +\n                (set[\"change\"] ? \" ~\" + set[\"change\"].length : \"\") +\n                (set[\"reset\"] ? \" =\" + set[\"reset\"].length : \"\") +\n                \" ==>\" +\n                data.length\n            );\n        }\n    }\n}\n","/*global _,$,console,Backbone */\n/// <reference path=\"DataSet.ts\"/>\n/// <reference path=\"../lib/ipc/Parse.ts\"/>\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class DataSet2 {\n        breakdownColumns: Array<string> = [];\n        columns = new Backbone.Collection();\n        columnDict: { [index: string]: ColumnInfo } = {};\n        agent: Agent;\n        collection;\n\n        // store collectionFunc so tempDataSet can use it\n        collectionFunc;\n\n        idAttribute: string;\n        maxRows: number;\n        pagingMeta: object;\n        primaryKey: string;\n        cols: { [index: string]: ipc.TypeBase };\n\n        constructor(options) {\n            this.breakdownColumns = [];\n\n            this.agent = options.agent;\n\n            this.idAttribute = options.idAttribute;\n            this.maxRows = Number(options.maxRows || 100);\n            this.primaryKey = options.primaryKey || DataSet.DEFAULT_ROW_INDEX;\n        }\n\n        cleanUp() {\n            this.columnDict = {};\n            this.columns = DataSet.columnsToCollection([]);\n            this.cols = undefined;\n        }\n\n        indexArray(arrData) {\n            let i;\n            for (i = 0; i < arrData.length; i += 1) {\n                arrData[i][DataSet.DEFAULT_ROW_INDEX] = i;\n            }\n        }\n\n        isEmpty() {\n            const keys = Object.keys(this.columnDict);\n            return (\n                !this.cols ||\n                keys.length == 0 ||\n                !this.cols[keys[0]] ||\n                this.cols[keys[0]].length == 0\n            );\n        }\n\n        onData(\n            meta: any,\n            cols: { [index: string]: ipc.TypeBase },\n            forceReset: boolean,\n            error?: any,\n            performanceMetrics?: PerformanceMetrics,\n        ) {\n            let dataChangeSet = new ChangeSet(this.collection),\n                columnsChangeSet = new ChangeSet(undefined),\n                metaChangeSet = {},\n                errorObj = error || undefined;\n\n            // update meta data\n            if (meta) {\n                if (!_.isUndefined(meta.breakdownColumns)) {\n                    this.breakdownColumns = meta.breakdownColumns;\n                }\n\n                this.columnDict = DataSet.updateColumns(this.columnDict, meta, columnsChangeSet);\n                //Log.Info(\"Meta: \" + this.updateSetCountToString(columnsChangeSet, this.columns.models));\n            }\n\n            metaChangeSet = {\n                primaryKey: this.primaryKey,\n                columns: columnsChangeSet,\n            };\n\n            this.pagingMeta = meta[\"paging\"];\n            if (this.pagingMeta) {\n                metaChangeSet[\"paging\"] = this.pagingMeta;\n            }\n\n            if (_.isArray(this.breakdownColumns)) {\n                metaChangeSet[\"breakdownColumns\"] = this.breakdownColumns;\n\n                if (metaChangeSet[\"breakdownColumns\"] instanceof Backbone.Model) {\n                    metaChangeSet[\"breakdownColumns\"] = metaChangeSet[\"breakdownColumns\"].get(\n                        \"value\",\n                    );\n                }\n            }\n\n            // if force reset or have no data\n            if (forceReset || !this.cols) {\n                this.cols = cols;\n            } else if (this.primaryKey == null || this.primaryKey === \"_rowIndex\") {\n                // if indexed data\n                _.each(cols, (c, key) => {\n                    const existing = this.cols[key];\n                    if (existing) {\n                        if (c.length < existing.length) {\n                            if (c.qtype !== existing.qtype) {\n                                Log.Error(\n                                    \"Column '\" +\n                                        key +\n                                        \"': meta mis-match - cannot merge kdb type \" +\n                                        c.qtype +\n                                        \" -> \" +\n                                        existing.qtype,\n                                );\n                            } else existing.mergeIndexed(c);\n                        } else {\n                            // if update length exceeds existing - simply replace it\n                            this.cols[key] = c;\n                        }\n                    } else {\n                        // debugger is this a real use-case why\n                        debugger;\n                    }\n                });\n            } else {\n                // keyed data\n                const keyCol = this.cols[this.primaryKey];\n\n                // no merge if length = max-rows\n                if (cols[this.primaryKey] && cols[this.primaryKey].length >= this.maxRows) {\n                    this.cols = cols;\n                } else {\n                    // get index from merge key data\n                    const keyIndex: Array<number> = [];\n                    const indexOffset = keyCol.mergeKeyedPrimary(\n                        cols[this.primaryKey],\n                        this.maxRows,\n                        keyIndex,\n                    );\n\n                    _.each(cols, (c, key) => {\n                        if (key === this.primaryKey) return;\n                        const existing = this.cols[key];\n                        if (existing) {\n                            existing.mergeKeyed(c, keyIndex, indexOffset, this.maxRows);\n                        } else {\n                            // debugger is this a real use-case why\n                            debugger;\n                            this.cols[key] = c;\n                        }\n                    });\n                }\n            }\n\n            dataChangeSet[\"cols\"] = this.cols;\n\n            // gk: almost like a real collection\n            columnsChangeSet.assign(\n                (this.columns = DataSet.columnsToCollection(_.values(this.columnDict))),\n            );\n\n            // notify subscribers\n            this.agent.notifyAllRawChange(\n                metaChangeSet,\n                dataChangeSet,\n                errorObj,\n                performanceMetrics,\n            );\n        }\n\n        onDataRefresh(subscriber: Subscriber): void {\n            const columnValues = _.values(this.columnDict),\n                dataChangeSet = new ChangeSet(this.collection),\n                columnsChangeSet = new ChangeSet(this.columns);\n\n            // get meta data\n            columnsChangeSet[\"reset\"] = columnValues;\n\n            const metaChangeSet = {\n                primaryKey: this.primaryKey,\n                columns: columnsChangeSet,\n            };\n\n            if (_.isArray(this.breakdownColumns)) {\n                metaChangeSet[\"breakdownColumns\"] = this.breakdownColumns;\n\n                if (metaChangeSet[\"breakdownColumns\"] instanceof Backbone.Model) {\n                    metaChangeSet[\"breakdownColumns\"] = metaChangeSet[\"breakdownColumns\"].get(\n                        \"value\",\n                    );\n                }\n            }\n\n            if (this.pagingMeta) {\n                metaChangeSet[\"paging\"] = this.pagingMeta;\n            }\n\n            // get data\n            dataChangeSet[\"cols\"] = this.cols;\n\n            // if subscriber notify single or all\n            if (subscriber) {\n                this.agent.notifyChange(subscriber, metaChangeSet, dataChangeSet);\n            } else {\n                this.agent.notifyAllRawChange(metaChangeSet, dataChangeSet);\n            }\n        }\n\n        updateSetCountToString(set, data) {\n            return (\n                (set[\"add\"] ? \" +\" + set[\"add\"].length : \"\") +\n                (set[\"remove\"] ? \" -\" + set[\"remove\"].length : \"\") +\n                (set[\"change\"] ? \" ~\" + set[\"change\"].length : \"\") +\n                (set[\"reset\"] ? \" =\" + set[\"reset\"].length : \"\") +\n                \" ==>\" +\n                data.length\n            );\n        }\n    }\n}\n","/// <reference path=\"../lib/ipc/Parse.ts\" />\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class LegacyUpdate {\n        constructor(\n            public table: ipc.Table,\n            public forceReset: boolean,\n            public pagingMeta: any,\n            public pivotMeta?: { [index: string]: number },\n        ) {}\n    }\n}\n","/// <reference types=\"backbone\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class ViewStateBinding {\n        constructor(public callback: Backbone.EventHandler, public model: DocumentViewModel) {}\n    }\n}\n","// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.QueryBuilder {\n    export interface AggData {\n        [key: string]: (string | boolean)[];\n    }\n\n    export interface XBar {\n        num: string;\n        col: string;\n        cast: string;\n    }\n    export interface SelectData {\n        [key: string]: string | XBar;\n    }\n\n    export interface Data {\n        name?: string;\n        params?: DataParam[];\n        select?: SelectData;\n        where?: FilterGroup;\n        distinct?: boolean;\n        update?: UpdateField[];\n        filter?: FilterGroup;\n        groupBy?: SelectData;\n        agg?: AggData;\n        fn?: string;\n        swap?: boolean;\n        left?: string[];\n        right?: string[];\n        partition?: Partition;\n    }\n\n    export interface DataParam {\n        isViewState: boolean;\n        IsKdbParam: boolean;\n        name: string;\n        type: string;\n        value: string | string[];\n    }\n    export interface FilterGroup {\n        operator: string;\n        children: (FilterRule | FilterGroup)[];\n    }\n\n    export interface FilterRule {\n        active: boolean;\n        operator: string;\n        propertyName: string;\n        propertyType: number;\n        type: string;\n        value: string;\n        value2: string;\n    }\n\n    export interface Partition {\n        name: string;\n        type: string;\n        parameters: any[];\n        operator: string;\n    }\n\n    export interface UpdateField {\n        column: string;\n        propertyType: number;\n        val: string;\n    }\n}\n","/// <reference path=\"../../classes/RTTI.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.DataFilter {\n    export class RuleModel extends Backbone.Model {\n        public static VSRx = /^<%[^<>%]*%>$/i;\n        public schema: any;\n        private options: any;\n\n        constructor(options?: any) {\n            super(options);\n\n            this.options = options;\n\n            this.setSchema();\n        }\n\n        defaults(): any {\n            return {\n                propertyName: null,\n                propertyType: null,\n                operator: null,\n                value: null,\n                value2: null,\n                active: true,\n                type: \"normal\",\n                compareFields: false,\n            };\n        }\n\n        getBindingValue(key) {\n            const binding = _.find(\n                this.get(\"appModel\")\n                    .get(\"settingsModel\")\n                    .get(\"Bindings\"),\n                b => b.Key === key,\n            );\n            return binding && binding.ViewState instanceof DocumentViewModel\n                ? binding.ViewState.get(\"value\")\n                : \"\";\n        }\n\n        getTypeOperators(kdbType: number = null) {\n            const result = [],\n                operators = {\n                    equal: [\n                        {\n                            label: \"equal\",\n                            val: \"equal\",\n                        },\n                        {\n                            label: \"not equal\",\n                            val: \"not_equal\",\n                        },\n                    ],\n                    like: [\n                        {\n                            label: \"like\",\n                            val: \"like\",\n                        },\n                        {\n                            label: \"not like\",\n                            val: \"not_like\",\n                        },\n                    ],\n                    blank: [\n                        {\n                            label: \"is blank\",\n                            val: \"is_blank\",\n                        },\n                        {\n                            label: \"is not blank\",\n                            val: \"is_not_blank\",\n                        },\n                    ],\n                    compare: [\n                        {\n                            label: \"less\",\n                            val: \"less\",\n                        },\n                        {\n                            label: \"less or equal\",\n                            val: \"less_or_equal\",\n                        },\n                        {\n                            label: \"greater\",\n                            val: \"greater\",\n                        },\n                        {\n                            label: \"greater or equal\",\n                            val: \"greater_or_equal\",\n                        },\n                    ],\n                    in: [\n                        {\n                            label: \"in\",\n                            val: \"in\",\n                        },\n                        {\n                            label: \"not in\",\n                            val: \"not_in\",\n                        },\n                    ],\n                },\n                pushOperators = (...oprs): void => {\n                    _.each(oprs, opr => result.push(...opr));\n                };\n\n            if (this.get(\"compareFields\")) {\n                operators.like = operators.blank = operators.in = [];\n            }\n\n            pushOperators(operators.equal);\n\n            switch (kdbType) {\n                case 0: // list\n                    pushOperators(operators.like, operators.blank);\n                    break;\n\n                // numbers\n                case 5: // short\n                case 6: // int\n                case 7: // long\n                case 8: // real\n                case 9: // float\n\n                case 4: // byte\n                    pushOperators(operators.compare, operators.blank, operators.in);\n                    break;\n\n                // time\n                case 12: // timestamp\n                case 13: // month\n                case 14: // date\n                case 15: // datetime\n                case 16: // timespan\n                case 17: // minute\n                case 18: // second\n                case 19: // time\n                    pushOperators(operators.compare, operators.blank);\n                    break;\n                case 11: // symbol\n                    pushOperators(operators.in, operators.like, operators.blank);\n                    break;\n                case 2: // guid\n                    pushOperators(operators.in, operators.blank);\n                    break;\n                case 10: // char\n                case 1: // boolean\n                    pushOperators(operators.blank);\n                    break;\n            }\n\n            return result;\n        }\n\n        replaceBindings(val: string): string {\n            return _.isString(val) && this.get(\"appModel\").get(\"Bindings\")\n                ? val.replace(RuleModel.VSRx, (val: string) => {\n                      const key = val.substring(2, val.length - 2);\n                      return this.getBindingValue(key);\n                  })\n                : val;\n        }\n\n        setSchema() {\n            const kdbType = this.get(\"propertyType\");\n\n            if (this.get(\"type\") === \"histogram\") {\n                // filter out items with appropriate data types\n                const histogramKdbTypes = [5, 6, 7, 8, 9, 12, 13, 14, 15, 16, 17, 18, 19];\n\n                const dataItems = this.options.appModel\n                    .get(\"data.items\")\n                    .filter((i, k) => {\n                        return _.includes(\n                            histogramKdbTypes,\n                            this.options.appModel.get(\"data.meta.columns.models\")[k].get(\"kdbType\"),\n                        );\n                    })\n                    .map(i => {\n                        return {\n                            label: i.get(\"propertyName\"),\n                            val: i.get(\"propertyName\"),\n                        };\n                    });\n\n                this.schema = {\n                    active: {\n                        title: \"Is Active:\",\n                        type: \"Checkbox\",\n                    },\n                    propertyName: {\n                        title: \"Property:\",\n                        type: \"Select\",\n                        options: _.sortBy(dataItems, \"label\"),\n                    },\n                    value: _.extend(\n                        {\n                            title: \"From\",\n                        },\n                        RTTI.getByQTypeNum(kdbType || 11).editor,\n                    ),\n                    value2: _.extend(\n                        {\n                            title: \"To\",\n                        },\n                        RTTI.getByQTypeNum(kdbType || 11).editor,\n                    ),\n                };\n            } else {\n                const dataItems = this.options.appModel.get(\"data.items\").map(i => {\n                    return {\n                        label: i.get(\"propertyName\"),\n                        val: i.get(\"propertyName\"),\n                    };\n                });\n\n                // default schema\n                this.schema = {\n                    active: {\n                        title: \"Is Active:\",\n                        type: \"Checkbox\",\n                    },\n                    propertyName: {\n                        title: \"Property:\",\n                        type: \"Select\",\n                        options: _.sortBy(dataItems, \"label\"),\n                    },\n                    operator: {\n                        title: \"Operator:\",\n                        type: \"Select\",\n                        options: this.getTypeOperators(kdbType),\n                    },\n                    value: _.extend(\n                        {\n                            title: \"Value\",\n                        },\n                        RTTI.getByQTypeNum(kdbType || 11).editor,\n                    ),\n                };\n            }\n\n            if (this.get(\"compareFields\")) {\n                this.schema.value = {\n                    title: \"Value\",\n                    type: \"Select\",\n                };\n            } else if (\n                this.get(\"operator\") &&\n                this.get(\"propertyName\") &&\n                _.some(\n                    [\n                        \"in\",\n                        \"not_in\",\n                        \"equal\",\n                        \"not_equal\",\n                        \"greater\",\n                        \"less\",\n                        \"greater_or_equal\",\n                        \"less_or_equal\",\n                    ],\n                    o => {\n                        return o === this.get(\"operator\");\n                    },\n                )\n            ) {\n                const dataItem = this.options.appModel\n                    .get(\"data.items\")\n                    .get(this.get(\"propertyName\"));\n                const singleSelect =\n                    _.indexOf(\n                        [\n                            \"equal\",\n                            \"not_equal\",\n                            \"greater\",\n                            \"less\",\n                            \"greater_or_equal\",\n                            \"less_or_equal\",\n                        ],\n                        this.get(\"operator\"),\n                    ) >= 0;\n\n                if (dataItem) {\n                    let results = null;\n\n                    if (dataItem.get(\"result\") && dataItem.get(\"result\").data) {\n                        // data source is set\n                        const dataMappingLabel =\n                            dataItem.get(\"DataSourceMapping.Text\") || this.get(\"propertyName\");\n                        const dataMappingValue =\n                            dataItem.get(\"DataSourceMapping.Value\") || this.get(\"propertyName\");\n\n                        results = dataItem.get(\"result\").data.collection.map(m => {\n                            const lbl = m.get(dataMappingLabel),\n                                val = m.get(dataMappingValue);\n                            // convert boolean values to strings\n                            return {\n                                label: _.isBoolean(lbl) ? lbl + \"\" : lbl,\n                                val: _.isBoolean(val) ? val + \"\" : val,\n                            };\n                        });\n\n                        results = _.uniqBy(\n                            _.reject(results, r => _.isNil(r.label)),\n                            r => r.label,\n                        );\n\n                        if (\n                            results.length <= 0 &&\n                            this.get(\"value\") &&\n                            _.isArray(this.get(\"value\")) &&\n                            this.get(\"value\").length > 0\n                        ) {\n                            _.each(this.get(\"value\"), v => {\n                                results.push({\n                                    label: v,\n                                    val: v,\n                                });\n                            });\n                        }\n\n                        results.splice(0, 0, {\n                            label: \"\",\n                            val: \"\",\n                        });\n\n                        // set\n                        this.schema.value = {\n                            title: \"Value\",\n                            type: singleSelect ? \"Select\" : \"MultiSelect\",\n                            options: results,\n                            modelKey: \"value\",\n                        };\n                    } else if (dataItem.get(\"items\").length > 0) {\n                        results = _.map(dataItem.get(\"items\"), (m: any) => {\n                            return {\n                                label: m.Text,\n                                val: m.Value,\n                            };\n                        });\n\n                        results.splice(0, 0, {\n                            label: \"\",\n                            val: \"\",\n                        });\n                        // set\n                        this.schema.value = {\n                            title: \"Value\",\n                            type: singleSelect ? \"Select\" : \"MultiSelect\",\n                            options: results,\n                            modelKey: \"value\",\n                        };\n                    } else if (!singleSelect) {\n                        // no items\n                        this.schema.value = _.extend(\n                            {\n                                title: \"Value\",\n                            },\n                            RTTI.getByQTypeNum(0).editor,\n                        );\n                    }\n                }\n            }\n        }\n\n        isValueValid(value): boolean {\n            if (_.includes([\"is_not_blank\", \"is_blank\"], this.get(\"operator\"))) {\n                return true;\n            } else {\n                return !(_.isUndefined(value) || _.isNull(value) || value === \"\");\n            }\n        }\n\n        toJSON(): any {\n            let j;\n\n            if (this.get(\"type\") === \"histogram\") {\n                j = _.pick(\n                    this.attributes,\n                    \"propertyName\",\n                    \"propertyType\",\n                    \"value\",\n                    \"value2\",\n                    \"active\",\n                    \"type\",\n                );\n            } else {\n                j = _.pick(\n                    this.attributes,\n                    \"propertyName\",\n                    \"propertyType\",\n                    \"operator\",\n                    \"value\",\n                    \"active\",\n                    \"type\",\n                    \"compareFields\",\n                );\n            }\n\n            if (j.propertyType === null) {\n                j.propertyType = 11; // default to symbol!\n            }\n            return j;\n        }\n\n        toIPC(): Uint8Array {\n            if (this.get(\"type\") === \"histogram\") {\n                return this.toIPCHistogram();\n            }\n\n            return this.toIPCNormal();\n        }\n\n        toIPCHistogram(): Uint8Array {\n            const operator = new Uint8Array([102, 5]); // AND\n            const children = [];\n            const name = this.get(\"propertyName\");\n            const type = this.get(\"propertyType\");\n            const value1 = type === 7 ? Math.ceil(this.get(\"value\")) : this.get(\"value\");\n            const op1 = \"greater_or_equal\";\n            const value2 = type === 7 ? Math.floor(this.get(\"value2\")) : this.get(\"value2\");\n            const op2 = \"less_or_equal\";\n\n            if (\n                this.get(\"active\") &&\n                name &&\n                op1 &&\n                op2 &&\n                this.isValueValid(value1) &&\n                this.isValueValid(value2)\n            ) {\n                children.push(this.toIPCNormal(name, op1, value1));\n                children.push(this.toIPCNormal(name, op2, value2));\n                return QuickBase.ipc.List.toIPC([operator].concat(children));\n            }\n\n            return null;\n        }\n\n        toIPCNormal(name = null, op = null, value = null): Uint8Array {\n            name = name || this.get(\"propertyName\");\n            op = op || this.get(\"operator\");\n            value = this.replaceBindings(value || this.get(\"value\"));\n\n            // casting generic list 0 to symbol, used for strings\n            const type = -this.get(\"propertyType\") || 10;\n\n            if (this.get(\"active\") && name && op && this.isValueValid(value)) {\n                const qtype = QuickBase.ipc.Util.getType(type);\n\n                if (this.get(\"compareFields\") && value === this.get(\"value\")) {\n                    value = QuickBase.ipc.Symbol.toIPC(value);\n                } else if (op === \"in\" || op === \"not_in\") {\n                    // make array regardless for value type\n                    if (!_.isArray(value)) {\n                        value = value === null ? [] : [value];\n                    }\n\n                    // put value in array or pass empty array\n                    value = qtype.listToIPC(_.map(value, value => this.typeCast(value)));\n                } else {\n                    // Boolean types in datasource comes as a string so cast to boolean\n                    if (type === -1 && _.isString(value)) {\n                        value = value === \"true\";\n                    }\n                    value = qtype.toIPC(ipc.fromString(qtype, value));\n                }\n\n                return QuickBase.ipc.Dict.toIPC(\n                    [\"src\", \"comparison\", \"value\", \"dataType\", \"compareFields\"],\n                    QuickBase.ipc.List.toIPC(\n                        _.map([this.get(\"propertyName\"), op], v =>\n                            QuickBase.ipc.Symbol.toIPC(v),\n                        ).concat([\n                            value,\n                            QuickBase.ipc.Short.toIPC(type),\n                            QuickBase.ipc.Boolean.toIPC(this.get(\"compareFields\")),\n                        ]),\n                    ),\n                );\n            }\n\n            return null;\n        }\n\n        toKDB(): string {\n            let qtype, value;\n\n            if (\n                this.get(\"active\") &&\n                this.get(\"propertyName\") &&\n                this.get(\"operator\") &&\n                this.isValueValid(this.get(\"value\"))\n            ) {\n                if (this.get(\"operator\") === \"in\" || this.get(\"operator\") === \"not_in\") {\n                    qtype = RTTI.getByQTypeNum(0);\n                    value = this.get(\"value\");\n                    value = qtype.toKDBInput(value);\n                } else {\n                    qtype = RTTI.getByQTypeNum(this.get(\"propertyType\") || 11); // if bad data then symbol\n                    value = qtype.toKDBInput(this.get(\"value\"));\n                }\n\n                return (\n                    \"(`src`comparison`value!(`\" +\n                    this.get(\"propertyName\") +\n                    \";`\" +\n                    this.get(\"operator\") +\n                    \";\" +\n                    value +\n                    \"))\"\n                );\n            }\n            return null;\n        }\n\n        /**\n         * Cat value if model has property \"propertyType\" is kdb type code\n         * @param {any} value - value to cast\n         */\n        typeCast(value): number | string {\n            switch (this.get(\"propertyType\")) {\n                case 4: // byte\n                case 5: // short\n                case 6: // int\n                case 7: // long\n                case 8: // real\n                case 9: // float\n                    if (!_.isNaN(Number(value))) {\n                        return Number(value);\n                    }\n            }\n\n            return value !== null ? \"\" + value : \"\";\n        }\n\n        validate(value1, value2): boolean {\n            let v1, v2;\n\n            if (!isNaN(value1) && !isNaN(value2)) {\n                // numbers\n                v1 = new Number(value1);\n                v2 = new Number(value2);\n            } else {\n                // dates\n                v1 = moment(value1);\n                v2 = moment(value2);\n            }\n\n            return v1 >= v2; // return true if error\n        }\n    }\n}\n","/// <reference path=\"./RuleModel.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.DataFilter {\n    export class GroupModel extends Backbone.Model {\n        constructor(options?: any) {\n            super(options);\n\n            const children = this.get(\"children\");\n\n            if (!children || _.isArray(children)) {\n                // new children collection\n                // children should be an array here\n\n                // convert array to collection\n                const collection = new Backbone.Collection<RuleModel | GroupModel>();\n\n                // one by one make RuleModel or GroupModel\n                _.each(children || [], i => {\n                    let itemModel;\n\n                    // add app model\n                    _.extend(i, {\n                        appModel: options.appModel,\n                    });\n\n                    if (i.hasOwnProperty(\"children\")) {\n                        itemModel = new GroupModel(i);\n                    } else {\n                        itemModel = new RuleModel(i);\n                    }\n                    collection.add(itemModel);\n                });\n\n                this.set(\"children\", collection);\n            }\n\n            // Set Group as Active if Children\n            if (this.get(\"children\").length > 0) {\n                this.set(\"active\", true, { silent: true });\n            }\n\n            this.listenTo(this.get(\"children\"), \"add remove reset change\", () => {\n                const items = this.get(\"children\").filter(c => c.get(\"active\"));\n\n                if (items.length > 0) {\n                    this.set(\"active\", true);\n                } else {\n                    this.set(\"active\", false);\n                }\n                this.trigger(\"change\");\n            });\n        }\n\n        defaults(): any {\n            return {\n                children: new Backbone.Collection<RuleModel | GroupModel>(),\n                operator: \"AND\", // AND / OR\n                active: false,\n            };\n        }\n\n        // returns true if all the group's active rules are null\n        isNull(): boolean {\n            return _.every(\n                this.get(\"children\").filter(c => c.get(\"active\")),\n                c => {\n                    return c instanceof GroupModel ? c.isNull() : _.isNull(c.toIPC());\n                },\n            );\n        }\n\n        toJSON(): any {\n            return {\n                operator: this.get(\"operator\"),\n                children: this.get(\"children\").toJSON(),\n            };\n        }\n\n        toIPC(): Uint8Array {\n            let temp;\n            const children = new Array<Uint8Array>(),\n                // filter out active items\n                items = this.get(\"children\").filter(c => c.get(\"active\"));\n\n            if (items.length > 0) {\n                _.each(items, child => {\n                    if (child instanceof GroupModel && child.isNull()) {\n                        // group models with all-null rules are excluded from ipc\n                        temp = null;\n                    } else {\n                        temp = child.toIPC();\n                    }\n                    if (temp) {\n                        children.push(temp);\n                    }\n                });\n            }\n\n            // set operator to AND or OR IPC\n            const operator = new Uint8Array([102, this.get(\"operator\") === \"AND\" ? 5 : 6]);\n\n            return QuickBase.ipc.List.toIPC([operator].concat(children));\n        }\n\n        toKDB(): string {\n            let kdb = \"(\" + this.get(\"operator\") + \";\",\n                temp;\n            const children = [];\n\n            if (this.get(\"children\").length > 0) {\n                this.get(\"children\").each(function(child) {\n                    temp = child.toKDB();\n                    if (temp) {\n                        children.push(temp);\n                    }\n                });\n\n                if (children.length <= 0) {\n                    return null;\n                }\n\n                kdb += children.join(\";\");\n                return kdb + \")\";\n            }\n\n            return null;\n        }\n    }\n}\n","/// <reference path=\"./GroupModel.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.DataFilter {\n    export class App extends Backbone.View<Backbone.Model> {\n        public static generateIpcHexMessage(filtersJson): string {\n            const gm = new GroupModel(\n                _.extend(\n                    {\n                        //dummy model, to avoid exception thrown in RuleModel > setSchema\n                        appModel: new Backbone.DeepModel({\n                            \"data.items\": new Backbone.Collection(),\n                        }),\n                    },\n                    filtersJson,\n                ),\n            );\n\n            return QuickBase.ipc.Util.toHexString(QuickBase.ipc.Util.toMessage(gm.toIPC()));\n        }\n    }\n}\n","/// <reference path=\"./Interfaces.ts\" />\n/// <reference path=\"./DataFilter.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.QueryBuilder {\n    export abstract class GraphNode {\n        public static bindings: { [index: string]: string } = {};\n        public static dataToIPC: (data: any) => Uint8Array;\n        public static viewModel: QuickBase.DocumentViewModel;\n        public static VSRx = /^<%[^<>%]*%>$/i;\n        public data: Data | string | undefined;\n\n        id: string;\n        group: \"data\" | \"stream\" | \"filter\" | \"function\" | \"groupBy\" | \"join\" | \"update\" | \"result\";\n        meta?;\n        subscription?;\n\n        constructor(data: any) {\n            this.id = data.id;\n            this.group = data.group;\n            if (data.meta) {\n                this.meta = data.meta;\n            }\n            if (this.group !== \"result\") {\n                this.data = data.data || {};\n            }\n        }\n\n        public static getBindingKeysFromArray(\n            existingKeys: Array<string>,\n            arr: string[],\n        ): Array<string> {\n            return existingKeys.concat(\n                _.filter(arr, k => _.isString(k) && GraphNode.VSRx.exec(k)).map((k: string) =>\n                    k.substring(2, k.length - 2),\n                ),\n            );\n        }\n\n        public static getActiveBindingKeys(data: any): Array<string> {\n            return [];\n        }\n\n        public static replaceAllBindings(obj: any, value = \"value\"): void {\n            _.each(obj, item => {\n                if (!item[value] && item[\"children\"]) {\n                    GraphNode.replaceAllBindings(item[\"children\"]);\n                } else {\n                    item[value] =\n                        typeof item[value] !== \"string\"\n                            ? item[value]\n                            : GraphNode.VSRx.test(item[value])\n                            ? GraphNode.replaceBindings(item[value])\n                            : item[value];\n                }\n            });\n        }\n\n        public static replaceBindings(val: string): string {\n            const key = val.substring(2, val.length - 2);\n            if (GraphNode.viewModel) {\n                const vs = GraphNode.viewModel.getByPath(key);\n                return vs && vs.get(\"value\");\n            } else {\n                return GraphNode.bindings[key];\n            }\n        }\n\n        public static replaceKeys(obj: SelectData | AggData): void {\n            let replaceKeys = false;\n\n            _.each(obj, (val, index, obj) => {\n                let newIndex;\n\n                if (GraphNode.VSRx.exec(index)) {\n                    newIndex = index.replace(GraphNode.VSRx, GraphNode.replaceBindings.bind(this));\n                    // replace this key and all that come after to preserve insertion order\n                    replaceKeys = true;\n                }\n\n                if (replaceKeys) {\n                    delete obj[index];\n                    obj[newIndex || index] = val;\n                }\n            });\n        }\n\n        public toIPC(): Uint8Array {\n            return QuickBase.ipc.Dict.toIPC(\n                [\"type\", \"data\"],\n                QuickBase.ipc.List.toIPC([\n                    QuickBase.ipc.Symbol.toIPC(this.group),\n                    QueryBuilder.App.groupToClass[this.group].dataToIPC(this.data),\n                ]),\n            );\n        }\n    }\n}\n","/// <reference path=\"./GraphNode.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.QueryBuilder {\n    export class DataNode extends GraphNode {\n        static partitionParameterToIPC(value: any, ipcType: any): Uint8Array {\n            return value instanceof Array\n                ? QuickBase.ipc.List.toIPC(\n                      value.map((val: any) => ipcType.toIPC(ipc.fromString(ipcType, \"\" + val))),\n                  )\n                : ipcType.toIPC(ipc.fromString(ipcType, \"\" + value));\n        }\n\n        static dataToIPC(data: any): Uint8Array {\n            data = DataNode.processBindings(data);\n            if (data.name && data.params) {\n                return QuickBase.ipc.List.toIPC(\n                    [QuickBase.ipc.Symbol.toIPC(data.name)].concat(\n                        DataNode.recursiveToIPC(data.params),\n                    ),\n                );\n            } else if (data.name && data.partition) {\n                const typeNum = QuickBase.RTTI.getByName(data.partition.type).num;\n                const ipcType = QuickBase.ipc.Util.getType(\"-\" + typeNum);\n                const ipcOperator =\n                    data.partition.operator === \"equals\"\n                        ? 8\n                        : data.partition.operator === \"in\"\n                        ? 23\n                        : 24;\n                return QuickBase.ipc.Dict.toIPC(\n                    [\"table\", \"operator\", \"type\", \"values\"],\n                    QuickBase.ipc.List.toIPC([\n                        QuickBase.ipc.Symbol.toIPC(data.partition.name),\n                        new Uint8Array([102, ipcOperator]),\n                        QuickBase.ipc.Symbol.toIPC(\n                            data.partition.type === \"long\" ? \"year\" : data.partition.type,\n                        ),\n                        data.partition.parameters.length > 1\n                            ? QuickBase.ipc.List.toIPC(\n                                  data.partition.parameters.map(p =>\n                                      DataNode.partitionParameterToIPC(p.value, ipcType),\n                                  ),\n                              )\n                            : DataNode.partitionParameterToIPC(\n                                  data.partition.parameters[0].value,\n                                  ipcType,\n                              ),\n                    ]),\n                );\n            } else {\n                return QuickBase.ipc.QString.toIPC(data as string);\n            }\n        }\n\n        static processBindings(data: any): Data {\n            data = _.cloneDeep(data) as Data;\n\n            if (data && data.params) {\n                DataNode.replaceAllBindings(data.params);\n            } else if (data && data.partition) {\n                DataNode.replaceAllBindings(data.partition.parameters);\n            }\n\n            return data;\n        }\n\n        static getActiveBindingKeys(data: any): Array<string> {\n            if ((data as Data).params) {\n                return (data as Data).params\n                    .filter((p: DataParam) => {\n                        return _.isString(p.value) ? GraphNode.VSRx.exec(p.value) : false;\n                    })\n                    .map((p: DataParam) => (p.value as string).substring(2, p.value.length - 2));\n            } else {\n                return [];\n            }\n        }\n\n        static recursiveToIPC(params: any): any {\n            return _.flatten(\n                _.map(params, (p: DataParam) => {\n                    let type = QuickBase.RTTI.getByName(p.type === \"list\" ? \"List\" : p.type);\n                    const typeNum = type ? type.num : 11; // set undefined or null types to 11 (symbol)\n                    if (typeNum === 98) {\n                        return DataNode.recursiveToIPC(p.value);\n                    } else if (typeNum === 7 && p.value === \"\") {\n                        p.value = \"0\";\n                    }\n                    type =\n                        QuickBase.ipc.Util.getType(typeNum > 0 ? \"-\" + typeNum : \"\" + typeNum) ||\n                        QuickBase.ipc.Util.getType(\"-11\");\n\n                    if (typeNum === 0 && p.value instanceof Array) {\n                        return type.toIPC(p.value.map(v => QuickBase.ipc.Symbol.toIPC(v)));\n                    } else {\n                        return type.toIPC(ipc.fromString(type, p.value));\n                    }\n                }),\n            );\n        }\n    }\n}\n","/// <reference path=\"./GraphNode.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.QueryBuilder {\n    export class FilterNode extends GraphNode {\n        static operatorMap: { [index: string]: string } = {\n            AND: \" and \",\n            OR: \" or \",\n            equal: \"=\",\n            in: \" in \",\n            like: \" like \",\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            greater_or_equal: \">=\",\n            less: \"<\",\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            less_or_equal: \"<=\",\n            greater: \">\",\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            is_blank: \" is blank\",\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            not_equal: \"!=\",\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            not_in: \" not in \",\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            not_like: \" not like \",\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            is_not_blank: \" is not blank\",\n        };\n\n        static dataToIPC(data: any): Uint8Array {\n            data = FilterNode.processBindings(data);\n            return QuickBase.ipc.Dict.toIPC(\n                [\"select\", \"where\", \"distinct\"],\n                QuickBase.ipc.List.toIPC([\n                    QuickBase.ipc.Dict.toIPC(\n                        _.keys(data.select),\n                        QuickBase.ipc.Symbol.listToIPC(_.values(data.select)),\n                    ),\n                    QuickBase.ipc.Util.fromHexString(\n                        DataFilter.App.generateIpcHexMessage(data.where).slice(16),\n                    ),\n                    QuickBase.ipc.Boolean.toIPC(data.distinct),\n                ]),\n            );\n        }\n\n        static getActiveBindingKeys(data: any): Array<string> {\n            let keys: Array<string> = [];\n            data = data as Data;\n            _.each(\n                data.where.children,\n                c => (keys = FilterNode.getBindingKeysFromArray(keys, _.keys(c))),\n            );\n            return FilterNode.getBindingKeysFromArray(keys, _.keys(data.select));\n        }\n\n        static processBindings(data: any): Data {\n            data = _.cloneDeep(data) as Data;\n\n            this.replaceAllBindings(data.where.children);\n            this.replaceKeys(data.select);\n\n            return data;\n        }\n    }\n}\n","/// <reference path=\"./GraphNode.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.QueryBuilder {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    export class GroupByNode extends GraphNode {\n        static dataToIPC(data: any): Uint8Array {\n            data = GroupByNode.processBindings(data);\n            return QuickBase.ipc.Dict.toIPC(\n                [\"groupBy\", \"agg\"],\n                QuickBase.ipc.List.toIPC([\n                    QuickBase.ipc.Dict.toIPC(\n                        _.keys(data.groupBy),\n                        QuickBase.ipc.List.toIPC(\n                            _.values(data.groupBy).map(v => {\n                                return _.isString(v)\n                                    ? QuickBase.ipc.Symbol.toIPC(v)\n                                    : QuickBase.ipc.Dict.toIPC(\n                                          _.keys(v),\n                                          QuickBase.ipc.Symbol.listToIPC(_.values(v)),\n                                      );\n                            }),\n                        ),\n                    ),\n                    _.isEmpty(data.agg)\n                        ? QuickBase.ipc.List.toIPC([])\n                        : QuickBase.ipc.Dict.toIPC(\n                              _.keys(data.agg),\n                              QuickBase.ipc.List.toIPC(\n                                  _.map(_.values(data.agg), a =>\n                                      QuickBase.ipc.Symbol.listToIPC(a.map(v => String(v))),\n                                  ),\n                              ),\n                          ),\n                ]),\n            );\n        }\n\n        static getActiveBindingKeys(data: any): Array<string> {\n            data = data as Data;\n            return GroupByNode.getBindingKeysFromArray(\n                [],\n                _.union(_.keys(data.agg), _.keys(data.groupBy)),\n            );\n        }\n\n        static processBindings(data: any): Data {\n            data = _.cloneDeep(data) as Data;\n\n            GraphNode.replaceKeys(data.agg);\n            GraphNode.replaceKeys(data.groupBy);\n\n            return data;\n        }\n    }\n}\n","/// <reference path=\"./GraphNode.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.QueryBuilder {\n    export class JoinNode extends GraphNode {\n        constructor(data: GraphNode) {\n            super(data);\n            if (_.isEmpty(this.data)) {\n                // set default\n                this.data = { fn: \"lj\", swap: false, left: [], right: [] };\n            }\n        }\n\n        static dataToIPC(data: any): Uint8Array {\n            data = data as Data;\n            if (data) {\n                return QuickBase.ipc.Dict.toIPC(\n                    [\"fn\", \"swap\", \"left\", \"right\"],\n                    QuickBase.ipc.List.toIPC([\n                        QuickBase.ipc.Symbol.toIPC(data.fn),\n                        QuickBase.ipc.Boolean.toIPC(data.swap),\n                        QuickBase.ipc.List.toIPC(\n                            _.map(data.left, value => QuickBase.ipc.Symbol.toIPC(String(value))),\n                        ),\n                        QuickBase.ipc.List.toIPC(\n                            _.map(data.right, value => QuickBase.ipc.Symbol.toIPC(String(value))),\n                        ),\n                    ]),\n                );\n            } else return QuickBase.ipc.Int.toIPC(null);\n        }\n    }\n}\n","/// <reference path=\"./GraphNode.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.QueryBuilder {\n    export class ResultNode extends GraphNode {\n        static dataToIPC(): Uint8Array {\n            return QuickBase.ipc.Int.toIPC(null);\n        }\n    }\n}\n","/// <reference path=\"./GraphNode.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.QueryBuilder {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    export class UpdateNode extends GraphNode {\n        static dataToIPC(data: any): Uint8Array {\n            data = UpdateNode.processBindings(data);\n            // `type`data!(`update;`filter`update!(filterNode`data;(`side`qty)!(enlist `P;0)));\n            return QuickBase.ipc.Dict.toIPC(\n                [\"filter\", \"update\"],\n                QuickBase.ipc.List.toIPC([\n                    // filter value\n                    QuickBase.ipc.Util.fromHexString(\n                        DataFilter.App.generateIpcHexMessage(data.filter).slice(16),\n                    ),\n                    // update value\n                    QuickBase.ipc.Dict.toIPC(\n                        _.map(data.update, \"column\"),\n                        QuickBase.ipc.List.toIPC(\n                            _.map(data.update, u => {\n                                const qtype = QuickBase.ipc.Util.getType(u.propertyType);\n                                const val = qtype.toIPC(ipc.fromString(qtype, u.val));\n                                return u.propertyType === -11\n                                    ? QuickBase.ipc.List.toIPC([val])\n                                    : val;\n                            }),\n                        ),\n                    ),\n                ]),\n            );\n        }\n\n        static getActiveBindingKeys(data: any): Array<string> {\n            data = data as Data;\n            let keys: Array<string> = [];\n            _.each(\n                data.filter.children,\n                c => (keys = UpdateNode.getBindingKeysFromArray(keys, _.keys(c))),\n            );\n            _.each(\n                data.update,\n                c => (keys = UpdateNode.getBindingKeysFromArray(keys, _.values(c) as string[])),\n            );\n            return keys;\n        }\n\n        static processBindings(data: any): Data {\n            data = _.cloneDeep(data) as Data;\n\n            GraphNode.replaceAllBindings(data.filter.children);\n            GraphNode.replaceAllBindings(data.update, \"val\");\n\n            return data;\n        }\n    }\n}\n","/// <reference path=\"./DataNode.ts\" />\n/// <reference path=\"./FilterNode.ts\" />\n/// <reference path=\"./GraphNode.ts\" />\n/// <reference path=\"./GroupByNode.ts\" />\n/// <reference path=\"./JoinNode.ts\" />\n/// <reference path=\"./ResultNode.ts\" />\n/// <reference path=\"./UpdateNode.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase.QueryBuilder {\n    export class App extends Backbone.View<Backbone.Model> {\n        public static groupToClass = {\n            data: DataNode,\n            function: DataNode,\n            stream: DataNode,\n            filter: FilterNode,\n            update: UpdateNode,\n            groupBy: GroupByNode,\n            join: JoinNode,\n            result: ResultNode,\n        };\n        public static VSRx = /^<%[^<>%]*%>$/i;\n        public docDataModel: QuickBase.DocumentDataModel | null = null;\n        private bindingParams = [];\n\n        public static calculateReverseEdges(edges: any): any {\n            // todo could be shorter\n            const edgesR = _.reduce(\n                edges,\n                (s, v, k) => {\n                    _.each(v, vi => {\n                        if (s[vi] === undefined) {\n                            s[vi] = [k];\n                        } else s[vi].push(k);\n                    });\n\n                    return s;\n                },\n                {} as any,\n            );\n\n            // sort edgesR values for consistent order\n            return _.fromPairs(_.map(edgesR, (v, k) => [k, _.sortBy(v)]));\n        }\n\n        public static createNode(node: GraphNode): GraphNode {\n            switch (node.group) {\n                case \"data\":\n                case \"function\":\n                case \"stream\":\n                    return new DataNode(node);\n                case \"filter\":\n                    return new FilterNode(node);\n                case \"groupBy\":\n                    return new GroupByNode(node);\n                case \"join\":\n                    return new JoinNode(node);\n                case \"update\":\n                    return new UpdateNode(node);\n                case \"result\":\n                    return new ResultNode(node);\n                default:\n                    throw \"Invalid node \" + node;\n            }\n        }\n\n        public static graphToIPC(nodes: any, edges: any, selected: string): string {\n            const filteredNodes = {},\n                filteredEdges = {},\n                edgesR = this.calculateReverseEdges(edges);\n\n            const getConnectedNodes = (id: string): void => {\n                _.extend(filteredNodes, _.pick(nodes, id));\n                if (id !== selected) {\n                    _.extend(filteredEdges, _.pick(edges, id));\n                }\n                _.each(edgesR[id], nodeId => {\n                    getConnectedNodes(nodeId);\n                });\n            };\n            getConnectedNodes(selected || \"result\");\n\n            nodes = filteredNodes;\n            edges = filteredEdges;\n\n            const qIPC = QuickBase.ipc.Dict.toIPC(\n                [\"nodes\", \"edges\"],\n                QuickBase.ipc.List.toIPC([\n                    // nodes\n                    QuickBase.ipc.Dict.toIPC(\n                        _.keys(nodes),\n                        QuickBase.ipc.List.toIPC(\n                            _.values(nodes).map(n => this.createNode(n).toIPC()),\n                        ),\n                    ),\n                    // edges\n                    QuickBase.ipc.Dict.toIPC(\n                        _.keys(edgesR),\n                        QuickBase.ipc.List.toIPC(\n                            _.values(edgesR).map(v =>\n                                QuickBase.ipc.List.toIPC(\n                                    _.sortBy(v).map(vi => QuickBase.ipc.Symbol.toIPC(vi)),\n                                ),\n                            ),\n                        ),\n                    ),\n                ]),\n            );\n\n            return QuickBase.ipc.Util.toHexString(QuickBase.ipc.Util.toMessage(qIPC));\n        }\n\n        public getIPC(\n            graphJSON: string,\n            selectedNode: string,\n            model: QuickBase.DocumentDataModel,\n        ): string {\n            let graph = JSON.parse(graphJSON);\n            this.docDataModel = model;\n\n            // replace viewstates/bindings\n            graph = this.replaceBindingsInGraph(graph);\n\n            return App.graphToIPC(graph.nodes, graph.edges, selectedNode);\n        }\n\n        private replaceBindings(val: string): any {\n            const key = val.substring(2, val.length - 2);\n            const vs = this.docDataModel.getViewState().getByPath(key);\n            this.bindingParams.push({ value: val });\n            return vs && vs.get(\"value\");\n        }\n\n        private replaceBindingsInGraph(graph: any): any {\n            this.bindingParams = [];\n\n            _.values(graph.nodes).forEach(n => {\n                // update binding values\n                [\n                    { type: \"params\", value: \"value\", children: null },\n                    { type: \"filter\", value: \"value\", children: \"children\" },\n                    { type: \"where\", value: \"value\", children: \"children\" },\n                    { type: \"update\", value: \"val\", children: null },\n                ].forEach(\n                    prop =>\n                        n.data &&\n                        n.data[prop.type] &&\n                        this.replaceAllBindings(n.data[prop.type], prop.value, prop.children),\n                );\n                // update key values\n                [\"select\", \"agg\", \"groupBy\"].forEach(\n                    prop => n.data && n.data[prop] && this.replaceKeys(n.data[prop]),\n                );\n            });\n\n            this.docDataModel.set(\"_builderParams\", this.bindingParams);\n            return graph;\n        }\n\n        private replaceAllBindings(obj: any, value = \"value\", children = \"\"): void {\n            if (!_.isEmpty(children)) obj = obj[children];\n\n            _.each(obj, item => {\n                if (!item[value] && item[\"children\"]) {\n                    this.replaceAllBindings(item[\"children\"]);\n                } else if (item[value] !== undefined) {\n                    item[value] =\n                        typeof item[value] !== \"string\"\n                            ? item[value]\n                            : App.VSRx.test(item[value])\n                            ? this.replaceBindings(item[value])\n                            : item[value];\n                }\n            });\n        }\n\n        private replaceKeys(obj): void {\n            let replaceKeys = false;\n            _.each(obj, (val, index, obj) => {\n                let newIndex;\n                if (App.VSRx.exec(index)) {\n                    newIndex = index.replace(App.VSRx, this.replaceBindings.bind(this));\n                    // replace this key and all that come after to preserve insertion order\n                    replaceKeys = true;\n                }\n                if (replaceKeys) {\n                    delete obj[index];\n                    obj[newIndex || index] = val;\n                }\n            });\n        }\n    }\n}\n","/// <reference path=\"../lib/delta-client-lib.ts\" />\r\n/// <reference path=\"../lib/dashClient.ts\" />\r\n/// <reference path=\"../classes/Agent.ts\" />\r\n/// <reference path=\"../classes/ComponentInterface.ts\"/>\r\n/// <reference path=\"../classes/DataMapper.ts\" />\r\n/// <reference path=\"../classes/DataSet.ts\" />\r\n/// <reference path=\"../classes/DataSet2.ts\" />\r\n/// <reference path=\"../classes/log.ts\"/>\r\n/// <reference path=\"../classes/LegacyUpdate.ts\"/>\r\n/// <reference path=\"../classes/PerformanceMetrics.ts\"/>\r\n/// <reference path=\"../classes/viewStateBinding.ts\"/>\r\n/// <reference path=\"connection.ts\"/>\r\n/// <reference path=\"../lib/ipc/Parse.ts\" />\r\n/// <reference path=\"../lib/qb/QueryBuilder.ts\" />\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class DocumentDataModel extends Backbone.Model\r\n        implements Commandable, DataModelInterface {\r\n        static readonly DEFAULT_MAX_ROWS = null;\r\n        static readonly DEFAULT_PAGE_SIZE = 2000;\r\n        static readonly DEFAULT_PAGING = \"NONE\";\r\n        static readonly IMMATERIAL_ATTRIBUTES = [\"error\", \"queryStatus\"];\r\n        static readonly NO_DATA_ERROR_TEXT = \"No data returned from selected data source\";\r\n        static readonly PAGING_ATTRIBUTES = [\r\n            \"_pagingNum\",\r\n            \"_pageSize\",\r\n            \"_pagingType\",\r\n            \"_pageSort\",\r\n            \"_serverPaging\",\r\n        ];\r\n        static readonly PARAMETER_RX = new RegExp(\"<%([^<>%]+?)%>\", \"g\");\r\n        static readonly TYPES_TO_PARSE = [\r\n            \"date\",\r\n            \"datetime\",\r\n            \"guid\",\r\n            \"minute\",\r\n            \"month\",\r\n            \"second\",\r\n            \"time\",\r\n            \"timespan\",\r\n            \"timestamp\",\r\n        ];\r\n        static readonly VIEW_STATE_ATTRIBUTES = {\r\n            // attributes that can be bound to view states\r\n            analytic: {\r\n                _subscriptionInterval: \"onQuerySettingChange\",\r\n            },\r\n            pivot: {\r\n                _aggregateCols: \"onPivotSettingChange\",\r\n                _aggregateFns: \"onPivotSettingChange\",\r\n                _aggregateLabels: \"onPivotSettingChange\",\r\n                _breakdownCols: \"onPivotSettingChange\",\r\n            },\r\n            query: {\r\n                _subscriptionInterval: \"onQuerySettingChange\",\r\n            },\r\n        };\r\n        static readonly VIRTUAL_QUERY_REGEX = /^(function(?: )?\\()([a-z0-9A-Z,\\w\\/ ]+?)(,(?: +)?callback\\)(?: ){)([\\s\\S]+)(\\})$/;\r\n        static readonly AGGREGATE_COLS_PROP = \"_aggregateCols\";\r\n        static readonly AGGREGATE_LABELS_PROP = \"_aggregateLabels\";\r\n        static readonly OLD_THRESHOLD = 2000;\r\n        static readonly FAST_THRESHOLD = 10;\r\n        agent = new Agent();\r\n        callbacks = [];\r\n        clientPivotData: any;\r\n        dataMapper: DataMapper = null;\r\n        dataSet: DataSet = null;\r\n        dataSet2: DataSet2 = null;\r\n        debouncedParameterChange: Function;\r\n        execute: Function;\r\n        forceInternalReset = false;\r\n        forceRender?: boolean;\r\n        group: boolean;\r\n        isClone = false;\r\n        isDirty = false;\r\n        isPending = false;\r\n        legacyFlushFrame?: number;\r\n        legacyFlushTime = 0;\r\n        consolidateCount = 0;\r\n        dataExecuteSuccessCount = 0;\r\n        durationMovingAverage = DocumentDataModel.FAST_THRESHOLD;\r\n        deferredUpdate?: LegacyUpdate;\r\n        meta: any;\r\n        paramChanged = [];\r\n        parameterModels: Array<any> = [];\r\n        performance: PerformanceMetrics = new PerformanceMetrics();\r\n        path: string;\r\n        pollingEvent = null;\r\n        root: DocumentDataModel;\r\n        subscriptionId = null;\r\n        subscriptionTypes = [\"polling\", \"subscription\", \"streaming\"];\r\n        viewStateBindings: { [index: string]: ViewStateBinding } = {};\r\n        viewState: any;\r\n        virtualSubscriptions = {};\r\n\r\n        constructor(\r\n            attributes: Record<string, any>,\r\n            root: DocumentDataModel | null,\r\n            path: string,\r\n            viewState: any,\r\n            group?: boolean,\r\n            virtualSubscriptions?: Record<string, any>,\r\n        ) {\r\n            super(attributes);\r\n\r\n            const dataModels = [];\r\n\r\n            this.root = root || this;\r\n            this.path = path;\r\n            this.viewState = viewState;\r\n            this.group = group;\r\n            this.virtualSubscriptions = virtualSubscriptions || {};\r\n\r\n            // fix to avoid setting default _pagingType on a group\r\n            if (this.group) {\r\n                this.unset(\"_pagingType\", { silent: true });\r\n            }\r\n\r\n            // FIX PIVOT\r\n            if (!this.get(\"_queryString\") && (this.get(\"_pivotQuery\") || this.get(\"_table\"))) {\r\n                this.set(\r\n                    \"_queryString\",\r\n                    this.get(\"_pivotQuery\") || \"select from \" + this.get(\"_table\"),\r\n                );\r\n                this.unset(\"_pivotQuery\");\r\n                this.unset(\"_table\");\r\n            }\r\n\r\n            // convert each child object into a DocumentData Model\r\n            _.keys(this.attributes).forEach(key => {\r\n                const obj = this.get(key);\r\n\r\n                if (_.isArray(obj)) {\r\n                    // do nothing\r\n                } else if (_.isObject(obj) && !(obj instanceof Backbone.Model)) {\r\n                    // if dataType - it is a data source apply\r\n                    if (obj[\"_dataType\"]) {\r\n                        // HACK TODO\r\n                        if (obj[\"_dataType\"] === \"copy\") {\r\n                            obj[\"_dataType\"] = \"query\";\r\n                        }\r\n\r\n                        if (\r\n                            _.includes(\r\n                                [\"analytic\", \"streaming\", \"pivot\", \"query\", \"virtual\", \"builder\"],\r\n                                obj[\"_dataType\"],\r\n                            )\r\n                        ) {\r\n                            const model = new DocumentDataModel(\r\n                                obj,\r\n                                this.root,\r\n                                this.path ? this.path + \"/\" + key : key,\r\n                                this.viewState,\r\n                            );\r\n\r\n                            dataModels.push(model);\r\n                            this.set(key, model, { silent: true });\r\n\r\n                            // eslint-disable-next-line @typescript-eslint/unbound-method\r\n                            this.listenTo(model, \"materialChange\", this.onMaterialChange);\r\n                        } else {\r\n                            Log.Error(\r\n                                this.logPrefix() + \" unsupported datatype: \",\r\n                                obj[\"_dataType\"],\r\n                            );\r\n                        }\r\n                    } else if (obj[\"_dashboardsType\"] === \"viewstate\") {\r\n                        const model = this.viewState.getByPath(obj[\"value\"]);\r\n                        this.set(key, model, { silent: true });\r\n                    } else if (\r\n                        !_.includes([\"_analyticParams\", \"_mappings\", \"_pageSort\"], key) &&\r\n                        !(obj instanceof Backbone.Model && obj.get(\"_viewType\"))\r\n                    ) {\r\n                        const model = new DocumentDataModel(\r\n                            obj,\r\n                            this.root,\r\n                            this.path ? this.path + \"/\" + key : key,\r\n                            this.viewState,\r\n                            true,\r\n                        );\r\n\r\n                        this.set(key, model, { silent: true });\r\n                        this.listenTo(model, \"change\", () => this.trigger(\"change\", this));\r\n\r\n                        // eslint-disable-next-line @typescript-eslint/unbound-method\r\n                        this.listenTo(model, \"materialChange\", this.onMaterialChange);\r\n                    }\r\n                }\r\n            });\r\n\r\n            //fix: KXAX-11979\r\n            //reset settings, so data config popup doesn't reuse paging info from datagrid on the dashboard\r\n            if (this.has(\"_pagingNum\")) {\r\n                this.set(\"_pagingNum\", 0, { silent: true });\r\n            }\r\n            if (this.has(\"_pageSort\")) {\r\n                this.set(\"_pageSort\", {}, { silent: true });\r\n            }\r\n\r\n            this.debouncedParameterChange = _.throttle(this.applyParameterChange.bind(this), 60, {\r\n                leading: false,\r\n            });\r\n\r\n            // eslint-disable-next-line @typescript-eslint/unbound-method\r\n            this.listenTo(this, \"change\", this.onModelChange);\r\n        }\r\n\r\n        static convertDeltaClientColumnSpecToMeta(columnSpec): ColumnInfo[] {\r\n            //{\"columns\":[\"sym\",\"midprice\"],\"meta\":{\"sym\":11,\"midprice\":9}\r\n            return (columnSpec[\"columns\"] || []).map((col: string, i: number) => {\r\n                return {\r\n                    id: col,\r\n                    index: i,\r\n                    kdbType: columnSpec[\"meta\"][col],\r\n                };\r\n            });\r\n        }\r\n\r\n        static convertMetaToDeltaClientColumnSpec(columns: ColumnInfo[]): any {\r\n            return {\r\n                columns: _.map(columns, c => c.id),\r\n                meta: _.fromPairs(_.map(columns, c => [c.id, c.kdbType])),\r\n            };\r\n        }\r\n\r\n        apply(): void {\r\n            this.performance.trigger(\"apply\");\r\n            let isVirtual = false;\r\n            // components listen for change:error so we need an initial value that we can unset later\r\n            if (!this.has(\"error\")) {\r\n                this.set(\"error\", null, { silent: true });\r\n            }\r\n\r\n            if (this.get(\"_dataType\") === \"pivot\") {\r\n                this.set(\r\n                    {\r\n                        _dataType: \"query\",\r\n                        _pivotType: \"server\",\r\n                    },\r\n                    { silent: true },\r\n                );\r\n            }\r\n\r\n            // reset model state\r\n            this.stop();\r\n            this.reset();\r\n\r\n            if (this.get(\"_pivotType\")) {\r\n                this.applyPivot();\r\n            } else {\r\n                switch (this.get(\"_dataType\")) {\r\n                    case \"query\":\r\n                        this.applyQuery();\r\n                        break;\r\n                    case \"analytic\":\r\n                    case \"builder\":\r\n                    case \"streaming\":\r\n                        this.applyAnalytic();\r\n                        break;\r\n                    case \"copy\":\r\n                        this.applyCopy();\r\n                        break;\r\n                    case \"virtual\":\r\n                        this.applyVirtual();\r\n                        isVirtual = true;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            this.forceInternalReset = true;\r\n\r\n            if (isVirtual && this.performance) this.performance.trigger(\"serverStart\");\r\n            this.updateVirtualSubscriptions();\r\n            if (isVirtual && this.performance) this.performance.trigger(\"serverEnd\");\r\n\r\n            this.dataMapper = new DataMapper({\r\n                mappings: this.get(\"_mappings\"),\r\n                setMappings: (mappings): void => {\r\n                    this.set(\"_mappings\", mappings);\r\n                },\r\n                subscribe: (key, listener): void => this.subscribe(key, listener, !isVirtual),\r\n                unsubscribe: (key): void => this.unsubscribe(key),\r\n                viewState: this.viewState,\r\n            });\r\n\r\n            this.dataMapper.initialize();\r\n        }\r\n\r\n        applyCopy(): void {\r\n            const idAttribute = this.get(\"_subscriptionKey\") || DataSet.DEFAULT_ROW_INDEX;\r\n\r\n            // set up data set to receive data\r\n            this.dataSet = new DataSet({\r\n                idAttribute: idAttribute,\r\n                collectionFunc: Backbone.Collection.extend({\r\n                    model: Backbone.Model.extend({ idAttribute: idAttribute }),\r\n                }),\r\n                agent: this.agent,\r\n                maxRows: this.get(\"_maxRows\"),\r\n                primaryKey: idAttribute,\r\n            });\r\n\r\n            // set defaults\r\n            this.unset(\"error\");\r\n            this.unset(\"queryStatus\");\r\n            this.updateParameters();\r\n            this.execute = _.noop.bind(this);\r\n        }\r\n\r\n        applyAnalytic(): void {\r\n            const idAttribute = this.get(\"_subscriptionKey\") || DataSet.DEFAULT_ROW_INDEX;\r\n            const successFn = (data: qTyped, buffer: ArrayBuffer): void => {\r\n                this.onExecuteSubscriptionSuccess(data, this.get(\"_forceReset\"), buffer);\r\n            };\r\n            const errorFn = (error, ...args): void => {\r\n                this.onError(this, this.attributes, error, \"Error\", args);\r\n            };\r\n\r\n            let paging;\r\n            const viewStateOptions = this.applyViewStateAttributes();\r\n\r\n            // set up data set to receive data\r\n            this.dataSet = new DataSet({\r\n                idAttribute: idAttribute,\r\n                collectionFunc: Backbone.Collection.extend({\r\n                    model: Backbone.Model.extend({ idAttribute: idAttribute }),\r\n                }),\r\n                agent: this.agent,\r\n                maxRows: this.get(\"_maxRows\"),\r\n                primaryKey: idAttribute,\r\n            });\r\n\r\n            // set up data set to receive data\r\n            this.dataSet2 = new DataSet2({\r\n                idAttribute: idAttribute,\r\n                agent: this.agent,\r\n                maxRows: this.get(\"_maxRows\"),\r\n                primaryKey: idAttribute,\r\n            });\r\n\r\n            this.unset(\"error\");\r\n            this.unset(\"queryStatus\");\r\n            this.updateParameters(true);\r\n\r\n            if (this.get(\"_subscriptionType\") === \"subscription\") {\r\n                const subscriptionInterval = this.formatValue(\r\n                    viewStateOptions[\"_subscriptionInterval\"] as number,\r\n                    \"_subscriptionInterval\",\r\n                );\r\n\r\n                this.execute = this.wrapWithErrorHandler(\r\n                    () => {\r\n                        this.onExecuteBegin();\r\n                        if (this.get(\"_serverPaging\")) {\r\n                            paging = {\r\n                                type: this.getPagingType(),\r\n                                num: this.get(\"_pagingNum\") || 0,\r\n                                size: this.get(\"_pageSize\") || DocumentDataModel.DEFAULT_PAGE_SIZE,\r\n                                sorting: this.get(\"_pageSort\") || {},\r\n                            };\r\n                        }\r\n\r\n                        this.runWithConnectionCheck(errorFn, () => {\r\n                            this.updateBuilder(() => {\r\n                                DeltaClientLib.startManagedAnalytic2(\r\n                                    this.get(\"_selectedAnalytic\"),\r\n                                    this.get(\"_connection\"),\r\n                                    this.bindViewStateToKdbParams(this.get(\"_analyticParams\")),\r\n                                    successFn,\r\n                                    errorFn,\r\n                                    subscriptionInterval,\r\n                                    this.get(\"_maxRows\") || DocumentDataModel.DEFAULT_MAX_ROWS,\r\n                                    this.performance,\r\n                                );\r\n                            }, errorFn);\r\n                        });\r\n                    },\r\n                    this,\r\n                    this.attributes,\r\n                );\r\n            } else if (this.get(\"_subscriptionType\") === \"streaming\") {\r\n                this.execute = this.wrapWithErrorHandler(\r\n                    () => {\r\n                        this.updateBuilder(() => {\r\n                            this.onExecuteBegin();\r\n                            this.runWithConnectionCheck(errorFn, () => {\r\n                                DeltaClientLib.startStreamingAnalytic2(\r\n                                    this.get(\"_selectedAnalytic\"),\r\n                                    this.get(\"_connection\"),\r\n                                    this.bindViewStateToKdbParams(this.get(\"_analyticParams\")),\r\n                                    successFn,\r\n                                    errorFn,\r\n                                    this.performance,\r\n                                );\r\n                            });\r\n                        }, errorFn);\r\n                    },\r\n                    this,\r\n                    this.attributes,\r\n                );\r\n            } else {\r\n                this.execute = this.wrapWithErrorHandler(\r\n                    () => {\r\n                        this.updateBuilder(() => {\r\n                            this.onExecuteBegin();\r\n\r\n                            if (this.get(\"_serverPaging\")) {\r\n                                paging = {\r\n                                    type: this.getPagingType(),\r\n                                    num: this.get(\"_pagingNum\") || 0,\r\n                                    size:\r\n                                        this.get(\"_pageSize\") ||\r\n                                        DocumentDataModel.DEFAULT_PAGE_SIZE,\r\n                                    sorting: this.get(\"_pageSort\") || {},\r\n                                };\r\n                            }\r\n\r\n                            this.runWithConnectionCheck(errorFn, () => {\r\n                                DeltaClientLib.runAnalytic2(\r\n                                    this.get(\"_selectedAnalytic\"),\r\n                                    this.get(\"_connection\"),\r\n                                    this.bindViewStateToKdbParams(this.get(\"_analyticParams\")),\r\n                                    successFn,\r\n                                    errorFn,\r\n                                    this.get(\"_maxRows\") || DocumentDataModel.DEFAULT_MAX_ROWS,\r\n                                    paging,\r\n                                    this.performance,\r\n                                );\r\n                            });\r\n                        }, errorFn);\r\n                    },\r\n                    this,\r\n                    this.attributes,\r\n                );\r\n            }\r\n        }\r\n\r\n        updateBuilder(success, error): void {\r\n            // return if not builder\r\n            if (this.get(\"_dataType\") !== \"builder\") {\r\n                success();\r\n                return;\r\n            }\r\n\r\n            // set analytic name\r\n            const isStreaming = this.get(\"_subscriptionType\") === \"streaming\";\r\n            const queryBuilderApp = new QuickBase.QueryBuilder.App();\r\n            const qIPC = queryBuilderApp.getIPC(\r\n                this.get(\"_graphJSON\"),\r\n                this.get(\"_selectedNode\"),\r\n                this,\r\n            );\r\n\r\n            if (isStreaming) {\r\n                this.set(\"_selectedAnalytic\", qIPC);\r\n                this.set(\"_analyticParams\", [], { silent: true });\r\n            } else {\r\n                this.set(\"_selectedAnalytic\", \".queryBuilder.processGraph2\");\r\n\r\n                // set analytic params\r\n                this.set(\r\n                    \"_analyticParams\",\r\n                    [\r\n                        {\r\n                            id: \"graph\",\r\n                            name: \"graph\",\r\n                            index: 0,\r\n                            type: isStreaming ? \"symbol\" : \"string\",\r\n                            value: qIPC,\r\n                        },\r\n                    ],\r\n                    { silent: true },\r\n                );\r\n            }\r\n\r\n            success();\r\n        }\r\n\r\n        runWithConnectionCheck(errorFn, func): void {\r\n            const connection = this.get(\"_connection\");\r\n            const ignoreNullConnectionCheck = this.get(\"_ignoreNullConnectionCheck\");\r\n\r\n            if (ignoreNullConnectionCheck) {\r\n                func();\r\n            } else if (connection === undefined || connection === null || connection === \"DC\") {\r\n                errorFn({\r\n                    message: \"Invalid connection specified\",\r\n                });\r\n            } else {\r\n                func();\r\n            }\r\n        }\r\n\r\n        applyPivot(): void {\r\n            let breakdownCols = this.get(\"_breakdownCols\"),\r\n                lastModel;\r\n\r\n            const options = {\r\n                dataSource: this.get(\"_dataSource\"),\r\n                connection: this.get(\"_connection\"),\r\n                pivotSource: \"query\",\r\n\r\n                // upgrade old table value to query\r\n                queryString: this.get(\"_queryString\"),\r\n                queryParams: this.get(\"_queryParams\"),\r\n                breakdownCols: this.get(\"_breakdownCols\"),\r\n                aggFn: this.get(\"_aggFn\"),\r\n                ordering: this.get(\"_ordering\"),\r\n                maxRows: this.get(\"_maxRows\"),\r\n                subscriptionType: this.get(\"_subscriptionType\"),\r\n                subscriptionInterval: this.get(\"_subscriptionInterval\"),\r\n                columnLabel: this.get(\"_columnLabel\"),\r\n            };\r\n            const viewStateOptions = this.applyViewStateAttributes();\r\n\r\n            _.each(viewStateOptions, (value, key) => {\r\n                if (key === \"_subscriptionInterval\") {\r\n                    viewStateOptions[key] = this.formatValue(\r\n                        value as number,\r\n                        \"_subscriptionInterval\",\r\n                    );\r\n                } else {\r\n                    // trim unnecessary whitespace and try to split strings in arrays\r\n                    if (_.isString(value)) {\r\n                        viewStateOptions[key] = value.trim();\r\n                        viewStateOptions[key] = value.split(\",\");\r\n                    }\r\n                }\r\n\r\n                // DeltaClientLib expects attributes without _ prefix\r\n                options[key.replace(\"_\", \"\")] = value;\r\n            });\r\n\r\n            breakdownCols = options[\"breakdownCols\"];\r\n\r\n            lastModel = Backbone.Model.extend({\r\n                idAttribute: _.last(breakdownCols),\r\n                getRoot: () => this,\r\n            });\r\n\r\n            // loop calculating values from the level n bottom up to level 0\r\n            _.each(breakdownCols, (breakdownEl, i: number) => {\r\n                const localOptions = {};\r\n\r\n                // calc ids for generate pivot model\r\n                const childId = breakdownCols[breakdownCols.length - i - 1];\r\n                const id =\r\n                    i === breakdownCols.length - 1\r\n                        ? \"id\"\r\n                        : breakdownCols[breakdownCols.length - i - 2];\r\n\r\n                // DEBUG\r\n                //console.log(\"id:\" + id, breakdownCols.slice(0, breakdownCols.length - i), breakdownCols.slice(0, breakdownCols.length - i - 1));\r\n\r\n                // calc local options object for generate pivot model\r\n                _.extend(localOptions, options, {\r\n                    dimensions: breakdownCols.slice(0, breakdownCols.length - i),\r\n                    wheres: breakdownCols.slice(0, breakdownCols.length - i - 1),\r\n                    id: id,\r\n                });\r\n\r\n                // generate pivot model - using previous as inner child\r\n                lastModel = this.generatePivotModel(id, childId, lastModel, localOptions);\r\n            });\r\n\r\n            this.unset(\"error\");\r\n            this.unset(\"queryStatus\");\r\n            this.updateParameters();\r\n\r\n            _.extend(this, {\r\n                dataSet: new DataSet({\r\n                    idAttribute: lastModel.prototype.childId,\r\n                    collectionFunc: Backbone.Collection.extend({\r\n                        model: lastModel.prototype.childModelType || lastModel,\r\n                    }),\r\n                    agent: this.agent,\r\n                    maxRows: options.maxRows,\r\n                    primaryKey: lastModel.prototype.childId,\r\n                }),\r\n                dataSet2: new DataSet2({\r\n                    idAttribute: lastModel.prototype.childId,\r\n                    agent: this.agent,\r\n                    maxRows: options.maxRows,\r\n                    primaryKey: lastModel.prototype.childId,\r\n                }),\r\n                execute: lastModel.prototype.execute || _.noop.bind(this),\r\n                exportPivotData: lastModel.prototype.exportPivotData,\r\n                staticIdAttribute: lastModel.staticIdAttribute,\r\n            });\r\n        }\r\n\r\n        applyQuery(): void {\r\n            const idAttribute = this.get(\"_subscriptionKey\") || DataSet.DEFAULT_ROW_INDEX;\r\n            const successFn = (data: any, buffer: ArrayBuffer): void => {\r\n                this.onExecuteSubscriptionSuccess(data, this.get(\"_forceReset\"), buffer);\r\n            };\r\n            const errorFn = (error, ...args): void => {\r\n                this.onError(this, this.attributes, error, \"Error\", args);\r\n            };\r\n\r\n            const viewStateOptions = this.applyViewStateAttributes();\r\n\r\n            // set up data set to receive data\r\n            this.dataSet = new DataSet({\r\n                idAttribute: idAttribute,\r\n                collectionFunc: Backbone.Collection.extend({\r\n                    model: Backbone.Model.extend({ idAttribute: idAttribute }),\r\n                }),\r\n                agent: this.agent,\r\n                lazyLoading: this.get(\"_lazyLoading\"),\r\n                maxRows: this.get(\"_maxRows\"),\r\n                primaryKey: idAttribute,\r\n            });\r\n\r\n            // set up data set to receive data\r\n            this.dataSet2 = new DataSet2({\r\n                idAttribute: idAttribute,\r\n                agent: this.agent,\r\n                lazyLoading: this.get(\"_lazyLoading\"),\r\n                maxRows: this.get(\"_maxRows\"),\r\n                primaryKey: idAttribute,\r\n            });\r\n\r\n            // set defaults\r\n            this.unset(\"error\");\r\n            this.unset(\"queryStatus\");\r\n            this.updateParameters();\r\n\r\n            if (this.get(\"_subscriptionType\") === \"subscription\") {\r\n                const subscriptionInterval = this.formatValue(\r\n                    viewStateOptions[\"_subscriptionInterval\"] as number,\r\n                    \"_subscriptionInterval\",\r\n                );\r\n\r\n                this.execute = this.wrapWithErrorHandler(\r\n                    () => {\r\n                        let paging = null;\r\n\r\n                        this.onExecuteBegin();\r\n                        const query = this.replaceViewStateParams(this.get(\"_queryString\"));\r\n\r\n                        if (this.get(\"_serverPaging\")) {\r\n                            paging = {\r\n                                type: this.getPagingType(),\r\n                                num: this.get(\"_pagingNum\") || 0,\r\n                                size: this.get(\"_pageSize\") || DocumentDataModel.DEFAULT_PAGE_SIZE,\r\n                                sorting: this.get(\"_pageSort\") || {},\r\n                            };\r\n                        }\r\n\r\n                        this.runWithConnectionCheck(errorFn, () => {\r\n                            DeltaClientLib.startManagedQuery2(\r\n                                this.get(\"_connection\"),\r\n                                query,\r\n                                this.bindViewStateToKdbParams(this.get(\"_queryParams\")),\r\n                                successFn,\r\n                                errorFn,\r\n                                subscriptionInterval,\r\n                                this.get(\"_maxRows\") || DocumentDataModel.DEFAULT_MAX_ROWS,\r\n                                paging,\r\n                                this.performance,\r\n                            );\r\n                        });\r\n                    },\r\n                    this,\r\n                    this.attributes,\r\n                );\r\n            } else {\r\n                this.execute = this.wrapWithErrorHandler(\r\n                    () => {\r\n                        let paging = null;\r\n\r\n                        this.onExecuteBegin();\r\n                        const query = this.replaceViewStateParams(this.get(\"_queryString\"));\r\n\r\n                        if (this.get(\"_serverPaging\")) {\r\n                            paging = {\r\n                                type: this.getPagingType(),\r\n                                num: this.get(\"_pagingNum\") || 0,\r\n                                size: this.get(\"_pageSize\") || DocumentDataModel.DEFAULT_PAGE_SIZE,\r\n                                sorting: this.get(\"_pageSort\") || {},\r\n                            };\r\n                        }\r\n\r\n                        this.runWithConnectionCheck(errorFn, () => {\r\n                            DeltaClientLib.getQueryData2(\r\n                                this.get(\"_dataSource\"),\r\n                                this.get(\"_connection\"),\r\n                                query,\r\n                                this.bindViewStateToKdbParams(this.get(\"_queryParams\")),\r\n                                successFn,\r\n                                errorFn,\r\n                                this.get(\"_maxRows\") || DocumentDataModel.DEFAULT_MAX_ROWS,\r\n                                paging,\r\n                                this.performance,\r\n                            );\r\n                        });\r\n                    },\r\n                    this,\r\n                    this.attributes,\r\n                );\r\n            }\r\n        }\r\n\r\n        applyVirtual(): void {\r\n            const idAttribute = this.get(\"_subscriptionKey\") || DataSet.DEFAULT_ROW_INDEX;\r\n            const successFn = (data: DCDS, buffer: ArrayBuffer): void => {\r\n                this.onExecuteSuccess(data, this.get(\"_forceReset\"), buffer);\r\n            };\r\n\r\n            // set up data set to receive data\r\n            this.dataSet = new DataSet({\r\n                idAttribute: idAttribute,\r\n                collectionFunc: Backbone.Collection.extend({\r\n                    model: Backbone.Model.extend({ idAttribute: idAttribute }),\r\n                }),\r\n                agent: this.agent,\r\n                // not possible to edit number of rows on virtual source in Data Dialog\r\n                // set to max int\r\n                maxRows: 9007199254740991,\r\n                primaryKey: idAttribute,\r\n            });\r\n\r\n            // set defaults\r\n            this.unset(\"error\");\r\n            this.unset(\"queryStatus\");\r\n            this.updateParameters();\r\n\r\n            this.execute = this.wrapWithErrorHandler(\r\n                function() {\r\n                    this.onExecuteBegin();\r\n                    // need to update subscriptions in the event you toggle between\r\n                    // different virtual data sources\r\n                    this.updateVirtualSubscriptions();\r\n                    this.executeVirtualQuery(\r\n                        this.get(\"_virtualQueryString\"),\r\n                        this.get(\"_virtualParams\"),\r\n                        successFn,\r\n                    );\r\n                },\r\n                this,\r\n                this.attributes,\r\n            );\r\n        }\r\n\r\n        applyParameterChange(): void {\r\n            let forceExecute, isApplyRequired;\r\n\r\n            if (this.paramChanged && this.paramChanged.length) {\r\n                forceExecute = !!_.find(this.paramChanged, o => o === \"#forced\");\r\n                isApplyRequired = !!_.find(this.paramChanged, o => o.runApply);\r\n\r\n                Log.Info(this.logPrefix() + \"apply parameter change\", this.paramChanged);\r\n                this.paramChanged = [];\r\n\r\n                if (this.agent.subscriberCount()) {\r\n                    if (isApplyRequired) {\r\n                        this.apply();\r\n                        this.start();\r\n                    } else if (this.isPending) {\r\n                        this.isDirty = true;\r\n                    } else {\r\n                        this.isDirty = this.isDirty || forceExecute;\r\n                        this.performance.trigger(\"paramChange\");\r\n                        this.start();\r\n                    }\r\n                } else if (forceExecute) {\r\n                    if (!this.dataSet) {\r\n                        this.apply();\r\n                    }\r\n\r\n                    this.execute();\r\n                }\r\n            }\r\n        }\r\n\r\n        applyViewStateAttributes(): { [index: string]: number | string | string[] } {\r\n            const attributes = {};\r\n            const viewStateAttributes =\r\n                _.clone(DocumentDataModel.VIEW_STATE_ATTRIBUTES[this.get(\"_dataType\")]) || {};\r\n\r\n            let unusedBindings = _.clone(this.viewStateBindings);\r\n\r\n            if (this.get(\"_pivotType\")) {\r\n                _.extend(viewStateAttributes, DocumentDataModel.VIEW_STATE_ATTRIBUTES[\"pivot\"]);\r\n            }\r\n\r\n            _.each(viewStateAttributes, (callback, att) => {\r\n                let value = this.get(att);\r\n\r\n                const existingBinding = _.findKey(unusedBindings, function(binding, key) {\r\n                    return key === att && binding.callback === callback && binding.model === value;\r\n                });\r\n\r\n                if (existingBinding) {\r\n                    // keep existing binding\r\n                    unusedBindings = _.omit(unusedBindings, existingBinding);\r\n                    value = value.get(\"value\");\r\n                } else {\r\n                    // if it's assigned to a view state then add a new binding\r\n                    if (value instanceof Backbone.Model) {\r\n                        this.listenTo(value, \"change:value\", this[callback]);\r\n                        this.viewStateBindings[att] = new ViewStateBinding(\r\n                            callback,\r\n                            value as DocumentViewModel,\r\n                        );\r\n                        value = value.get(\"value\");\r\n                    }\r\n                }\r\n\r\n                attributes[att] = value;\r\n            });\r\n\r\n            //fix: labels length not matching columns length\r\n            if (\r\n                this.get(\"_pivotType\") &&\r\n                attributes[DocumentDataModel.AGGREGATE_COLS_PROP] &&\r\n                attributes[DocumentDataModel.AGGREGATE_LABELS_PROP] &&\r\n                attributes[DocumentDataModel.AGGREGATE_COLS_PROP].length !==\r\n                    attributes[DocumentDataModel.AGGREGATE_LABELS_PROP].length\r\n            ) {\r\n                Log.Warn(this.logPrefix() + \"invalid aggregate labels length\");\r\n                attributes[DocumentDataModel.AGGREGATE_LABELS_PROP] = [];\r\n            }\r\n\r\n            // stop listening to unused models\r\n            _.each(unusedBindings, binding => {\r\n                this.stopListening(binding.model, \"change:value\", binding.callback);\r\n            });\r\n\r\n            return attributes;\r\n        }\r\n\r\n        //Parse params to look for viewstate parameters\r\n        bindViewStateToKdbParams(queryParams): any[] {\r\n            let typeName, typeDef, paramPath;\r\n            const newParams = [];\r\n\r\n            //Copy params array so we don't trigger an update event on the model\r\n            $.extend(true, newParams, queryParams);\r\n\r\n            //Replace viewstate parameters with values on relevent kdb query parameters\r\n            if (newParams && newParams.length > 0) {\r\n                newParams.forEach(queryParam => {\r\n                    if (typeof queryParam.value === \"string\") {\r\n                        paramPath = queryParam.value.match(DocumentDataModel.PARAMETER_RX);\r\n                        if (paramPath) {\r\n                            const viewModel = this.getViewState().getByPath(\r\n                                $.trim(paramPath[0].substring(2, paramPath[0].length - 2)),\r\n                            );\r\n\r\n                            if (viewModel) {\r\n                                const val = _.isFunction(viewModel.get)\r\n                                    ? viewModel.get(\"value\")\r\n                                    : viewModel[\"value\"];\r\n                                if (val === undefined) {\r\n                                    queryParam.value = null;\r\n                                }\r\n\r\n                                queryParam.value =\r\n                                    _.isObject(val) && !_.isArray(val)\r\n                                        ? $.extend(true, {}, val)\r\n                                        : val;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // dict types - replace viewstate path with viewstate value\r\n                    if (queryParam.type === \"dict\" && _.isObject(queryParam.value)) {\r\n                        _.keys(queryParam.value).forEach(key => {\r\n                            if (queryParam.value[key] instanceof Backbone.Model) {\r\n                                queryParam.value[key] = {\r\n                                    type: queryParam.value[key].get(\"_type\"),\r\n                                    IsKdbParam: true,\r\n                                    isViewState: true,\r\n                                    name: queryParam.value[key].path,\r\n                                    value: queryParam.value[key].get(\"value\"),\r\n                                };\r\n                            } else if (typeof queryParam.value[key] === \"object\") {\r\n                                //when no viewstates present (e.g. in ActionTracker, DDM is created without viewstates),\r\n                                // no conversion is required for dictionary values\r\n                                if (_.has(queryParam.value[key], \"_isKdbReady\")) return;\r\n\r\n                                // Update value\r\n                                if (\r\n                                    typeof queryParam.value[key].value === \"string\" &&\r\n                                    queryParam.value[key].value.indexOf(\"<%\") === 0\r\n                                ) {\r\n                                    // path to view state is in the value of the object\r\n                                    const queryPath = $.trim(\r\n                                        queryParam.value[key].value.substring(\r\n                                            2,\r\n                                            queryParam.value[key].value.length - 2,\r\n                                        ),\r\n                                    );\r\n                                    const viewModel = this.getViewState().getByPath(queryPath);\r\n                                    if (viewModel) {\r\n                                        queryParam.value[key].type = viewModel.get(\"_type\");\r\n                                        queryParam.value[key].value = viewModel.get(\"value\");\r\n                                    }\r\n                                }\r\n                            } else if (typeof queryParam.value[key] === \"string\") {\r\n                                // Generate parameter\r\n                                let queryPath: string;\r\n\r\n                                if (queryParam.value[key].indexOf(\"<%\") === 0) {\r\n                                    queryPath = $.trim(\r\n                                        queryParam.value[key].substring(\r\n                                            2,\r\n                                            queryParam.value[key].length - 2,\r\n                                        ),\r\n                                    );\r\n\r\n                                    const viewModel = this.getViewState().getByPath(queryPath);\r\n\r\n                                    if (viewModel) {\r\n                                        queryParam.value[key] = {\r\n                                            type: viewModel.get(\"_type\"),\r\n                                            IsKdbParam: true,\r\n                                            isViewState: true,\r\n                                            name: queryParam.value[key],\r\n                                            value: viewModel.get(\"value\"),\r\n                                        };\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            // apply toKDBInput\r\n                            typeName = queryParam.value[key].type;\r\n                            typeDef = typeName ? RTTI.getByName(typeName) : null;\r\n                            if (typeDef && typeDef.toKDBInput) {\r\n                                queryParam.value[key].value = _.includes(\r\n                                    DocumentDataModel.TYPES_TO_PARSE,\r\n                                    typeName,\r\n                                )\r\n                                    ? typeDef.toKDBInput(queryParam.value[key].value)\r\n                                    : queryParam.value[key].value;\r\n                                Log.Info(\r\n                                    this.logPrefix() +\r\n                                        \"View State  Binding [\" +\r\n                                        queryParam.name +\r\n                                        \"]\",\r\n                                    queryParam.value[key].value,\r\n                                );\r\n                            }\r\n                        });\r\n                    } else {\r\n                        typeName = queryParam.type;\r\n                        typeDef = RTTI.getByName(typeName);\r\n                        if (typeDef) {\r\n                            if (typeDef.name !== \"dict\" && typeDef.toKDBInput) {\r\n                                queryParam.value = _.includes(\r\n                                    DocumentDataModel.TYPES_TO_PARSE,\r\n                                    typeName,\r\n                                )\r\n                                    ? typeDef.toKDBInput(queryParam.value)\r\n                                    : queryParam.value;\r\n                                Log.Info(\r\n                                    this.logPrefix() +\r\n                                        \"View State  Binding [\" +\r\n                                        queryParam.name +\r\n                                        \"]\",\r\n                                    queryParam.value,\r\n                                );\r\n                            } else if (typeDef.name === \"dict\") {\r\n                                // items dilimeter\r\n                                const dictItems = queryParam.value.split(\"\\u0002\");\r\n                                const paramValue = {};\r\n\r\n                                dictItems.forEach(item => {\r\n                                    // item properies dilimeter\r\n                                    const parts = item.split(\"\\u0001\");\r\n\r\n                                    if (parts.length === 6) {\r\n                                        // key is name\r\n                                        paramValue[parts[0]] = {\r\n                                            type: parts[1],\r\n                                            IsKdbParam: true,\r\n                                            isViewState: true,\r\n                                            name: parts[0],\r\n                                            value: parts[2],\r\n                                        };\r\n                                    }\r\n                                });\r\n\r\n                                queryParam.value = paramValue;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            return newParams;\r\n        }\r\n\r\n        clearVirtualSubscriptions(keys): void {\r\n            _.each(keys, key => {\r\n                const subscription = this.virtualSubscriptions[key];\r\n\r\n                if (subscription) {\r\n                    if (subscription instanceof DocumentDataModel) {\r\n                        subscription.unsubscribe(key);\r\n                    }\r\n\r\n                    delete this.virtualSubscriptions[key];\r\n                }\r\n            });\r\n        }\r\n\r\n        //clears all virtual subscription\r\n        clearVirtualSubscriptionsAll(): void {\r\n            const keys = _.keys(this.virtualSubscriptions);\r\n            this.clearVirtualSubscriptions(keys);\r\n        }\r\n\r\n        clone(): DocumentDataModel {\r\n            const clone = new DocumentDataModel(\r\n                this.attributes,\r\n                this.root,\r\n                this.path,\r\n                this.viewState,\r\n                this.group,\r\n            );\r\n\r\n            //_.each(['dataSet', 'path', 'viewState'], function (key) {\r\n            //    clone[key] = this[key];\r\n            //}, this);\r\n            clone.isClone = true;\r\n\r\n            return clone;\r\n        }\r\n\r\n        defaults(): any {\r\n            return { _pagingType: \"NONE\" };\r\n        }\r\n\r\n        destroy(): void {\r\n            // stop fetching data\r\n            this.stop();\r\n            this.reset();\r\n\r\n            if (this.agent) {\r\n                this.agent.unsubscribeAll();\r\n            }\r\n\r\n            Backbone.Model.prototype.destroy.call(this);\r\n        }\r\n\r\n        determineMaterialChange(): void {\r\n            if (\r\n                this.changed &&\r\n                !_.isEmpty(_.omit(this.changed, DocumentDataModel.IMMATERIAL_ATTRIBUTES))\r\n            ) {\r\n                this.trigger(\"materialChange\");\r\n            }\r\n        }\r\n\r\n        doCommand(path: Array<string>, todos: Array<Todo>): void {\r\n            if (path.length > 0) {\r\n                const vsPath = path.reverse().join(\"/\");\r\n                return this.getByPath(vsPath).doCommand(path, todos);\r\n            }\r\n\r\n            //TODO: do something its your command\r\n        }\r\n\r\n        executeClientPivotQuery(base: DCDS, options) {\r\n            const data = {\r\n                columns: [],\r\n                meta: {},\r\n                rows: [],\r\n            };\r\n\r\n            // check no data\r\n            if (!base) {\r\n                return data;\r\n            }\r\n\r\n            const aggregateCols = this.getViewStateAttribute(\"_aggregateCols\") || [];\r\n            const aggregateFns = this.getViewStateAttribute(\"_aggregateFns\") || [];\r\n            let aggregateLabels = this.getViewStateAttribute(\"_aggregateLabels\") || [];\r\n            const breakdownCols: string[] = this.getViewStateAttribute(\"_breakdownCols\") || [];\r\n            const aggregateCompare = aggregateCols.map(c =>\r\n                Tools.getComparator(base.meta[c] || 0, a => a),\r\n            );\r\n\r\n            aggregateLabels = _.map(aggregateCols, function(aggregateCol, i) {\r\n                return aggregateLabels[i] || aggregateCol;\r\n            });\r\n\r\n            let wheres = options && options.wheres ? options.wheres : [];\r\n\r\n            // only include wheres that match breakdownCols\r\n            wheres = _.filter(wheres, function(where, i) {\r\n                // use meta to pick comparator\r\n                where.comparator = Tools.getComparator(base.meta[where.columnName] || 0, a => a);\r\n                return where.columnName === breakdownCols[i];\r\n            });\r\n\r\n            // determine current breakdown columns\r\n            const currentBreakdownCols = _.take(breakdownCols, wheres.length + 1);\r\n\r\n            // get the last breakdown column to group by and compare\r\n            const lastBreakdown: string = _.last(currentBreakdownCols);\r\n            const groupCompare = Tools.getComparator(\r\n                base.meta[lastBreakdown] || 0,\r\n                b => b[lastBreakdown],\r\n            );\r\n\r\n            // for each row in data\r\n            base.rows.forEach(row => {\r\n                // filter the rows by the where clauses\r\n                let j = 0;\r\n                for (; j < wheres.length; j++) {\r\n                    const w = wheres[j];\r\n                    if (w.comparator(w[\"columnValue\"], row[w[\"columnName\"]]) !== 0) {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (j < wheres.length) return;\r\n\r\n                // update groups\r\n                const key = row[lastBreakdown];\r\n                const groupIndex = Tools.binarySearch2(key, data.rows, groupCompare);\r\n                let group;\r\n\r\n                if (groupIndex < 0) {\r\n                    group = _.pick(row, currentBreakdownCols);\r\n                    data.rows.splice(-groupIndex - 1, 0, group);\r\n\r\n                    // initialize group\r\n                    aggregateLabels.forEach((label, i) => {\r\n                        if (aggregateFns[i] === \"count\") {\r\n                            group[label] = 0;\r\n                        } else if (_.includes([\"max\", \"min\", \"sum\"], aggregateFns[i])) {\r\n                            group[label] = null;\r\n                        } else {\r\n                            group[label] = [];\r\n                        }\r\n                    });\r\n                } else group = data.rows[groupIndex];\r\n\r\n                // update aggregate columns on existing group\r\n                aggregateCols.forEach((col, i) => {\r\n                    const fn = aggregateFns[i],\r\n                        label = aggregateLabels[i];\r\n\r\n                    // update our aggregate with the new value\r\n                    switch (fn) {\r\n                        case \"count\":\r\n                            group[label] += 1;\r\n                            break;\r\n                        case \"max\":\r\n                            if (\r\n                                row[col] !== null &&\r\n                                (group[label] === null ||\r\n                                    aggregateCompare[i](group[label], row[col]) === -1)\r\n                            ) {\r\n                                group[label] = row[col];\r\n                            }\r\n                            break;\r\n                        case \"min\":\r\n                            if (\r\n                                row[col] !== null &&\r\n                                (group[label] === null ||\r\n                                    aggregateCompare[i](group[label], row[col]) === 1)\r\n                            ) {\r\n                                group[label] = row[col];\r\n                            }\r\n                            break;\r\n                        case \"sum\":\r\n                            if (row[col] !== null) {\r\n                                group[label] += Number(row[col]);\r\n                            }\r\n                            break;\r\n                        default:\r\n                            // custom function or avg\r\n                            group[label] = group[label] || [];\r\n                            group[label].push(row);\r\n                            break;\r\n                    }\r\n                });\r\n            });\r\n\r\n            // post process custom fns and averages\r\n            if (!_.every(aggregateFns, a => _.includes([\"count\", \"max\", \"min\", \"sum\"], a))) {\r\n                data.rows.forEach(row => {\r\n                    aggregateLabels.forEach((label, j) => {\r\n                        let d = row[label];\r\n                        const fn = aggregateFns[j];\r\n\r\n                        if (_.isArray(d)) {\r\n                            switch (fn) {\r\n                                case \"avg\":\r\n                                    // avg function requires number type\r\n                                    d = _.map(d, v =>\r\n                                        _.transform(v, (acc, val, key) => (acc[key] = Number(val))),\r\n                                    );\r\n                                    row[label] = _.meanBy(d, aggregateCols[j]);\r\n                                    break;\r\n                                case \"first\":\r\n                                    row[label] = _.first(d)[aggregateCols[j]];\r\n                                    break;\r\n                                case \"last\":\r\n                                    row[label] = _.last(d)[aggregateCols[j]];\r\n                                    break;\r\n                                default:\r\n                                    // custom function\r\n                                    row[label] = this.executeUserJavascript(fn, [\"data\"], [d]);\r\n                                    break;\r\n                            }\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n\r\n            // add breakdown columns and set meta\r\n            _.each(currentBreakdownCols, function(breakdownCol) {\r\n                data[\"columns\"].push(breakdownCol);\r\n                data[\"meta\"][breakdownCol] = base.meta[breakdownCol] || 11;\r\n            });\r\n\r\n            // add labelled aggregate columns and set meta\r\n            _.each(aggregateCols, function(aggregateCol, i) {\r\n                data[\"columns\"].push(aggregateLabels[i]);\r\n                data[\"meta\"][aggregateLabels[i]] = base.meta[aggregateCol] || 11;\r\n            });\r\n\r\n            return data;\r\n        }\r\n\r\n        executeUserJavascript(fnBody, paramNames, paramValues): void {\r\n            try {\r\n                const fn = new Function(paramNames, fnBody);\r\n                return fn.apply({}, paramValues);\r\n            } catch (error) {\r\n                // try to get the line/col in the user's code that's triggering the error\r\n                const errorParts = /<anonymous>:(\\d+):(\\d+)/.exec(error.stack);\r\n\r\n                if (errorParts && errorParts.length === 3) {\r\n                    const line = Number(errorParts[1]);\r\n                    const col = Number(errorParts[2]);\r\n                    throw error.message + \" (\" + (line - 2) + \":\" + col + \")\";\r\n                }\r\n\r\n                throw error.message;\r\n            }\r\n        }\r\n\r\n        executeVirtualQuery(query, params, success): void {\r\n            const fnParts = DocumentDataModel.VIRTUAL_QUERY_REGEX.exec(query),\r\n                paramNames = [],\r\n                paramValues = [];\r\n            let shallowCloneRequired = false,\r\n                fnBody;\r\n\r\n            if (!fnParts) {\r\n                // not in the required function format\r\n                throw \"Invalid function definition\";\r\n            }\r\n\r\n            _.each(params, (param): void => {\r\n                let key, paramSource;\r\n\r\n                switch (param.type) {\r\n                    case \"datasource\":\r\n                        key = this.path + \"_\" + param.value;\r\n\r\n                        if (this.get(\"isSourceDataDialog\")) {\r\n                            key += \"#edit\";\r\n                        }\r\n\r\n                        paramNames.push(param.name);\r\n                        paramSource = this.virtualSubscriptions[key];\r\n\r\n                        if (paramSource) {\r\n                            const sourcePk =\r\n                                paramSource.get(\"_subscriptionKey\") || DataSet.DEFAULT_ROW_INDEX;\r\n                            const targetPk =\r\n                                this.get(\"_subscriptionKey\") || DataSet.DEFAULT_ROW_INDEX;\r\n\r\n                            shallowCloneRequired =\r\n                                shallowCloneRequired ||\r\n                                (targetPk === DataSet.DEFAULT_ROW_INDEX &&\r\n                                    (sourcePk === DataSet.DEFAULT_ROW_INDEX ||\r\n                                        paramSource.get(\"_dataType\") === \"virtual\"));\r\n\r\n                            // get columns/meta into the correct format and add rows from our data collection\r\n                            paramValues.push(\r\n                                _.extend(\r\n                                    DocumentDataModel.convertMetaToDeltaClientColumnSpec(\r\n                                        paramSource.dataSet\r\n                                            ? _.sortBy(\r\n                                                  paramSource.dataSet.columns.map(\r\n                                                      c => c.attributes,\r\n                                                  ),\r\n                                                  \"index\",\r\n                                              )\r\n                                            : [],\r\n                                    ),\r\n                                    {\r\n                                        rows: paramSource.dataSet\r\n                                            ? paramSource.dataSet.collection.models.map(\r\n                                                  m => m.attributes,\r\n                                              )\r\n                                            : [],\r\n                                    },\r\n                                ),\r\n                            );\r\n                        } else {\r\n                            paramValues.push(null);\r\n                        }\r\n                        break;\r\n                    case \"text\":\r\n                        // simple text, use value as given\r\n                        paramNames.push(param.name);\r\n                        paramValues.push(param.value);\r\n                        break;\r\n                    case \"viewstate\":\r\n                        paramNames.push(param.name);\r\n                        paramSource = this.viewState.getByPath(param.value);\r\n\r\n                        if (paramSource) {\r\n                            // use the viewstate value\r\n                            paramValues.push(paramSource.get(\"value\"));\r\n                        } else {\r\n                            paramValues.push(null);\r\n                        }\r\n                        break;\r\n                }\r\n            });\r\n\r\n            // define our callback function\r\n            paramNames.push(\"callback\");\r\n            paramValues.push(function(result) {\r\n                // shallow clone attributes\r\n                // this is required where the dataset will re-index rows on _rowIndex\r\n                if (result.rows && shallowCloneRequired) {\r\n                    result.rows = result.rows.map(r => Object.assign({}, r));\r\n                }\r\n                success(result);\r\n            });\r\n\r\n            paramNames.push(\"Tools\");\r\n            paramValues.push(Tools);\r\n\r\n            // create a function using the user's function body and call it with our parameters\r\n            if (fnParts && fnParts.length === 6) {\r\n                fnBody = fnParts[4];\r\n                this.executeUserJavascript(fnBody, paramNames, paramValues);\r\n            }\r\n        }\r\n\r\n        exportData(callback, errorCallback, options): void {\r\n            let pivotModel,\r\n                splitFocus,\r\n                exportParams: ExportParams = {},\r\n                exportName = \"\";\r\n\r\n            if (options) {\r\n                if (options.exportName) {\r\n                    exportName = options.exportName;\r\n                }\r\n                if (options.exportParams) {\r\n                    exportParams = options.exportParams;\r\n                }\r\n            }\r\n\r\n            if (this.get(\"_dataType\") === \"analytic\") {\r\n                this.runWithConnectionCheck(\r\n                    errorCallback,\r\n                    function(): void {\r\n                        DeltaClientLib.exportAnalyticData(\r\n                            this.get(\"_selectedAnalytic\"),\r\n                            this.get(\"_connection\"),\r\n                            this.bindViewStateToKdbParams(this.get(\"_analyticParams\")),\r\n                            exportName,\r\n                            exportParams,\r\n                            callback,\r\n                            errorCallback,\r\n                        );\r\n                    }.bind(this),\r\n                );\r\n            } else if (this.get(\"_dataType\") === \"pivot\" || this.get(\"_pivotType\")) {\r\n                pivotModel = this;\r\n\r\n                // find the currently focused data model\r\n                if (options && options.focus && _.isString(options.focus)) {\r\n                    splitFocus = options.focus.split(\",\");\r\n\r\n                    _.each(splitFocus, function(id) {\r\n                        if (pivotModel.dataSet.collection.has(id)) {\r\n                            pivotModel = pivotModel.dataSet.collection.get(id);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                pivotModel.exportPivotData(callback, errorCallback, options);\r\n            } else if (this.get(\"_dataType\") === \"query\") {\r\n                this.runWithConnectionCheck(\r\n                    errorCallback,\r\n                    function(): void {\r\n                        DeltaClientLib.exportQueryData(\r\n                            this.get(\"_connection\"),\r\n                            this.replaceViewStateParams(this.get(\"_queryString\")),\r\n                            this.bindViewStateToKdbParams(this.get(\"_queryParams\")),\r\n                            exportName,\r\n                            exportParams,\r\n                            callback,\r\n                            errorCallback,\r\n                        );\r\n                    }.bind(this),\r\n                );\r\n            } else {\r\n                // export not supported for this datatype\r\n                errorCallback(\"Export not currently supported for type \" + this.get(\"_dataType\"));\r\n            }\r\n        }\r\n\r\n        flatten(): any {\r\n            if (\r\n                _.includes(\r\n                    [\"analytic\", \"streaming\", \"pivot\", \"query\", \"virtual\", \"builder\"],\r\n                    this.get(\"_dataType\"),\r\n                )\r\n            ) {\r\n                return [this];\r\n            } else {\r\n                return _.reduce(\r\n                    _.omit(this.attributes, \"error\"),\r\n                    function(memo, value) {\r\n                        return memo.concat(value.flatten());\r\n                    },\r\n                    [],\r\n                );\r\n            }\r\n        }\r\n\r\n        flattenObject(ob) {\r\n            const toReturn = {};\r\n            if (_.keys(ob).length) {\r\n                for (const i in ob) {\r\n                    if (!ob.hasOwnProperty(i)) continue;\r\n\r\n                    if (typeof ob[i] === \"object\") {\r\n                        const flatObject = this.flattenObject(ob[i]);\r\n                        for (const x in flatObject) {\r\n                            if (!flatObject.hasOwnProperty(x)) continue;\r\n\r\n                            toReturn[i + \".\" + x] = flatObject[x];\r\n                        }\r\n                    } else {\r\n                        toReturn[i] = ob[i];\r\n                    }\r\n                }\r\n\r\n                return toReturn;\r\n            }\r\n\r\n            return { 0: ob.toString() };\r\n        }\r\n\r\n        forceExecute(key, callback): void {\r\n            this.paramChanged.push(\"#forced\");\r\n            if (callback) this.callbacks.push(callback);\r\n            this.debouncedParameterChange();\r\n        }\r\n\r\n        formatValue(value: number, key: string): number {\r\n            if (key === \"_subscriptionInterval\") {\r\n                value = Math.min(3600, Math.max(0.5, Number(value || 0))) * 1000;\r\n            }\r\n\r\n            return value;\r\n        }\r\n\r\n        generatePivotModel(idAttribute, childId, modelType, options) {\r\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n            const topSelf: DocumentDataModel = this;\r\n\r\n            if (options.breakdownCols instanceof Backbone.Model) {\r\n                options.breakdownCols = options.breakdownCols.get(\"value\");\r\n            }\r\n\r\n            // init empty meta set for wheres transform\r\n            topSelf.meta = {};\r\n\r\n            const model = Backbone.Model.extend(\r\n                {\r\n                    defaults: {\r\n                        _dataType: topSelf.get(\"_dataType\"),\r\n                        _pivotType: topSelf.get(\"_pivotType\"),\r\n                        _subscriptionType: topSelf.get(\"_subscriptionType\"),\r\n                        _subscriptionInterval: topSelf.get(\"_subscriptionInterval\"),\r\n                    },\r\n                    idAttribute: idAttribute,\r\n                    childId: childId,\r\n                    childModelType: modelType,\r\n\r\n                    initialize() {\r\n                        this.isDirty = true;\r\n                        this.isPending = false;\r\n                        this.legacyUpdates = [];\r\n                        this.agent = new Agent();\r\n                    },\r\n\r\n                    apply() {\r\n                        this.dataSet = new DataSet({\r\n                            idAttribute: childId,\r\n                            collectionFunc: Backbone.Collection.extend({\r\n                                model: modelType,\r\n                            }),\r\n                            agent: this.agent,\r\n                            maxRows: options.maxRows,\r\n                            primaryKey: childId,\r\n                        });\r\n                    },\r\n\r\n                    getRoot() {\r\n                        return topSelf;\r\n                    },\r\n\r\n                    getViewState() {\r\n                        return topSelf.getViewState();\r\n                    },\r\n\r\n                    execute(args) {\r\n                        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n                        const self: DocumentDataModel = this,\r\n                            clientExecutePending =\r\n                                !topSelf.clientPivotData ||\r\n                                topSelf.isDirty ||\r\n                                (args && args.intervalQuery);\r\n\r\n                        if (!this.wheres) {\r\n                            this.wheres = options.wheres;\r\n                        }\r\n\r\n                        const parentExecuteFn = self.onExecuteSubscriptionSuccess.bind(self);\r\n\r\n                        const executeFn = function(data?): void {\r\n                            if (data) {\r\n                                parentExecuteFn(data);\r\n                            } else {\r\n                                parentExecuteFn(\r\n                                    topSelf.executeClientPivotQuery(topSelf.clientPivotData, {\r\n                                        wheres: options.wheres,\r\n                                    }),\r\n                                    topSelf.get(\"_forceReset\"),\r\n                                );\r\n                            }\r\n                        };\r\n\r\n                        self.onExecuteBegin();\r\n\r\n                        try {\r\n                            options.topX = null;\r\n                            options.ordering = null;\r\n                            options.queryParams = topSelf.bindViewStateToKdbParams(\r\n                                topSelf.get(\"_queryParams\"),\r\n                            );\r\n                            options.maxRows =\r\n                                topSelf.get(\"_maxRows\") || DocumentDataModel.DEFAULT_MAX_ROWS;\r\n\r\n                            // options only contain wheres from level 1 on\r\n                            _.each(options.wheres, function(where, i) {\r\n                                const whereKey =\r\n                                    typeof where === \"string\" ? where : where.columnName;\r\n                                const columnType = topSelf.meta[whereKey];\r\n                                // transform where to object with type information from top meta set\r\n                                options.wheres[i] = {\r\n                                    columnName: whereKey,\r\n                                    columnType: columnType,\r\n                                    columnOperator: \"=\",\r\n                                    columnValue: self.get(whereKey),\r\n                                };\r\n                            });\r\n\r\n                            const errorFn = function(error, ...args): void {\r\n                                topSelf.onError(model, options, error, \"Error\", args);\r\n                            };\r\n\r\n                            if (self.get(\"_pivotType\") === \"client\") {\r\n                                if (clientExecutePending) {\r\n                                    self.stop();\r\n                                    topSelf.runWithConnectionCheck(errorFn, function() {\r\n                                        switch (topSelf.get(\"_dataType\")) {\r\n                                            case \"query\":\r\n                                                const query = topSelf.replaceViewStateParams(\r\n                                                    options.queryString,\r\n                                                );\r\n                                                if (\r\n                                                    self.get(\"_subscriptionType\") === \"subscription\"\r\n                                                ) {\r\n                                                    DeltaClientLib.startManagedQuery(\r\n                                                        options.connection,\r\n                                                        query,\r\n                                                        topSelf.bindViewStateToKdbParams(\r\n                                                            options.queryParams,\r\n                                                        ),\r\n                                                        function(data: any, bData) {\r\n                                                            if (\r\n                                                                data &&\r\n                                                                data.dataSet &&\r\n                                                                data.dataSet.rows\r\n                                                            ) {\r\n                                                                topSelf.clientPivotData =\r\n                                                                    data.dataSet;\r\n                                                                executeFn();\r\n                                                            } else {\r\n                                                                executeFn(data);\r\n                                                            }\r\n                                                        },\r\n                                                        errorFn,\r\n                                                        options.subscriptionInterval * 1000,\r\n                                                        options.maxRows,\r\n                                                        null, // TODO NF paging,\r\n                                                        self.performance,\r\n                                                    );\r\n                                                } else {\r\n                                                    DeltaClientLib.getQueryData(\r\n                                                        options.dataSource,\r\n                                                        options.connection,\r\n                                                        query,\r\n                                                        topSelf.bindViewStateToKdbParams(\r\n                                                            options.queryParams,\r\n                                                        ),\r\n                                                        function(data) {\r\n                                                            topSelf.clientPivotData = data;\r\n                                                            executeFn();\r\n                                                        },\r\n                                                        errorFn,\r\n                                                        options.maxRows,\r\n                                                        null, // TODO NF paging,\r\n                                                        self.performance,\r\n                                                    );\r\n                                                }\r\n                                                break;\r\n                                            case \"analytic\":\r\n                                            case \"streaming\":\r\n                                                if (\r\n                                                    self.get(\"_subscriptionType\") === \"subscription\"\r\n                                                ) {\r\n                                                    DeltaClientLib.startManagedAnalytic(\r\n                                                        topSelf.get(\"_selectedAnalytic\"),\r\n                                                        topSelf.get(\"_connection\"),\r\n                                                        topSelf.bindViewStateToKdbParams(\r\n                                                            topSelf.get(\"_analyticParams\"),\r\n                                                        ),\r\n                                                        function(data: any, bData) {\r\n                                                            if (data && data.rows) {\r\n                                                                topSelf.clientPivotData = data;\r\n                                                                executeFn();\r\n                                                            } else {\r\n                                                                executeFn(data);\r\n                                                            }\r\n                                                        },\r\n                                                        errorFn,\r\n                                                        options.subscriptionInterval * 1000,\r\n                                                        options.maxRows,\r\n                                                        self.performance,\r\n                                                    );\r\n                                                } else {\r\n                                                    DeltaClientLib.runAnalytic(\r\n                                                        topSelf.get(\"_selectedAnalytic\"),\r\n                                                        topSelf.get(\"_connection\"),\r\n                                                        topSelf.bindViewStateToKdbParams(\r\n                                                            topSelf.get(\"_analyticParams\"),\r\n                                                        ),\r\n                                                        function(data) {\r\n                                                            topSelf.clientPivotData = data;\r\n                                                            executeFn();\r\n                                                        },\r\n                                                        errorFn,\r\n                                                        options.maxRows,\r\n                                                        null, // TODO NF paging,\r\n                                                        self.performance,\r\n                                                    );\r\n                                                }\r\n                                                break;\r\n                                            case \"virtual\":\r\n                                                topSelf.executeVirtualQuery(\r\n                                                    topSelf.get(\"_virtualQueryString\"),\r\n                                                    topSelf.get(\"_virtualParams\"),\r\n                                                    function(data) {\r\n                                                        topSelf.clientPivotData = data;\r\n                                                        executeFn();\r\n                                                    },\r\n                                                );\r\n                                                break;\r\n                                            case \"builder\":\r\n                                                if (\r\n                                                    self.get(\"_subscriptionType\") === \"subscription\"\r\n                                                ) {\r\n                                                    DeltaClientLib.startManagedQuery(\r\n                                                        options.connection,\r\n                                                        self.get(\"_analyticString\"),\r\n                                                        self.get(\"_queryBuilderParams\"),\r\n                                                        function(data: any, bData) {\r\n                                                            if (\r\n                                                                data &&\r\n                                                                data.dataSet &&\r\n                                                                data.dataSet.rows\r\n                                                            ) {\r\n                                                                topSelf.clientPivotData =\r\n                                                                    data.dataSet;\r\n                                                                executeFn();\r\n                                                            } else {\r\n                                                                executeFn(data);\r\n                                                            }\r\n                                                        },\r\n                                                        errorFn,\r\n                                                        options.subscriptionInterval * 1000,\r\n                                                        options.maxRows,\r\n                                                        null, // TODO NF paging,\r\n                                                        self.performance,\r\n                                                    );\r\n                                                } else {\r\n                                                    DeltaClientLib.getQueryData(\r\n                                                        options.dataSource,\r\n                                                        options.connection,\r\n                                                        self.get(\"_analyticString\"),\r\n                                                        self.get(\"_queryBuilderParams\"),\r\n                                                        function(data) {\r\n                                                            topSelf.clientPivotData = data;\r\n                                                            executeFn();\r\n                                                        },\r\n                                                        errorFn,\r\n                                                        options.maxRows,\r\n                                                        null, // TODO NF paging,\r\n                                                        self.performance,\r\n                                                    );\r\n                                                }\r\n                                                break;\r\n                                        }\r\n                                    });\r\n                                } else {\r\n                                    executeFn();\r\n                                }\r\n                            } else {\r\n                                if (topSelf.get(\"_dataType\") === \"builder\") {\r\n                                    options.queryString = topSelf.get(\"_analyticString\");\r\n                                    options.queryParams = topSelf.get(\"_queryBuilderParams\");\r\n                                }\r\n                                topSelf.runWithConnectionCheck(errorFn, function() {\r\n                                    DeltaClientLib.getPivotData(\r\n                                        options,\r\n                                        function(data: any, buffer: ArrayBuffer) {\r\n                                            // add to top meta set for where transform above - set from level 0 on\r\n                                            _.extend(topSelf.meta, data[\"meta\"]);\r\n\r\n                                            // on success\r\n                                            if (\r\n                                                topSelf.get(\"_subscriptionType\") === \"subscription\"\r\n                                            ) {\r\n                                                self.onExecuteSubscriptionSuccess(\r\n                                                    data,\r\n                                                    topSelf.get(\"_forceReset\"),\r\n                                                    buffer,\r\n                                                    topSelf.meta,\r\n                                                );\r\n                                            } else {\r\n                                                self.onExecuteSuccess(\r\n                                                    data,\r\n                                                    topSelf.get(\"_forceReset\"),\r\n                                                    buffer,\r\n                                                    topSelf.meta,\r\n                                                );\r\n                                            }\r\n                                        },\r\n                                        errorFn,\r\n                                        self.performance,\r\n                                    );\r\n                                });\r\n                            }\r\n                        } catch (e) {\r\n                            topSelf.onError(model, options, e, \"Error\", args);\r\n                        }\r\n                    },\r\n                    //?why options are not passed as arguments\r\n                    exportPivotData: function(callback, errorCallback, args) {\r\n                        topSelf.runWithConnectionCheck(errorCallback, function() {\r\n                            DeltaClientLib.exportPivotData(\r\n                                $.extend({}, options, args),\r\n                                callback,\r\n                                errorCallback,\r\n                            );\r\n                        });\r\n                    },\r\n\r\n                    /* eslint-disable @typescript-eslint/unbound-method */\r\n                    clearVirtualSubscriptions: _.noop,\r\n                    clearVirtualSubscriptionsAll: _.noop,\r\n                    executeClientPivotQuery: topSelf.executeClientPivotQuery,\r\n                    formatValue: topSelf.formatValue,\r\n                    getViewStateAttribute: topSelf.getViewStateAttribute,\r\n                    isPagingData: topSelf.isPagingData,\r\n                    logPrefix: topSelf.logPrefix,\r\n                    legacyFlush: topSelf.legacyFlush,\r\n                    legacyUpdate: topSelf.legacyUpdate,\r\n                    onComplete: topSelf.onComplete,\r\n                    onExecuteSubscriptionSuccess: topSelf.onExecuteSubscriptionSuccess,\r\n                    onExecuteBegin: topSelf.onExecuteBegin,\r\n                    onExecuteSuccess: topSelf.onExecuteSuccess,\r\n                    reset: topSelf.reset,\r\n                    start: topSelf.start,\r\n                    stop: topSelf.stop,\r\n                    subscribe: topSelf.subscribe,\r\n                    triggerCallbacks: _.noop,\r\n                    updateVirtualSubscriptions: _.noop,\r\n                    unsubscribe: topSelf.unsubscribe,\r\n                    /* eslint-enable @typescript-eslint/unbound-method */\r\n                },\r\n                {\r\n                    staticIdAttribute: idAttribute,\r\n                },\r\n            );\r\n\r\n            return model;\r\n        }\r\n\r\n        getByPath(path: string): DocumentDataModel {\r\n            // if path is not defined, return undefined\r\n            if (!path) {\r\n                return undefined;\r\n            }\r\n\r\n            // split path by delimeter, excluding empty entries\r\n            const splitPath = _.filter(path.split(\"/\"), function(key) {\r\n                return key && key.length > 0;\r\n            });\r\n\r\n            // default to this (normal root)\r\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n            let val = this;\r\n\r\n            // iterate over the nested models using the path of keys\r\n            _.each(splitPath, function(key) {\r\n                if (val) {\r\n                    val = val.get(key);\r\n                }\r\n            });\r\n\r\n            return val;\r\n        }\r\n\r\n        /**\r\n         * Get the execution rate since apply was last called\r\n         * @return {number} The execution rate value per minute\r\n         */\r\n        getExecutionRate(): number {\r\n            if (this.performance) {\r\n                const t = this.performance.performance[\"apply\"];\r\n                return t ? (60000 * this.dataExecuteSuccessCount) / (Date.now() - t) : 0;\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        getMappedViewStates() {\r\n            const mapping = this.get(\"_mappings\"),\r\n                viewstates = [];\r\n\r\n            if (mapping && mapping.mappings) {\r\n                _.each(\r\n                    mapping.mappings,\r\n                    function(viewstate): void {\r\n                        viewstates.push(\r\n                            viewstate && viewstate._dashboardsType\r\n                                ? this.viewState.getByPath(viewstate.value)\r\n                                : viewstate,\r\n                        );\r\n                    }.bind(this),\r\n                );\r\n            }\r\n\r\n            return viewstates;\r\n        }\r\n\r\n        getMeta(callback: (meta: any) => void): void {\r\n            const key = _.uniqueId(\"getMeta_\");\r\n\r\n            this.subscribe(key, {\r\n                onData: meta => {\r\n                    callback(meta);\r\n                    _.defer(() => this.unsubscribe(key));\r\n                },\r\n            });\r\n        }\r\n\r\n        getRoot(): DocumentDataModel {\r\n            return this;\r\n        }\r\n\r\n        getTreeList() {\r\n            const children = _.filter(this.attributes, function(child) {\r\n                return child instanceof DocumentDataModel;\r\n            });\r\n            return children.length\r\n                ? _.chain(children)\r\n                      .map(function(child) {\r\n                          return child.getTreeList();\r\n                      })\r\n                      .flatten()\r\n                      .value()\r\n                : [this];\r\n        }\r\n\r\n        getViewState() {\r\n            //console.log('d:' + this.cid, this.viewState, this);\r\n            return this.viewState;\r\n        }\r\n\r\n        getPagingType(): string {\r\n            let pagingType = DocumentDataModel.DEFAULT_PAGING;\r\n\r\n            if (this.get(\"_serverPaging\")) {\r\n                if (this.get(\"_forceReset\")) {\r\n                    pagingType = \"PAGENO_NOCACHE\";\r\n                } else if (this.get(\"_pagingType\") && this.get(\"_pagingType\") !== \"NONE\") {\r\n                    pagingType = this.get(\"_pagingType\");\r\n                } else {\r\n                    pagingType = \"PAGENO\";\r\n                }\r\n            }\r\n\r\n            return pagingType;\r\n        }\r\n\r\n        getParameters() {\r\n            const parameters = [];\r\n            let parameter, paramPath, paramValue, queryParameters;\r\n\r\n            if (this.get(\"_queryParams\")) {\r\n                queryParameters = this.get(\"_queryParams\");\r\n            } else if (this.get(\"_updateQueryParams\")) {\r\n                queryParameters = this.get(\"_updateQueryParams\");\r\n            } else if (this.get(\"_builderParams\")) {\r\n                queryParameters = this.get(\"_builderParams\");\r\n            } else if (this.get(\"_analyticParams\")) {\r\n                queryParameters = this.get(\"_analyticParams\");\r\n            } else if (this.get(\"_virtualParams\")) {\r\n                queryParameters = _.filter(this.get(\"_virtualParams\"), {\r\n                    type: \"viewstate\",\r\n                }).map((p: any) => ({ value: \"<%\" + p.value + \"%>\" }));\r\n            }\r\n\r\n            // get parameters bound to a viewstate\r\n            if (queryParameters) {\r\n                _.each(queryParameters, (queryParam): void => {\r\n                    if (typeof queryParam.value === \"string\") {\r\n                        paramPath = queryParam.value.match(DocumentDataModel.PARAMETER_RX);\r\n\r\n                        if (paramPath) {\r\n                            parameter = {\r\n                                path: paramPath[0].substring(2, paramPath[0].length - 2),\r\n                            };\r\n\r\n                            // Get static readonly ituent parameters of dict\r\n                            paramValue = this.viewState.getByPath(\r\n                                paramPath[0].substring(2, paramPath[0].length - 2),\r\n                            );\r\n                            if (paramValue && paramValue.get(\"_type\") === \"dict\") {\r\n                                parameter.dictParameters = [];\r\n                                _.each(paramValue.get(\"value\"), function(dictVal, dictKey) {\r\n                                    if (dictVal instanceof Backbone.Model) {\r\n                                        parameter.dictParameters.push({\r\n                                            path: (dictVal as any).path,\r\n                                            key: dictKey,\r\n                                        });\r\n                                    } else if (_.isObject(dictVal)) {\r\n                                        if (dictVal.name) {\r\n                                            parameter.dictParameters.push({\r\n                                                path: dictVal.name,\r\n                                                key: dictKey,\r\n                                            });\r\n                                        } else if (dictVal.type) {\r\n                                            parameter.dictParameters.push({\r\n                                                raw: true,\r\n                                                key: dictKey,\r\n                                                type: dictVal.type,\r\n                                                value: dictVal.value,\r\n                                            });\r\n                                        }\r\n                                    } else if (_.isString(dictVal)) {\r\n                                        if (dictVal.match(DocumentDataModel.PARAMETER_RX)) {\r\n                                            parameter.dictParameters.push({\r\n                                                path: dictVal.substring(2, dictVal.length - 2),\r\n                                            });\r\n                                        } else {\r\n                                            parameter.dictParameters.push({\r\n                                                path: dictVal,\r\n                                            });\r\n                                        }\r\n                                    } else if (dictVal) {\r\n                                        parameter.dictParameters.push({\r\n                                            path: dictVal.name ? dictVal.name : dictVal,\r\n                                        });\r\n                                    }\r\n                                });\r\n                            }\r\n\r\n                            parameters.push(parameter);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            return parameters;\r\n        }\r\n\r\n        getViewStateAttribute(att): any {\r\n            const value = this.get(att);\r\n            return value instanceof Backbone.Model ? value.get(\"value\") : value;\r\n        }\r\n\r\n        getViewStateDict() {\r\n            const viewStateDict = {},\r\n                dicts = [],\r\n                newParams = _.union(\r\n                    _.filter(this.get(\"_analyticParams\"), function(param) {\r\n                        if (param.type === \"dict\") {\r\n                            dicts.push(param);\r\n                        }\r\n                        return param.isViewState;\r\n                    }),\r\n                    _.filter(this.get(\"_queryParams\"), function(param) {\r\n                        if (param.type === \"dict\") {\r\n                            dicts.push(param);\r\n                        }\r\n                        return param.isViewState;\r\n                    }),\r\n                    _.filter(this.get(\"_virtualParams\"), function(param) {\r\n                        if (param.type === \"dict\") {\r\n                            dicts.push(param);\r\n                        }\r\n                        param.isVirtual = true;\r\n                        return param.type === \"viewstate\";\r\n                    }),\r\n                );\r\n\r\n            // add view states from dicts params\r\n            _.each(dicts, function(d) {\r\n                _.each(d.value, function(p) {\r\n                    if (p.isViewState) {\r\n                        newParams.push(p);\r\n                    }\r\n                });\r\n            });\r\n\r\n            //Replace viewstate parameters with values on relevent kdb query parameters\r\n            if (newParams && newParams.length > 0) {\r\n                _.each(\r\n                    newParams,\r\n                    _.bind(function(queryParam) {\r\n                        const viewState = this.parseViewState(\r\n                            queryParam.value,\r\n                            queryParam.isVirtual,\r\n                        );\r\n                        if (viewState) {\r\n                            viewStateDict[queryParam.name] = viewState;\r\n                        }\r\n\r\n                        if (queryParam.type === \"dict\" && _.isObject(queryParam.value)) {\r\n                            _.each(\r\n                                queryParam.value,\r\n                                function(value, key) {\r\n                                    const viewState = this.parseViewState(value);\r\n                                    if (viewState) {\r\n                                        viewStateDict[queryParam.name + \".\" + key] = viewState;\r\n                                    }\r\n                                }.bind(this),\r\n                            );\r\n                        }\r\n                    }, this),\r\n                );\r\n            }\r\n\r\n            // get view state attributes\r\n            _.each(\r\n                _.reduce(\r\n                    _.values(DocumentDataModel.VIEW_STATE_ATTRIBUTES),\r\n                    function(memo, ats) {\r\n                        return memo.concat(_.keys(ats));\r\n                    },\r\n                    [],\r\n                ),\r\n                _.bind(function(key) {\r\n                    const value = this.get(key);\r\n                    if (value instanceof Backbone.Model) {\r\n                        viewStateDict[key] = value;\r\n                    }\r\n                }, this),\r\n            );\r\n\r\n            return viewStateDict;\r\n        }\r\n\r\n        isMapping(): boolean {\r\n            return this.get(\"_mappings\") && !_.isEmpty(this.get(\"_mappings\").mappings);\r\n        }\r\n\r\n        isPagingData(data): boolean {\r\n            return (\r\n                data &&\r\n                data.rows &&\r\n                data.rows[0] &&\r\n                data.rows[0][\"Property\"] === \"startRows\" &&\r\n                data.rows[3]\r\n            );\r\n        }\r\n\r\n        /*\r\n         * apply the defferred update and flush updates\r\n         */\r\n        legacyFlush(): void {\r\n            this.legacyFlushTime = Date.now();\r\n            this.legacyFlushFrame = undefined;\r\n            if (\r\n                (this.deferredUpdate && this.agent.subscriberLegacyCount()) ||\r\n                this.get(\"_dataType\").match(/virtual|copy/)\r\n            ) {\r\n                const legacyTable: DCDS = this.legacyUpdate(this.deferredUpdate);\r\n\r\n                // check this.dataSet is present as legacyUpdate callbacks above can unsubscribe\r\n                this.dataSet && this.dataSet.flushUpdates();\r\n\r\n                if (\r\n                    (this.deferredUpdate.forceReset &&\r\n                        legacyTable[\"rows\"] &&\r\n                        !legacyTable[\"rows\"].length) || // rows present but empty\r\n                    !this.dataSet ||\r\n                    (this.dataSet && this.dataSet.isEmpty())\r\n                ) {\r\n                    // ignore status update in mixed mode (legacy getMeta call + raw subscription)\r\n                    if (this.agent.subscriberRawCount() === 0) {\r\n                        // missing or empty dataset\r\n                        this.set(\"queryStatus\", {\r\n                            type: \"NoResults\",\r\n                            options: {},\r\n                        });\r\n                    }\r\n                } else this.unset(\"queryStatus\");\r\n\r\n                if (this.consolidateCount > 0) {\r\n                    QuickBase.Log.Info(\r\n                        this.logPrefix() + \"consolidated \" + (this.consolidateCount + 1),\r\n                    );\r\n                } else {\r\n                    QuickBase.Log.Info(this.logPrefix() + \"deferred\");\r\n                }\r\n            }\r\n\r\n            this.consolidateCount = 0;\r\n            this.deferredUpdate = undefined;\r\n            this.durationMovingAverage =\r\n                (this.durationMovingAverage * 2 + (Date.now() - this.legacyFlushTime)) / 3;\r\n        }\r\n\r\n        legacyUpdate(u: LegacyUpdate): DCDS {\r\n            const forceReset = u.forceReset;\r\n            const table = u.table;\r\n            const pivotMeta = u.pivotMeta;\r\n\r\n            let breakdownColumns = this.get(\"_breakdownCols\");\r\n            if (breakdownColumns instanceof Backbone.Model) {\r\n                breakdownColumns = breakdownColumns.get(\"value\");\r\n            }\r\n\r\n            if (pivotMeta) _.extend(pivotMeta, table[\"meta\"]);\r\n\r\n            // generate row data from columns if not present\r\n            const legacyTable: DCDS = !table[\"rows\"] ? table.toLegacy() : table;\r\n\r\n            this.dataSet.onData(\r\n                {\r\n                    breakdownColumns: breakdownColumns,\r\n                    columns: DocumentDataModel.convertDeltaClientColumnSpecToMeta(legacyTable),\r\n                    paging: _.omit(u.pagingMeta, \"data\"),\r\n                },\r\n                legacyTable.rows,\r\n                forceReset,\r\n                undefined,\r\n                this.performance,\r\n            );\r\n\r\n            return legacyTable;\r\n        }\r\n\r\n        logPrefix(): string {\r\n            return \"DataModel \" + this.agent.subscriberCount() + \" \" + this.path + \" \";\r\n        }\r\n\r\n        objToString(obj): string {\r\n            const returnArr = [];\r\n            _.each(_.keys(obj), function(key) {\r\n                returnArr.push(key + \": \" + obj[key]);\r\n            });\r\n\r\n            return returnArr.join(\"\\n\");\r\n        }\r\n\r\n        onComplete(): void {\r\n            if (this.isDirty && !this.isPending) {\r\n                this.stop();\r\n                this.start();\r\n            }\r\n        }\r\n\r\n        onError(model, options, error, errorType, args): void {\r\n            const errorObj = {\r\n                error: _.isObject(error) ? this.objToString(this.flattenObject(error)) : error,\r\n                type: errorType,\r\n                options: $.extend({}, options), // gk: no deep clone!!\r\n                args: undefined,\r\n            };\r\n\r\n            this.triggerCallbacks(errorObj);\r\n\r\n            if (args) {\r\n                errorObj.args = $.extend({}, args); // gk: no deep clone!!\r\n            }\r\n\r\n            //gk: note no deep clone since a recurring error can gather neted levels as it reports itself\r\n\r\n            this.set({\r\n                error: errorObj,\r\n            });\r\n\r\n            this.set({\r\n                queryStatus: errorObj,\r\n            });\r\n\r\n            this.isPending = false;\r\n            this.onComplete();\r\n\r\n            try {\r\n                if (this.dataSet) {\r\n                    // use forceInternalReset but don't set it to false since no valid data yet\r\n                    this.dataSet.onData([], [], this.forceInternalReset, errorObj);\r\n                }\r\n\r\n                if (this.dataSet2) {\r\n                    // use forceInternalReset but don't set it to false since no valid data yet\r\n                    this.dataSet2.onData([], {}, this.forceInternalReset, errorObj);\r\n                }\r\n            } catch (ex) {\r\n                // do nothing\r\n            }\r\n\r\n            Log.Error(this.logPrefix() + \"onError \", errorObj);\r\n            if (model && model.trigger) {\r\n                model.trigger(\"error\", model, errorObj);\r\n            }\r\n        }\r\n\r\n        onExecuteBegin(): void {\r\n            this.isPending = true;\r\n            this.isDirty = false;\r\n\r\n            this.set({\r\n                queryStatus: {\r\n                    type: \"Loading\",\r\n                },\r\n            });\r\n\r\n            //console.trace();\r\n            Log.Info(this.logPrefix() + \"execute begin\");\r\n        }\r\n\r\n        public onExecuteSuccess(\r\n            data: DCDS,\r\n            forceReset: boolean,\r\n            buffer?: ArrayBuffer,\r\n            pivotMeta?: { [index: string]: number },\r\n        ): void {\r\n            const pagingMeta = {};\r\n            let table: ipc.Table;\r\n            let breakdownColumns = this.get(\"_breakdownCols\");\r\n            if (breakdownColumns instanceof Backbone.Model) {\r\n                breakdownColumns = breakdownColumns.get(\"value\");\r\n            }\r\n\r\n            this.dataExecuteSuccessCount++;\r\n            this.triggerCallbacks();\r\n\r\n            // if binary\r\n            if (buffer && buffer.byteLength) {\r\n                // start binary paging check\r\n                const PAGING_ROWS = [\"startRows\", \"numRows\", \"totalNumRows\", \"data\"];\r\n                if (\r\n                    data &&\r\n                    data[\"qtype\"] === 99 &&\r\n                    data[\"keys\"][\"qtype\"] === 11 &&\r\n                    data[\"keys\"][\"offsets\"][\"length\"] === 4 &&\r\n                    _.isEqual(\r\n                        PAGING_ROWS,\r\n                        _.times(4, i =>\r\n                            ipc.Parse.col(data[\"keys\"] as qSymList, new DataView(buffer)).toLegacy(\r\n                                i,\r\n                            ),\r\n                        ),\r\n                    )\r\n                ) {\r\n                    const vals = ipc.Parse.col(\r\n                        data[\"values\"] as qGenericList,\r\n                        new DataView(buffer),\r\n                    );\r\n                    for (let i = 0; i < 3; i++) {\r\n                        pagingMeta[PAGING_ROWS[i]] = vals.toLegacy(i);\r\n                    }\r\n\r\n                    pagingMeta[\"pagingType\"] = this.getPagingType();\r\n                    pagingMeta[\"pageSize\"] = this.get(\"_pageSize\");\r\n\r\n                    table = ipc.Parse.reshape((vals as ipc.List).values[3], buffer);\r\n                    forceReset = true;\r\n                } else table = ipc.Parse.reshape((data as any).dataSet || data, buffer);\r\n                // end paging check\r\n\r\n                if (pivotMeta) _.extend(pivotMeta, table[\"meta\"]);\r\n\r\n                // apply and reset forceInternalReset\r\n                forceReset = forceReset || this.forceInternalReset;\r\n\r\n                if (this.agent.subscriberRawCount()) {\r\n                    this.unset(\"error\");\r\n                    this.dataSet2.onData(\r\n                        {\r\n                            breakdownColumns: breakdownColumns,\r\n                            columns: DocumentDataModel.convertDeltaClientColumnSpecToMeta(table),\r\n                            paging: _.omit(pagingMeta, \"data\"),\r\n                        },\r\n                        table.cols,\r\n                        forceReset,\r\n                        undefined,\r\n                        this.performance,\r\n                    );\r\n\r\n                    this.forceInternalReset = false;\r\n\r\n                    if (!this.dataSet2 || (this.dataSet2 && this.dataSet2.isEmpty())) {\r\n                        // missing or empty dataset\r\n                        this.set(\"queryStatus\", {\r\n                            type: \"NoResults\",\r\n                            options: {},\r\n                        });\r\n                    } else this.unset(\"queryStatus\");\r\n                }\r\n            } else if (this.isPagingData(data)) {\r\n                // data contains 4 key/value rows, keys are: startRows, numRows, totalNumRows, data\r\n                _.each(data[\"rows\"], function(el) {\r\n                    pagingMeta[el[\"Property\"]] = el[\"Value\"];\r\n                });\r\n\r\n                pagingMeta[\"pagingType\"] = this.getPagingType();\r\n                pagingMeta[\"pageSize\"] = this.get(\"_pageSize\");\r\n\r\n                table = pagingMeta[\"data\"] || {};\r\n                forceReset = true;\r\n            } else {\r\n                table = data as ipc.Table;\r\n            }\r\n\r\n            // legacy subscriptions\r\n            if (this.agent.subscriberLegacyCount() || this.get(\"_dataType\").match(/virtual|copy/)) {\r\n                // legacy updates deferred to animationFrame\r\n                forceReset = forceReset || this.forceInternalReset;\r\n                const update = new LegacyUpdate(table, forceReset, pagingMeta, pivotMeta);\r\n                this.forceInternalReset = false;\r\n\r\n                // TODO: apply legacy update in place if queued\r\n                if (this.deferredUpdate) {\r\n                    this.dataSet.background();\r\n                    this.consolidateCount++;\r\n                    // apply the deferred update to the background dataSet\r\n                    this.legacyUpdate(this.deferredUpdate);\r\n                    this.deferredUpdate = update;\r\n                }\r\n                // if dataSet is not in background AND\r\n                // generally FAST to process OR\r\n                // not run in a long time\r\n                else if (\r\n                    !this.dataSet.isBackground() &&\r\n                    (this.durationMovingAverage <= DocumentDataModel.FAST_THRESHOLD ||\r\n                        Date.now() - this.legacyFlushTime - this.durationMovingAverage >\r\n                            DocumentDataModel.OLD_THRESHOLD)\r\n                ) {\r\n                    // Express frame\r\n                    this.deferredUpdate = update;\r\n                    this.legacyFlush();\r\n                    QuickBase.Log.Info(this.logPrefix() + \" Express\");\r\n                } else {\r\n                    this.deferredUpdate = update;\r\n                }\r\n\r\n                if (!this.legacyFlushFrame && this.deferredUpdate) {\r\n                    this.legacyFlushFrame = window.requestAnimationFrame(\r\n                        this.legacyFlush.bind(this),\r\n                    );\r\n                    this.deferredUpdate = update;\r\n                }\r\n            }\r\n\r\n            this.isPending = false;\r\n            this.unset(\"error\");\r\n            Log.Info(this.logPrefix() + \"execute success\");\r\n\r\n            // STAC\r\n            //console.log(_.map(this.performance.performance, (v,k) => k + \": \" + moment(v).format(\"hh:mm:ss.SSS\")).join(\"\\n\"))\r\n\r\n            this.onComplete();\r\n        }\r\n\r\n        onExecuteSubscriptionSuccess(\r\n            msg: any,\r\n            forceReset: boolean,\r\n            buffer: ArrayBuffer,\r\n            pivotMeta?: { [index: string]: number },\r\n        ): void {\r\n            if (msg[\"class\"] === \"207\") {\r\n                // Ack Message\r\n                this.stop();\r\n\r\n                if (msg[\"add\"]) {\r\n                    // add subcription\r\n                    this.subscriptionId = msg.clientId + \":\" + msg.subId;\r\n                    this.isPending = false;\r\n                    Log.Info(this.logPrefix() + \"sub started \" + msg.subId);\r\n                } else {\r\n                    Log.Info(this.logPrefix() + \"sub stopped \" + msg.subId);\r\n                }\r\n                return;\r\n            } else if (msg[\"class\"] === \"208\") {\r\n                // Nack Message remove subscription\r\n                Log.Info(this.logPrefix() + \"sub failed \" + msg.subId + \": \" + msg.reason);\r\n                DeltaClientLib.removeSubscriptions(msg.clientId + \":\" + msg.subId);\r\n                return;\r\n            } else if (msg[\"class\"] === \"209\") {\r\n                // Update Message doesn't match subscription id\r\n                if (this.subscriptionId !== msg.clientId + \":\" + msg.subId) {\r\n                    Log.Warn(\r\n                        this.logPrefix() +\r\n                            \"sub stray persisting: \" +\r\n                            msg.clientId +\r\n                            \":\" +\r\n                            msg.subId,\r\n                    );\r\n                    DeltaClientLib.removeSubscriptions(msg.clientId + \":\" + msg.subId);\r\n                    return;\r\n                }\r\n            } else if (msg[\"class\"] === \"210\") {\r\n                // Status Message\r\n                return; // do nothing\r\n            } else if (\r\n                msg[\"class\"] === \"com.fd.business.querymanager.subscriptions.ManagedSubscription\" ||\r\n                msg[\"class\"] === \"com.fd.business.querymanager.subscriptions.StreamingSubscription\"\r\n            ) {\r\n                return; // do nothing\r\n            }\r\n\r\n            this.onExecuteSuccess(msg.dataSet || msg, forceReset, buffer, pivotMeta);\r\n        }\r\n\r\n        onMaterialChange(): void {\r\n            this.trigger(\"materialChange\");\r\n        }\r\n\r\n        onModelChange(model, options): void {\r\n            const changedAttributes = _.keys(model.changed),\r\n                changedPagingAttributes = _.intersection(\r\n                    changedAttributes,\r\n                    DocumentDataModel.PAGING_ATTRIBUTES,\r\n                );\r\n\r\n            // if any _ prefixed properties change\r\n            if (_.find(changedAttributes, testKey => testKey.indexOf(\"_\") === 0)) {\r\n                // trigger model data change for save status\r\n                this.determineMaterialChange();\r\n\r\n                // have any _ prefixed properties except _layout havebeen trigged\r\n                if (\r\n                    _.some(\r\n                        changedAttributes,\r\n                        a => a.indexOf(\"_\") === 0 && !_.includes([\"_layout\", \"_mappings\"], a),\r\n                    )\r\n                ) {\r\n                    this.isDirty = true;\r\n                }\r\n\r\n                // if paging parameters have changed we need to execute\r\n                if (changedPagingAttributes && changedPagingAttributes.length) {\r\n                    this.paramChanged = this.paramChanged.concat(changedPagingAttributes);\r\n                    this.stop();\r\n                    this.isDirty = true;\r\n                    this.forceInternalReset = true;\r\n                    this.debouncedParameterChange();\r\n                }\r\n            }\r\n        }\r\n\r\n        onParameterChange(model, val, options): void {\r\n            // always run apply for pivots so children will not be homeless\r\n            const param = {\r\n                runApply: !!(options && options.runApply) || !!this.get(\"_pivotType\"),\r\n                modelPath: model.path,\r\n                previous: model.previous(\"value\"),\r\n                new: val,\r\n            };\r\n\r\n            this.paramChanged.push(param);\r\n            //can be viewstate/breakdown/querySetting parameter\r\n            Log.Info(this.logPrefix() + \"parameter change\", param);\r\n            this.stop();\r\n            this.isDirty = true;\r\n            this.forceInternalReset = true;\r\n\r\n            // reset to first page, check KXAX-17781\r\n            if (\r\n                this.get(\"_pagingType\") !== DocumentDataModel.DEFAULT_PAGING &&\r\n                this.get(\"_pagingNum\") !== 0\r\n            ) {\r\n                this.set(\"_pagingNum\", 0);\r\n            }\r\n\r\n            this.debouncedParameterChange();\r\n        }\r\n\r\n        onPivotSettingChange(model, val): void {\r\n            this.onParameterChange(model, val, { runApply: true });\r\n        }\r\n\r\n        onQuerySettingChange(model, val, options): void {\r\n            //append \"runApply\" flag to options\r\n            options = _.extend(true, { runApply: true }, options);\r\n            this.onParameterChange(model, val, options);\r\n        }\r\n\r\n        parseViewState(value, virtual): any {\r\n            if (typeof value === \"string\") {\r\n                if (virtual) {\r\n                    return this.getViewState().getByPath(value);\r\n                }\r\n\r\n                const paramPath = value.match(DocumentDataModel.PARAMETER_RX);\r\n                if (paramPath) {\r\n                    return this.getViewState().getByPath(\r\n                        $.trim(paramPath[0].substring(2, paramPath[0].length - 2)),\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        postCommand(sender: object, command: Command): any {\r\n            // TODO: assuming you set the data path before you got here\r\n            return this.root.postCommand(this, command);\r\n        }\r\n\r\n        //Remove subscriptions previously generated by this model if they exist\r\n        removeSubscriptions(): void {\r\n            this.stop();\r\n\r\n            if (this.group) {\r\n                this.values().forEach(v => v.removeSubscriptions());\r\n            }\r\n        }\r\n\r\n        replaceViewStateParams(str): string | any {\r\n            if (typeof str === \"string\") {\r\n                return str.replace(DocumentDataModel.PARAMETER_RX, (match, path) => {\r\n                    const viewModel = this.getViewState().getByPath(path);\r\n                    if (viewModel) {\r\n                        const val = viewModel.get(\"value\");\r\n                        if (val === undefined) {\r\n                            return null;\r\n                        }\r\n\r\n                        return val;\r\n                    }\r\n\r\n                    Log.Error(this.logPrefix() + \"replace parameter: \" + path + \" not found\");\r\n                    return \"\";\r\n                });\r\n            }\r\n\r\n            return str;\r\n        }\r\n\r\n        reset(): void {\r\n            if (this.dataMapper) {\r\n                this.dataMapper.cleanUp();\r\n                delete this.dataMapper;\r\n            }\r\n\r\n            if (this.dataSet) {\r\n                this.dataSet.cleanUp();\r\n                delete this.dataSet;\r\n            }\r\n\r\n            if (this.dataSet2) {\r\n                this.dataSet2.cleanUp();\r\n                delete this.dataSet2;\r\n            }\r\n\r\n            this.deferredUpdate = undefined;\r\n            this.isDirty = true;\r\n            this.isPending = false;\r\n            this.dataExecuteSuccessCount = 0;\r\n        }\r\n\r\n        start(): void {\r\n            if (this.agent.subscriberCount() === 0) {\r\n                Log.Info(this.logPrefix() + \"start: no subscriptions\");\r\n                return;\r\n            }\r\n\r\n            // code starts after subscriber check\r\n            const subscriptionInterval = this.formatValue(\r\n                this.getViewStateAttribute(\"_subscriptionInterval\"),\r\n                \"_subscriptionInterval\",\r\n            );\r\n\r\n            const subType = this.get(\"_subscriptionType\");\r\n            if (subType === \"polling\") {\r\n                if (!this.pollingEvent) {\r\n                    Log.Info(this.logPrefix() + \"start: polling now...\");\r\n                    this.pollingEvent = setInterval(() => {\r\n                        if (!this.isPending) {\r\n                            Log.Info(this.logPrefix() + \"poll\");\r\n                            this.execute({\r\n                                intervalQuery: true,\r\n                            });\r\n                        }\r\n                    }, subscriptionInterval);\r\n                    this.execute();\r\n                } else {\r\n                    Log.Info(this.logPrefix() + \"start: already polling!\");\r\n                }\r\n            } else if (subType === \"subscription\" || subType === \"streaming\") {\r\n                if (!this.subscriptionId) {\r\n                    this.execute();\r\n                }\r\n            } else {\r\n                if (this.isDirty && !this.isPending) {\r\n                    this.execute();\r\n                }\r\n            }\r\n        }\r\n\r\n        stop(): void {\r\n            if (this.pollingEvent) {\r\n                // destroy polling event\r\n                //console.log(\"stop polling now\", this);\r\n                clearInterval(this.pollingEvent);\r\n                this.pollingEvent = null;\r\n            }\r\n\r\n            if (this.subscriptionId) {\r\n                DeltaClientLib.removeSubscriptions(this.subscriptionId);\r\n                Log.Info(this.logPrefix() + \" unsubcribed \" + this.subscriptionId);\r\n                this.subscriptionId = null;\r\n            }\r\n        }\r\n\r\n        subscribe(key: string, listener: Subscriber, raw?: boolean, pagingInfo?: any) {\r\n            if (this.agent.subscribe(key, listener, raw)) {\r\n                Log.Info(this.logPrefix() + \"subscribed \" + key);\r\n\r\n                //update model with page info properties\r\n                if (pagingInfo) {\r\n                    this.set(pagingInfo, { silent: true });\r\n                } else {\r\n                    if (this.has(\"_lazyLoading\")) {\r\n                        this.unset(\"_lazyLoading\");\r\n                        if (this.dataSet) {\r\n                            this.dataSet.lazyLoading = false;\r\n                        }\r\n\r\n                        //reset\r\n                        this.set(\r\n                            {\r\n                                _pagingType: \"NONE\",\r\n                                _pageNum: 0,\r\n                            },\r\n                            { silent: true },\r\n                        );\r\n                    }\r\n                }\r\n\r\n                // gk: onData NEEDS to be called when 'meta' or 'rows' are present\r\n                // since these collections are sent as changesets of add, remove, changed\r\n                // thus need an initial state if any is present\r\n                if (this.dataSet) {\r\n                    if (\r\n                        !raw &&\r\n                        (!this.dataSet.collection.isEmpty() || !this.dataSet.columns.isEmpty())\r\n                    ) {\r\n                        this.dataSet.onDataRefresh(listener);\r\n                    } else if (this.dataSet2 && !this.dataSet2.columns.isEmpty()) {\r\n                        if (raw) {\r\n                            this.dataSet2.onDataRefresh(listener);\r\n                        } else {\r\n                            // no dataSet content but dataSet2 content sync up\r\n                            const dc = ipc.Table.toLegacy(\r\n                                _.mapValues(\r\n                                    _.keyBy(\r\n                                        this.dataSet2.columns.map(c => c.attributes),\r\n                                        \"id\",\r\n                                    ),\r\n                                    \"kdbType\",\r\n                                ),\r\n                                this.dataSet2.columns.map(c => c.id),\r\n                                this.dataSet2.cols,\r\n                            );\r\n\r\n                            this.dataSet.onData(\r\n                                {\r\n                                    breakdownColumns: this.dataSet2.breakdownColumns,\r\n                                    columns: DocumentDataModel.convertDeltaClientColumnSpecToMeta(\r\n                                        dc,\r\n                                    ),\r\n                                },\r\n                                dc.rows,\r\n                                true,\r\n                                undefined,\r\n                            );\r\n                        }\r\n                    } else if (raw && !this.dataSet.columns.isEmpty()) {\r\n                        // if raw and no dataSet2 but dataSet has data then we've discarded the binary, call again.\r\n                        this.apply();\r\n                    }\r\n\r\n                    // trigger queryStatus change (so new subscribers get current status)\r\n                    this.trigger(\"change:queryStatus\", this, this.get(\"queryStatus\"));\r\n                } else {\r\n                    this.apply();\r\n                }\r\n\r\n                // start will run execute if required\r\n                this.start();\r\n            } else {\r\n                // already subscribed\r\n                Log.Error(this.logPrefix() + \"subscribe: already subscribed\", key);\r\n            }\r\n        }\r\n\r\n        /*\r\n         * toJSON override is necessary to prevent all of the data\r\n         * contained within the data type models from being serialized.\r\n         * - only the definition properties prefixed with '_' are\r\n         *   saved\r\n         */\r\n        toJSON(): object {\r\n            const filteredAttrs = {};\r\n\r\n            _.keys(this.attributes).forEach((key: string) => {\r\n                const child = this.attributes[key],\r\n                    filteredChild = {};\r\n\r\n                // if child is a data type, lets only store the _properties\r\n                if (_.isObject(child) && child.has && child.has(\"_dataType\")) {\r\n                    _.each(\r\n                        _.filter(_.keys(child.attributes), function(testKey) {\r\n                            return (\r\n                                testKey.indexOf(\"_\") === 0 &&\r\n                                //fix: KXAX-11979 paging info should be ignored when saving\r\n                                !_.includes([\"_pageSort\", \"_pagingNum\"], testKey)\r\n                            );\r\n                        }),\r\n                        function(filteredKey) {\r\n                            if (child.get(filteredKey) instanceof Backbone.Model) {\r\n                                filteredChild[filteredKey] = {\r\n                                    _dashboardsType: \"viewstate\",\r\n                                    value: child.get(filteredKey).path,\r\n                                };\r\n                            } else {\r\n                                filteredChild[filteredKey] = child.get(filteredKey);\r\n                            }\r\n                        },\r\n                    );\r\n                    filteredAttrs[key] = filteredChild;\r\n                } else if (child instanceof DocumentViewModel) {\r\n                    // just extract path to viewstate model\r\n                    filteredAttrs[key] = {\r\n                        _dashboardsType: \"viewstate\",\r\n                        value: child.path,\r\n                    };\r\n                } else if (_.isObject(child) && child.type === \"Error\") {\r\n                    // error object holds reference to docDataModel - causes circular struture error\r\n                    child.options = {};\r\n                    filteredAttrs[key] = child;\r\n                } else {\r\n                    filteredAttrs[key] = child;\r\n                }\r\n            });\r\n\r\n            return filteredAttrs;\r\n        }\r\n\r\n        triggerCallbacks(error = null) {\r\n            this.callbacks.forEach(callback => {\r\n                callback({\r\n                    success: error ? false : true,\r\n                    error,\r\n                });\r\n            });\r\n            this.callbacks = [];\r\n        }\r\n\r\n        unsubscribe(key): void {\r\n            if (this.agent.unsubscribe(key)) {\r\n                Log.Info(this.logPrefix() + \"unsubscribed \" + key);\r\n                if (this.agent.subscriberCount() === 0) {\r\n                    this.stop();\r\n                    this.reset();\r\n                    this.clearVirtualSubscriptionsAll();\r\n                    Log.Info(this.logPrefix() + \"0 subscribers, data source reset\");\r\n                }\r\n            } else {\r\n                // not subscribed\r\n                Log.Warn(\"unsubscribe not found\", key, this);\r\n            }\r\n        }\r\n\r\n        updateParameterPath(type, prevPath, newPath) {\r\n            const regex = new RegExp(\"^<%\" + prevPath);\r\n\r\n            if (type === \"vs\") {\r\n                _.each(\r\n                    [\r\n                        this.get(\"_analyticParams\"),\r\n                        this.get(\"_queryParams\"),\r\n                        this.get(\"_updateQueryParams\"),\r\n                    ],\r\n                    params => {\r\n                        _.each(params, param => {\r\n                            if (param.isViewState === \"viewstate\") {\r\n                                param.value = param.value.replace(regex, \"<%\" + newPath);\r\n                            }\r\n                        });\r\n                    },\r\n                );\r\n\r\n                _.each(this.get(\"_virtualParams\"), param => {\r\n                    if (param.type === \"viewstate\") {\r\n                        param.value = param.value.replace(regex, \"<%\" + newPath);\r\n                    }\r\n                });\r\n            } else if (type === \"ds\") {\r\n                _.each(this.get(\"_virtualParams\"), param => {\r\n                    if (param.type === \"datasource\") {\r\n                        param.value = param.value.replace(regex, \"<%\" + newPath);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        updateParameters(isAnalytic?: boolean) {\r\n            let self = this,\r\n                paramPath,\r\n                dictViewStateString,\r\n                paramValue;\r\n\r\n            // clear parameters\r\n            const parameters = [];\r\n\r\n            // find all parameters\r\n            _.each(\r\n                _.filter(_.keys(self.attributes), function(testKey) {\r\n                    return testKey.indexOf(\"_\") === 0;\r\n                }),\r\n                function(filteredKey) {\r\n                    if (typeof self.get(filteredKey) === \"string\") {\r\n                        self.get(filteredKey).replace(DocumentDataModel.PARAMETER_RX, function(\r\n                            match,\r\n                            path,\r\n                        ) {\r\n                            parameters.push(path);\r\n                            return \"\";\r\n                        });\r\n                    }\r\n                },\r\n            );\r\n\r\n            // find all kdb query params with binding to viewstate\r\n            if (self.get(\"_queryParams\") && self.get(\"_queryParams\").length > 0) {\r\n                _.each(self.get(\"_queryParams\"), function(queryParam) {\r\n                    if (typeof queryParam.value === \"string\") {\r\n                        paramPath = queryParam.value.match(DocumentDataModel.PARAMETER_RX);\r\n\r\n                        if (paramPath) {\r\n                            parameters.push(paramPath[0].substring(2, paramPath[0].length - 2));\r\n                            paramValue = self.viewState.getByPath(\r\n                                paramPath[0].substring(2, paramPath[0].length - 2),\r\n                            );\r\n                        }\r\n\r\n                        //Viewstate param is of type dict, get static readonly ituent parameters\r\n                        if (paramValue && paramValue.get(\"_type\") === \"dict\") {\r\n                            _.each(paramValue.get(\"value\"), function(dictVal, dictKey) {\r\n                                if (dictVal instanceof Backbone.Model) {\r\n                                    parameters.push((dictVal as any).path);\r\n                                } else if (_.isObject(dictVal) && dictVal.value) {\r\n                                    const val = dictVal.value;\r\n\r\n                                    if (\r\n                                        _.isString(val) &&\r\n                                        val.match(DocumentDataModel.PARAMETER_RX)\r\n                                    ) {\r\n                                        parameters.push(val.substring(2, val.length - 2));\r\n                                    }\r\n                                } else if (_.isString(dictVal)) {\r\n                                    if (dictVal.match(DocumentDataModel.PARAMETER_RX)) {\r\n                                        parameters.push(dictVal.substring(2, dictVal.length - 2));\r\n                                    }\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n            } else if (\r\n                self.get(\"_updateQueryParams\") &&\r\n                self.get(\"_updateQueryParams\").length > 0\r\n            ) {\r\n                _.each(self.get(\"_updateQueryParams\"), function(queryParam) {\r\n                    if (typeof queryParam.value === \"string\") {\r\n                        paramPath = queryParam.value.match(DocumentDataModel.PARAMETER_RX);\r\n\r\n                        if (paramPath) {\r\n                            parameters.push(paramPath[0].substring(2, paramPath[0].length - 2));\r\n                            paramValue = self.viewState.getByPath(\r\n                                paramPath[0].substring(2, paramPath[0].length - 2),\r\n                            );\r\n                        }\r\n\r\n                        //Viewstate param is of type dict, get static readonly ituent parameters\r\n                        if (paramValue && paramValue.get(\"_type\") === \"dict\") {\r\n                            _.each(paramValue.get(\"value\"), function(dictVal, dictKey) {\r\n                                if (dictVal instanceof Backbone.Model) {\r\n                                    parameters.push((dictVal as any).path);\r\n                                } else if (_.isObject(dictVal) && dictVal.value) {\r\n                                    const val = dictVal.value;\r\n\r\n                                    if (\r\n                                        _.isString(val) &&\r\n                                        val.match(DocumentDataModel.PARAMETER_RX)\r\n                                    ) {\r\n                                        parameters.push(val.substring(2, val.length - 2));\r\n                                    }\r\n                                } else if (_.isString(dictVal)) {\r\n                                    if (dictVal.match(DocumentDataModel.PARAMETER_RX)) {\r\n                                        parameters.push(dictVal.substring(2, dictVal.length - 2));\r\n                                    }\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n            } else if (self.get(\"_analyticParams\") && self.get(\"_analyticParams\").length > 0) {\r\n                _.each(self.get(\"_analyticParams\"), function(analyticParam) {\r\n                    if (typeof analyticParam.value === \"string\") {\r\n                        paramPath = analyticParam.value.match(DocumentDataModel.PARAMETER_RX);\r\n\r\n                        if (paramPath) {\r\n                            parameters.push(paramPath[0].substring(2, paramPath[0].length - 2));\r\n                            paramValue = self.viewState.getByPath(\r\n                                paramPath[0].substring(2, paramPath[0].length - 2),\r\n                            );\r\n                        }\r\n\r\n                        //Viewstate param is of type dict, get static readonly ituent parameters\r\n                        if (paramValue && paramValue.get(\"_type\") === \"dict\") {\r\n                            _.each(paramValue.get(\"value\"), function(dictVal, dictKey) {\r\n                                if (dictVal instanceof Backbone.Model) {\r\n                                    parameters.push((dictVal as any).path);\r\n                                } else if (_.isObject(dictVal) && dictVal.value) {\r\n                                    const val = dictVal.value;\r\n\r\n                                    if (\r\n                                        _.isString(val) &&\r\n                                        val.match(DocumentDataModel.PARAMETER_RX)\r\n                                    ) {\r\n                                        parameters.push(val.substring(2, val.length - 2));\r\n                                    }\r\n                                } else if (_.isString(dictVal)) {\r\n                                    if (dictVal.match(DocumentDataModel.PARAMETER_RX)) {\r\n                                        parameters.push(dictVal.substring(2, dictVal.length - 2));\r\n                                    }\r\n                                }\r\n                            });\r\n                        }\r\n                    } else if (typeof analyticParam.value === \"object\") {\r\n                        //Dictionary parameters have to be bound to viewstate\r\n                        if (analyticParam.type === \"dict\") {\r\n                            _.each(analyticParam.value, function(dictValue) {\r\n                                if (_.has(dictValue, \"_isKdbReady\")) return;\r\n\r\n                                dictViewStateString =\r\n                                    typeof dictValue === \"object\"\r\n                                        ? dictValue.value\r\n                                        : \"<%\" + dictValue + \"%>\";\r\n                                paramPath =\r\n                                    typeof dictViewStateString === \"string\" &&\r\n                                    dictViewStateString.match(DocumentDataModel.PARAMETER_RX);\r\n\r\n                                if (paramPath) {\r\n                                    parameters.push(\r\n                                        paramPath[0].substring(2, paramPath[0].length - 2),\r\n                                    );\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n            } else if (self.get(\"_virtualParams\") && self.get(\"_virtualParams\").length > 0) {\r\n                _.each(self.get(\"_virtualParams\"), function(queryParam) {\r\n                    paramPath = queryParam.value;\r\n\r\n                    if (paramPath && queryParam.type === \"viewstate\") {\r\n                        parameters.push(paramPath);\r\n                        paramValue = self.viewState.getByPath(paramPath);\r\n                    }\r\n\r\n                    //Viewstate param is of type dict, get static readonly ituent parameters\r\n                    if (paramValue && paramValue.get(\"_type\") === \"dict\") {\r\n                        _.each(paramValue.get(\"value\"), function(dictVal, dictKey) {\r\n                            if (dictVal instanceof Backbone.Model) {\r\n                                parameters.push((dictVal as any).path);\r\n                            } else if (_.isObject(dictVal) && dictVal.value) {\r\n                                const val = dictVal.value;\r\n\r\n                                if (_.isString(val) && val.match(DocumentDataModel.PARAMETER_RX)) {\r\n                                    parameters.push(val.substring(2, val.length - 2));\r\n                                }\r\n                            } else if (_.isString(dictVal)) {\r\n                                if (dictVal.match(DocumentDataModel.PARAMETER_RX)) {\r\n                                    parameters.push(dictVal.substring(2, dictVal.length - 2));\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n\r\n            // stop listening to old parameter models\r\n            if (self.parameterModels) {\r\n                _.each(self.parameterModels, function(m) {\r\n                    if (m) {\r\n                        //Log.Info(self.logPrefix() + 'unbind ' + m.path);\r\n\r\n                        // eslint-disable-next-line @typescript-eslint/unbound-method\r\n                        self.stopListening(m, \"change:value\", self.onParameterChange);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // clear parameterModels\r\n            self.parameterModels = [];\r\n\r\n            // start listening to new parameter models\r\n            _.each(parameters, function(path) {\r\n                const m = self.getViewState().getByPath(path);\r\n\r\n                if (m) {\r\n                    // eslint-disable-next-line @typescript-eslint/unbound-method\r\n                    self.listenTo(m, \"change:value\", self.onParameterChange);\r\n                    self.parameterModels.push(m);\r\n                }\r\n            });\r\n        }\r\n\r\n        updateVirtualSubscriptions(): void {\r\n            const sources = [];\r\n\r\n            if (this.get(\"_dataType\") !== \"virtual\") {\r\n                this.clearVirtualSubscriptionsAll();\r\n                return;\r\n            }\r\n\r\n            // get list of sources\r\n            _.each(this.get(\"_virtualParams\"), function(queryParam) {\r\n                const sourcePath = queryParam.value;\r\n\r\n                if (sourcePath && queryParam.type === \"datasource\") {\r\n                    sources.push(sourcePath);\r\n                }\r\n            });\r\n\r\n            // determine unused sources\r\n            let unusedSubscriptions = _.keys(this.virtualSubscriptions);\r\n\r\n            _.each(sources, (path): void => {\r\n                let key = this.path + \"_\" + path,\r\n                    model;\r\n\r\n                if (this.get(\"isSourceDataDialog\")) {\r\n                    key += \"#edit\";\r\n                }\r\n\r\n                if (_.includes(unusedSubscriptions, key)) {\r\n                    unusedSubscriptions = _.without(unusedSubscriptions, key);\r\n                    return;\r\n                }\r\n\r\n                if (this.root) {\r\n                    model = this.root.getByPath(path);\r\n                }\r\n\r\n                if (model && !this.virtualSubscriptions[key]) {\r\n                    this.virtualSubscriptions[key] = model;\r\n                    model.unsubscribe(key);\r\n                    model.subscribe(key, {\r\n                        key: key,\r\n                        onData: (meta, data, error) => {\r\n                            this.onParameterChange(\r\n                                { path: \"#virtual\", previous: _.noop.bind(this) },\r\n                                Math.random(),\r\n                                {},\r\n                            );\r\n                        },\r\n                        source: model,\r\n                    });\r\n                }\r\n            });\r\n\r\n            // unsubscribe from unused sources\r\n            this.clearVirtualSubscriptions(unusedSubscriptions);\r\n        }\r\n\r\n        wrapWithErrorHandler(func, model, options) {\r\n            const self = this;\r\n            return function() {\r\n                try {\r\n                    func.apply(self, arguments);\r\n                } catch (e) {\r\n                    self.onError(\r\n                        model,\r\n                        $.extend(true, {}, options),\r\n                        e,\r\n                        \"Error\",\r\n                        Array.prototype.slice.call(3, arguments),\r\n                    );\r\n                }\r\n            };\r\n        }\r\n    }\r\n}\r\n","/// <reference types=\"backbone\" />\n/// <reference path=\"ICommandable.ts\" />\n/// <reference path=\"../classes/ComponentInterface.ts\"/>\n/// <reference path=\"../lib/helpers.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class DocumentViewModel extends CommandoModel implements ViewModelInterface {\n        MATERIAL_ATTRIBUTES: string[] = [\"_type\", \"_default\"];\n        path: string;\n        root: DocumentViewModel;\n        schema: any;\n        withAllProperties = false;\n        parent: Commandable;\n\n        // gk: why?\n        viewStates: any[];\n\n        constructor(attributes: any, options: any, parent?: Commandable) {\n            super(attributes, options, parent);\n\n            // set path\n            if (options) {\n                if (options.path) {\n                    this.path = options.path;\n                }\n\n                // set root model\n                this.root = options.root === true ? this : options.root;\n            }\n\n            // convert each child object into a DocumentView Model\n            _.each(\n                _.keys(this.attributes),\n                function(key) {\n                    let val = this.get(key),\n                        model;\n\n                    //Check if val is object but ensure it is not _default or value properties as these may be arrays\n                    if (_.isObject(val) && [\"_default\", \"value\", \".settings\"].indexOf(key) === -1) {\n                        model = new DocumentViewModel(\n                            val,\n                            {\n                                path: this.path ? this.path + \"/\" + key : key,\n                                root: this.root,\n                            },\n                            this,\n                        );\n\n                        this.set(key, model, { silent: true });\n                        this.listenTo(model, \"change\", this.onChildModelChange);\n                        this.listenTo(model, \"materialChange\", this.onMaterialChange);\n                    } else if (key === \".settings\") {\n                        if (!(val instanceof Backbone.Model)) {\n                            // not a model means that it's previous setting being passed\n                            // make all component_id props backbone models\n                            for (const key2 in val) {\n                                if (val.hasOwnProperty(key2)) {\n                                    val[key2] = new Backbone.Model(val[key2]);\n                                }\n                            }\n                            // make the whole settings a backbone model\n                            this.set(key, new Backbone.Model(val));\n                        }\n                    } else {\n                        this.set(key, val);\n\n                        // apply default to value\n                        if (key === \"_default\") {\n                            if (this.get(\"_rolling\")) {\n                                this.set(\n                                    \"value\",\n                                    Helpers.convertRollingToDate(val, this.get(\"_type\")),\n                                );\n                            } else {\n                                this.set(\"value\", val);\n                            }\n                        }\n                    }\n                }.bind(this),\n            );\n\n            // if is view state item not group\n            if (_.has(this.attributes, \"_default\") && _.has(this.attributes, \"value\")) {\n                // init type & schema\n                this.attributes[\"_type\"] = this.attributes[\"_type\"] || \"symbol\";\n                this.schema = {\n                    _type: {\n                        type: \"Select\",\n                        options: [\n                            \"boolean\",\n                            \"byte\",\n                            \"char\",\n                            \"date\",\n                            \"datetime\",\n                            \"dict\",\n                            \"double\",\n                            \"float\",\n                            \"guid\",\n                            \"int\",\n                            \"list\",\n                            \"long\",\n                            \"minute\",\n                            \"month\",\n                            \"second\",\n                            \"short\",\n                            \"string\",\n                            \"symbol\",\n                            \"time\",\n                            \"timespan\",\n                            \"timestamp\",\n                        ],\n                    },\n                };\n\n                this.updateSchema();\n            }\n\n            this.listenTo(this, \"change\", this.onChange);\n        }\n\n        postInitialize() {\n            const self = this;\n\n            // convert view states in dictionaries to models\n            // needs to happen after view state has been set (including user view state)\n            _.each(self.getViewStateList(), function(viewState) {\n                if (viewState.model.get(\"_type\") === \"dict\") {\n                    viewState.model.set(\n                        \"_default\",\n                        _.mapValues(viewState.model.get(\"_default\"), function(value, key) {\n                            let model;\n\n                            if (_.isString(value) && value.indexOf(\"<%\") === 0) {\n                                model = self.getByPath(value.substring(2, value.length - 2));\n                            } else if (_.isObject(value)) {\n                                if (value._viewType) {\n                                    value = value.value;\n                                } else if (value.isViewState) {\n                                    model = self.getByPath(value.name);\n                                }\n                            }\n\n                            return model ? model : value;\n                        }),\n                        { silent: true },\n                    ); //otherwise causes unsaved changes on dash load\n\n                    viewState.model.set(\"value\", viewState.model.get(\"_default\"));\n                }\n            });\n        }\n\n        destroyOnServer(options) {\n            options = options ? _.clone(options) : {};\n            const model = this;\n            const success = options.success;\n            const wait = options.wait;\n\n            const destroy = function() {\n                // destroyOnServer is the same as destroy except it skips stopListening\n                //model.stopListening();\n                model.trigger(\"destroy\", model, model.collection, options);\n            };\n\n            const wrapError = function(model, options) {\n                const error = options.error;\n                options.error = function(resp) {\n                    if (error) error.call(options.context, model, resp, options);\n                    model.trigger(\"error\", model, resp, options);\n                };\n            };\n\n            options.success = function(resp) {\n                if (wait) destroy();\n                if (success) success.call(options.context, model, resp, options);\n                if (!model.isNew()) model.trigger(\"sync\", model, resp, options);\n            };\n\n            let xhr: boolean | JQueryXHR = false;\n            if (this.isNew()) {\n                _.defer(options.success);\n            } else {\n                wrapError(this, options);\n                xhr = this.sync(\"delete\", this, options);\n            }\n            if (!wait) destroy();\n            return xhr;\n        }\n\n        doCommand(path: Array<string>, todos: Array<Todo>) {\n            if (path.length > 0) {\n                const vsPath = path.reverse().join(\"/\");\n                return this.getByPath(vsPath).doCommand(path, todos);\n            }\n\n            //TODO: do something its your command\n        }\n\n        getByPath(path) {\n            let splitPath, val;\n\n            // if path is not defined, return undefined\n            if (!path) {\n                return undefined;\n            }\n\n            if (_.isObject(path)) {\n                console.warn(\"getByPath is deprecated, please update component.\");\n                return path;\n            }\n\n            // split path by delimeter, excluding empty entries\n            splitPath = _.filter(path.split(\"/\"), function(key) {\n                return key && key.length > 0;\n            });\n\n            // default to this (normall root)\n            val = this;\n\n            // iterate over the nested models using the path of keys\n            _.each(splitPath, function(key) {\n                if (val && val.get) {\n                    val = val.get(key);\n                }\n            });\n\n            return val;\n        }\n\n        getViewStateExport() {\n            let processNode,\n                viewStateExport = {};\n\n            processNode = function(root, path) {\n                let settings, currentNode, nodePath;\n\n                if (!(root && root.attributes)) {\n                    return;\n                }\n\n                _.each(_.keys(root.attributes), function(key) {\n                    nodePath = path ? path + \"/\" + key : key;\n                    currentNode = root.get(key);\n\n                    if (_.isObject(currentNode) && _.isFunction(currentNode.get)) {\n                        if (currentNode.get(\"_viewType\")) {\n                            // DocumentViewModel\n                            if (!_.isEqual(currentNode.get(\"value\"), currentNode.get(\"_default\"))) {\n                                viewStateExport[nodePath] = currentNode.get(\"value\");\n                            }\n                        } else if (nodePath === \".settings\") {\n                            // settings object\n                            settings = _.mapValues(currentNode.attributes, function(value) {\n                                return value.omit(\"version\");\n                            });\n\n                            if (!_.isEmpty(settings)) {\n                                viewStateExport[nodePath] = settings;\n                            }\n                        } else {\n                            // folder\n                            processNode(currentNode, nodePath);\n                        }\n                    }\n                });\n\n                return viewStateExport;\n            };\n\n            return processNode(this);\n        }\n\n        getViewStateList(includeSettings?: boolean) {\n            this.viewStates = [];\n            this.getViewStates(this);\n            return this.viewStates;\n        }\n\n        getViewStates(root, path?: string, includeSettings?: boolean) {\n            let self = this,\n                currentNode,\n                nodePath;\n\n            if (!root.attributes) {\n                return;\n            }\n\n            _.each(_.keys(root.attributes), function(key) {\n                nodePath = path ? path + \"/\" + key : key;\n                currentNode = root.get(key);\n\n                if (includeSettings || key !== \".settings\") {\n                    if (\n                        _.isObject(currentNode) &&\n                        _.isFunction(currentNode.get) &&\n                        currentNode.get(\"_viewType\") &&\n                        key.substr(0, 1) !== \".\"\n                    ) {\n                        self.viewStates.push({\n                            model: currentNode,\n                            path: nodePath,\n                        });\n                    } else {\n                        self.getViewStates(currentNode, nodePath, includeSettings);\n                    }\n                }\n            });\n        }\n\n        onChange() {\n            // listen and stop listening to children\n            _.each(this.changedAttributes(), (val, key) => {\n                if (this.previous(key) === undefined && val instanceof DocumentViewModel) {\n                    // listen to new view state added\n                    this.stopListening(val, \"change materialChange\");\n                    this.listenTo(val, \"change\", this.onChildModelChange);\n                    this.listenTo(val, \"materialChange\", this.onMaterialChange);\n                } else if (val === undefined && this.previous(key) instanceof DocumentViewModel) {\n                    // stop listening to view state removed\n                    this.stopListening(this.previous(key), \"change\");\n                    this.stopListening(this.previous(key), \"materialChange\");\n                }\n            });\n\n            // determine material change\n            if (this.changed && _.some(this.MATERIAL_ATTRIBUTES, a => this.hasChanged(a))) {\n                this.trigger(\"materialChange\");\n            }\n        }\n\n        onChildModelChange(model, value) {\n            this.trigger(\"change\", model, value);\n        }\n\n        postCommand(sender: object, command: Command) {\n            command.path.push(this.id);\n            return this.parent.postCommand(this, command);\n        }\n\n        onMaterialChange() {\n            this.trigger(\"materialChange\");\n        }\n\n        setModelValue(value): void {\n            let forceChangeEvent = false;\n\n            if (this.get(\"_type\") === \"dict\") {\n                // before we set the value, check if any sub-properties are linked to view states\n                _.each(\n                    // pick all properties that correspond to view states\n                    _.pickBy(\n                        value,\n                        (v, k) => this.get(\"value\")[k] instanceof QuickBase.DocumentViewModel,\n                    ),\n                    // loop over these properties and recursively set their values\n                    (val, key) => {\n                        val = _.includes(_.keys(val), \"value\") ? val.value : val;\n                        const model = this.get(\"value\")[key];\n                        if (model.get(\"value\") !== val) {\n                            // informs the parent dictionary that a change event is necessary\n                            forceChangeEvent = true;\n                        }\n                        model.setModelValue(val);\n                        value[key] = model;\n                    },\n                );\n            }\n\n            this.set(\"value\", value);\n            if (forceChangeEvent && _.isEmpty(this.changed)) {\n                // we must force a change event because the model can't see changes to its own deep properties\n                // (since the object references are still the same)\n                this.trigger(\"change:value\", this, value);\n            }\n        }\n\n        /*\n         * toJSON override is necessary to prevent all of the data\n         * contained within the data type models from being serialized.\n         * - only the definition properties prefixed with '_' are\n         *   saved\n         */\n        toJSON(withAllProperties) {\n            let self = this,\n                filteredAttrs = {},\n                keys = _.keys(self.attributes);\n\n            withAllProperties =\n                withAllProperties === true || (this.root && this.root.withAllProperties);\n\n            // if value is the same as the rolling default then don't save it\n            // so it will be re-generated on load\n            if (\n                self.get(\"_rolling\") &&\n                Helpers.convertRollingToDate(self.get(\"_default\"), self.get(\"_type\")) ===\n                    self.get(\"value\")\n            ) {\n                keys = _.without(keys, \"value\");\n            }\n\n            _.each(keys, function(key) {\n                let child = self.attributes[key],\n                    filteredChild = {},\n                    key2;\n\n                if (key === \".settings\") {\n                    //// dunno why but I have to cast all backbone models to json\n                    //_.each(child.attributes, function (value, key) {\n                    //    child.set(key, value.toJSON());\n                    //});\n                    // now the whole thing to json\n                    filteredAttrs[key] = child.toJSON();\n                    for (key2 in filteredAttrs[key]) {\n                        if (filteredAttrs[key].hasOwnProperty(key2)) {\n                            filteredAttrs[key][key2] = filteredAttrs[key][key2].toJSON();\n                        }\n                    }\n                }\n                // if child is a data type, lets only store the _properties\n                else if (_.isObject(child) && child.has && child.has(\"_viewType\")) {\n                    _.each(\n                        _.filter(_.keys(child.attributes), function(testKey) {\n                            return withAllProperties ? true : testKey.indexOf(\"_\") === 0;\n                        }),\n                        function(filteredKey) {\n                            filteredChild[filteredKey] = child.get(filteredKey);\n                        },\n                    );\n\n                    if (filteredChild[\"_type\"] === \"dict\") {\n                        // convert child models to paths\n                        filteredChild[\"_default\"] = _.mapValues(child.get(\"_default\"), function(\n                            value,\n                            key,\n                        ) {\n                            return value instanceof DocumentViewModel\n                                ? \"<%\" + value.path + \"%>\"\n                                : value;\n                        });\n\n                        // quickview will save 'value' so should convert that too\n                        filteredChild[\"value\"] = _.mapValues(child.get(\"value\"), function(\n                            value,\n                            key,\n                        ) {\n                            return value instanceof DocumentViewModel\n                                ? \"<%\" + value.path + \"%>\"\n                                : value;\n                        });\n                    }\n\n                    filteredAttrs[key] = filteredChild;\n                } else {\n                    filteredAttrs[key] = child;\n                }\n            });\n\n            return filteredAttrs;\n        }\n\n        parse(data) {\n            let val;\n\n            if (data && data[\".settings\"]) {\n                val = data[\".settings\"];\n\n                if (!(val instanceof Backbone.Model)) {\n                    // not a model means that it's previous setting being passed\n                    // make all component_id props backbone models\n                    for (const key in val) {\n                        if (val.hasOwnProperty(key)) {\n                            val[key] = new Backbone.Model(val[key]);\n                        }\n                    }\n                    // make the whole settings a backbone model\n                    data[\".settings\"] = new Backbone.Model(val);\n                }\n\n                //_.each(data[\".settings\"], function (value, key) {\n                //    data[key] = new Backbone.Model(value);\n                //});\n            }\n            return data;\n        }\n\n        updateBinding(path, componentView, componentViewModel, viewProp, bindingObjs) {\n            const appViewModelItem = _.isString(path) ? this.getByPath(path) : path;\n\n            componentView.stopListening(componentViewModel, \"change:\" + viewProp);\n            if (path && appViewModelItem) {\n                bindingObjs.push(appViewModelItem);\n                componentViewModel.set(viewProp, appViewModelItem.get(\"value\"));\n\n                componentView.listenTo(appViewModelItem, \"change:value\", function(model, value) {\n                    componentViewModel.set(viewProp, value);\n                });\n\n                componentView.listenTo(componentViewModel, \"change:\" + viewProp, function(\n                    model,\n                    value,\n                ) {\n                    appViewModelItem.set(\"value\", value);\n                });\n            }\n        }\n\n        updateBindingDeep(path, componentView, componentViewModel, viewProp, bindingObjs) {\n            const appViewModelItem = this.get(path);\n\n            componentView.stopListening(componentViewModel, \"change:\" + viewProp);\n            if (path && appViewModelItem) {\n                bindingObjs.push(appViewModelItem);\n                componentViewModel.set(viewProp, appViewModelItem.get(\"value\"));\n\n                componentView.listenTo(appViewModelItem, \"change:value\", function(model, value) {\n                    componentViewModel.set(viewProp, value);\n                });\n\n                componentView.listenTo(componentViewModel, \"change:\" + viewProp, function(\n                    model,\n                    value,\n                ) {\n                    appViewModelItem.set(\"value\", value);\n                });\n            }\n        }\n\n        updateSchema() {\n            const typeDefinition = RTTI.getByName(this.get(\"_type\")),\n                editor = typeDefinition.editor;\n\n            this.schema._default = editor;\n            this.schema.value = editor;\n        }\n\n        silentCast(key, ObjType, options) {\n            if (!(this.get(key) instanceof ObjType)) {\n                this.set(key, new ObjType(this.get(key), options), { silent: true });\n            }\n        }\n    }\n}\n","/// <reference types=\"backbone\" />\r\n/// <reference path=\"ICommandable.ts\" />\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class Screen extends CommandoModel {\r\n        readonly IMMATERIAL_ATTRIBUTES = [\"isDefault\", \"thumb\", \"widgets\"];\r\n        idAttribute: \"id\";\r\n\r\n        constructor(attributes, options, parent: Commandable) {\r\n            super(attributes, options, parent);\r\n\r\n            if (!this.get(\"id\")) {\r\n                // generate id\r\n                //console.log(\"generated id! for screen\");\r\n                this.set(\r\n                    {\r\n                        id: Helpers.getGUID(),\r\n                    },\r\n                    {\r\n                        silent: true,\r\n                    },\r\n                );\r\n            }\r\n\r\n            if (this.get(\"widgets\")) {\r\n                this.silentCast(\"widgets\", WidgetCollection);\r\n\r\n                this.listenTo(this.get(\"widgets\"), \"change add remove\", function(e) {\r\n                    this.trigger(\"change\");\r\n                });\r\n            }\r\n\r\n            this.listenTo(this, \"change\", this.determineMaterialChange.bind(this));\r\n            this.listenTo(this.get(\"widgets\"), \"materialChange\", this.onMaterialChange.bind(this));\r\n        }\r\n\r\n        clone(): Screen {\r\n            const attributes = this.toJSON();\r\n\r\n            // new id will be generated\r\n            delete attributes.id;\r\n            attributes.widgets = attributes.widgets.clone();\r\n\r\n            const clone = new Screen(attributes, {}, this.parent);\r\n\r\n            // change collection's parent to new screen\r\n            attributes.widgets.setParent(clone);\r\n\r\n            return clone;\r\n        }\r\n\r\n        defaults(): object {\r\n            return {\r\n                id: null,\r\n                name: \"Screen 1\",\r\n                thumb: null,\r\n                widgets: new WidgetCollection([], {}, this),\r\n\r\n                // layout params, equal to document model\r\n                // undefined properties will be populated when screen is loaded (check DocumentView)\r\n                relativeHeight: undefined,\r\n                rowCount: undefined,\r\n                rowHeight: undefined,\r\n                colCount: 36,\r\n                floatable: true,\r\n            };\r\n        }\r\n\r\n        commandSet(json): void {\r\n            const oldJSON = _.mapValues(json, (value, key) => this.previous(key));\r\n\r\n            this.postCommand(\r\n                this,\r\n                new Command(\r\n                    \"Set Screen\",\r\n                    [],\r\n                    [new Todo(CommandOp.Set, \"\", json)],\r\n                    [new Todo(CommandOp.Set, \"\", oldJSON)],\r\n                ),\r\n            );\r\n        }\r\n\r\n        determineMaterialChange(): void {\r\n            if (this.changed && !_.isEmpty(_.omit(this.changed, this.IMMATERIAL_ATTRIBUTES))) {\r\n                this.trigger(\"materialChange\");\r\n            }\r\n        }\r\n\r\n        doCommand(path: Array<string>, todos: Array<Todo>): void {\r\n            if (path.length > 0) {\r\n                const key = path.pop();\r\n                if (key === \"widgets\") {\r\n                    return this.get(key).doCommand(path, todos);\r\n                } else {\r\n                    throw \"Unsupported command key\";\r\n                }\r\n            } else {\r\n                todos.forEach(t => {\r\n                    this.set(t.payload);\r\n                });\r\n            }\r\n        }\r\n\r\n        onMaterialChange(): void {\r\n            this.trigger(\"materialChange\");\r\n        }\r\n\r\n        parseCastAndListen(data, key, ObjType, events: string): void {\r\n            // if data and data[key] present but not of ObjType\r\n            if (data && data[key] && !(data[key] instanceof ObjType)) {\r\n                // cast\r\n                data[key] = new ObjType(data[key], {}, this);\r\n\r\n                // listen to events\r\n\r\n                this.listenTo(data[key], events, function() {\r\n                    this.trigger(\"change\", this);\r\n                });\r\n            }\r\n        }\r\n\r\n        parse(data) {\r\n            // cast and listen to models\r\n            this.parseCastAndListen(data, \"widgets\", WidgetCollection, \"change add remove\");\r\n\r\n            return data;\r\n        }\r\n\r\n        postCommand(sender: object, command: Command): void {\r\n            if (sender instanceof WidgetCollection) {\r\n                command.path.push(\"widgets\");\r\n            }\r\n\r\n            command.path.push(this.id);\r\n            return this.parent && this.parent.postCommand(this, command);\r\n        }\r\n\r\n        /*preinitialize(models: any, options: any) {\r\n            this.parent = options.parent;\r\n        }*/\r\n\r\n        silentCast(key, ObjType): void {\r\n            if (!(this.get(key) instanceof ObjType)) {\r\n                this.set(key, new ObjType(this.get(key), {}, this), { silent: true });\r\n            }\r\n        }\r\n    }\r\n\r\n    export class ScreenCollection extends ComandoCollection<Screen> {\r\n        descriptor = \"Screen\";\r\n    }\r\n\r\n    ScreenCollection.prototype.model = Screen;\r\n}\r\n","/// <reference types=\"backbone\" />\n/// <reference path=\"ICommandable.ts\" />\n/// <reference path=\"widget.ts\" />\n\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class Popup extends CommandoModel {\n        idAttribute = \"id\";\n\n        constructor(attributes, options, parent: Commandable) {\n            super(attributes, options, parent);\n\n            if (!this.get(\"id\")) {\n                this.set(\n                    {\n                        id: Helpers.getGUID(),\n                    },\n                    {\n                        silent: true,\n                    },\n                );\n            }\n\n            this.transformToWidgetCollection();\n\n            this.listenTo(this, \"change\", this.onMaterialChange.bind(this));\n            this.listenTo(\n                this.get(\"widgets\"),\n                \"add remove materialChange\",\n                this.onMaterialChange.bind(this),\n            );\n        }\n\n        convertPathsToModels(vsModel): void {\n            _.each(this.attributes, (value, key) => {\n                if (value instanceof Array) {\n                    _.each(value, (itm, i) => {\n                        _.each(itm, (v, k) => {\n                            if (v._dashboardsType === \"viewstate\") {\n                                value[i][k] = vsModel.getByPath(v.value);\n                            }\n                        });\n                    });\n                }\n                if (value._dashboardsType === \"viewstate\") {\n                    this.set(key, vsModel.getByPath(value.value), { silent: true });\n                }\n            });\n        }\n\n        defaults(): object {\n            return {\n                visible: false,\n                dialogTitle: \"\",\n                dialogHeight: 0,\n                dialogWidth: 0,\n                modal: false,\n                resizable: false,\n                widgets: new WidgetCollection([], {}, this),\n                id: Helpers.getGUID(),\n            };\n        }\n\n        doCommand(path: Array<string>, todos: Array<Todo>): void {\n            if (path.length > 0) {\n                const key = path.pop();\n                if (key === \"widgets\") {\n                    return this.get(key).doCommand(path, todos);\n                } else {\n                    throw \"Unsupported command key\";\n                }\n            } else {\n                todos.forEach(t => {\n                    let payload;\n\n                    if (_.isArray(t.payload)) {\n                        payload = _.find(t.payload, {\n                            id: this.id,\n                        });\n                    } else {\n                        payload = t.payload;\n                    }\n\n                    if (payload) {\n                        this.set(payload);\n                    }\n                });\n            }\n        }\n\n        postCommand(sender: object, command: Command): void {\n            if (sender instanceof WidgetCollection) {\n                command.path.push(\"widgets\");\n            }\n\n            command.path.push(this.id);\n            return this.parent.postCommand(this, command);\n        }\n\n        onMaterialChange(): void {\n            this.trigger(\"materialChange\");\n        }\n\n        transformToWidgetCollection(): void {\n            let widgets = this.get(\"widgets\");\n\n            if (!(widgets instanceof WidgetCollection)) {\n                widgets = new WidgetCollection(widgets ? widgets[0] : [], {}, this);\n                this.set(\"widgets\", widgets, { silent: true });\n            }\n        }\n    }\n\n    export class PopupCollection extends ComandoCollection<Popup> {\n        descriptor = \"Popup\";\n\n        commandSet(models): void {\n            let added = [];\n            let changed = [];\n            const oldJSON = this.toJSON();\n            let removed = [];\n\n            added = _.differenceBy(models, oldJSON, item => item.id);\n            changed = _.filter(models, item => {\n                const model = this.get(item.id);\n\n                if (model) {\n                    return model.changedAttributes(item);\n                }\n\n                return false;\n            });\n            removed = _.differenceBy(oldJSON, models, item => item.id);\n\n            if (added.length) {\n                this.commandAdd(added.map(obj => new Popup(obj, {}, this)));\n            }\n\n            _.each(changed, popup => {\n                this.postCommand(\n                    this,\n                    new Command(\n                        this.getCommandDescription(CommandOp.Set, popup),\n                        [popup.id],\n                        [new Todo(CommandOp.Set, \"\", popup)],\n                        [new Todo(CommandOp.Set, \"\", oldJSON)],\n                    ),\n                );\n            });\n\n            if (removed.length) {\n                this.commandRemove(removed.map(m => this.get(m.id) || new Popup(m, {}, this)));\n            }\n        }\n\n        postInitialize(vsModel): void {\n            this.each(popup => {\n                popup.convertPathsToModels(vsModel);\n            });\n\n            this.trigger(\"viewStatesParsed\");\n\n            this.listenTo(this, \"add remove reset\", function() {\n                this.trigger(\"materialChange\");\n            });\n        }\n    }\n\n    PopupCollection.prototype.model = Popup;\n}\n","/// <reference types=\"backbone\" />\r\n/// <reference path=\"ICommandable.ts\" />\r\n/// <reference path=\"widget.ts\" />\r\n/// <reference path=\"documentDataModel.ts\" />\r\n/// <reference path=\"documentViewModel.ts\" />\r\n/// <reference path=\"screen.ts\" />\r\n/// <reference path=\"popup.ts\" />\r\n/// <reference path=\"../classes/log.ts\"/>\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class Document extends Backbone.Model implements Commandable {\r\n        static upgrades = [\r\n            {\r\n                version: \"4.3.0\",\r\n                fn: function(doc) {\r\n                    _.each(doc.get(\"viewState\").getViewStateList(), function(viewState) {\r\n                        const convertDictItemToModel = function(item) {\r\n                            let path;\r\n\r\n                            if (item instanceof DocumentViewModel) {\r\n                                path = item.path;\r\n                            } else if (_.isObject(item)) {\r\n                                path = item.name;\r\n                            } else {\r\n                                path = item;\r\n                            }\r\n\r\n                            return doc.get(\"viewState\").getByPath(path);\r\n                        };\r\n\r\n                        if (viewState.model.get(\"_type\") === \"dict\") {\r\n                            // convert paths to models\r\n                            viewState.model.set(\r\n                                \"_default\",\r\n                                _.mapValues(\r\n                                    viewState.model.get(\"_default\"),\r\n                                    convertDictItemToModel,\r\n                                ),\r\n                            );\r\n                            viewState.model.set(\r\n                                \"value\",\r\n                                _.mapValues(viewState.model.get(\"value\"), convertDictItemToModel),\r\n                            );\r\n                        }\r\n                    });\r\n                },\r\n            },\r\n            {\r\n                version: \"4.4.0\",\r\n                fn: function(doc) {\r\n                    Document.reorganizePopupsAndMappers(doc, false);\r\n                },\r\n            },\r\n            {\r\n                version: \"4.4.0p7\",\r\n                fn: function(doc) {\r\n                    //KXAX-17830: fix conversion of querymappers within popup\r\n                    Document.reorganizePopupsAndMappers(doc, true);\r\n                },\r\n            },\r\n            {\r\n                version: \"4.6.0\",\r\n                fn: function(doc) {\r\n                    doc.set(\r\n                        \"saveViewerState\",\r\n                        doc.get(\"enableSaveViewState\") === false ? \"disabled\" : \"enabled\",\r\n                    );\r\n                },\r\n            },\r\n            {\r\n                version: \"4.6.0P1\",\r\n                fn: function(doc) {\r\n                    // KXAX-22061: Reset cookies with new naming conventions\r\n                    Document.renameCookie(doc);\r\n                },\r\n            },\r\n        ];\r\n\r\n        IMMATERIAL_ATTRIBUTES = [\"data\", \"viewState\", \"wasChanged\"];\r\n\r\n        sampleData = null;\r\n        SAVE_DELAY = 30000; // 30 sec\r\n        // \"disable\" autosave\r\n        //SAVE_DELAY = 1000 * 1000;\r\n        saveTimeout = null;\r\n        version = \"4.6.0P1\";\r\n        viewStateInit = false;\r\n        idAttribute: \"id\";\r\n\r\n        // document is the top of the tree\r\n        // and there is only one, hence static\r\n        public static parent: Commandable;\r\n\r\n        constructor(attributes: any, options?: any) {\r\n            super(attributes, options);\r\n            const self = this;\r\n\r\n            //console.log(\"Dashboard name init: \" + this.get('name'), this.attributes);\r\n\r\n            if (!this.get(\"id\")) {\r\n                // generate id\r\n                //console.log(\"generated id! for dash\");\r\n                this.set(\r\n                    {\r\n                        id: Helpers.getGUID(),\r\n                    },\r\n                    {\r\n                        silent: true,\r\n                    },\r\n                );\r\n            }\r\n\r\n            this.silentCast(\"viewState\", DocumentViewModel, { root: true });\r\n            this.silentCast(\"popups\", PopupCollection);\r\n            this.silentCast(\"screens\", ScreenCollection);\r\n\r\n            if (!(this.get(\"data\") instanceof DocumentDataModel)) {\r\n                this.set(\r\n                    \"data\",\r\n                    new DocumentDataModel(this.get(\"data\"), null, \"\", this.get(\"viewState\"), true),\r\n                    { silent: true },\r\n                );\r\n            }\r\n\r\n            ////Save any changes to data object of document\r\n            //this.get('data').on('change', function (e) {\r\n            //    this.saveDelayed();\r\n            //});\r\n\r\n            this.listenTo(this, \"view-state-init\", this.onViewStateInit);\r\n\r\n            this.listenTo(this, \"change\", this.determineMaterialChange);\r\n\r\n            this.listenTo(this.get(\"screens\"), \"change add remove\", function(e) {\r\n                self.trigger(\"change\", arguments);\r\n            });\r\n\r\n            if (!this.has(\"showLoadingIndicators\")) {\r\n                this.set(\"showLoadingIndicators\", true, { silent: true });\r\n            }\r\n        }\r\n\r\n        static reorganizePopupsAndMappers(doc: Document, popupMode: boolean) {\r\n            const popupSettingsMap = {\r\n                \"Basics.DialogHeight\": \"dialogHeight\",\r\n                \"Basics.DialogTitle\": \"dialogTitle\",\r\n                \"Basics.DialogWidth\": \"dialogWidth\",\r\n                \"Basics.Modal\": \"modal\",\r\n                \"Basics.Resizable\": \"resizable\",\r\n                \"Basics.Visible\": \"visible\",\r\n            };\r\n\r\n            const processPopup = function(component) {\r\n                // copy popup to document\r\n                const componentSettings = component.get(\"options\"),\r\n                    newSettings = {};\r\n\r\n                _.each(popupSettingsMap, function(newKey, oldKey) {\r\n                    const setting = componentSettings.get(oldKey);\r\n\r\n                    if (_.isObject(setting) && setting._dashboardsType === \"viewstate\") {\r\n                        newSettings[newKey] = doc.get(\"viewState\").getByPath(setting.value);\r\n                    } else {\r\n                        newSettings[newKey] = setting;\r\n                    }\r\n                });\r\n\r\n                newSettings[\"widgets\"] = component.get(\"widgets\");\r\n\r\n                doc.get(\"popups\").add(newSettings);\r\n\r\n                //KXAX-17830: fix conversion of querymappers within popup\r\n                if (popupMode) {\r\n                    processWidgets(newSettings[\"widgets\"]);\r\n                }\r\n            };\r\n\r\n            const processQueryMapper = function(component) {\r\n                // copy mappings to data source\r\n                const componentMapping = component.get(\"options\").get(\"Basics.Mapping\");\r\n                let dataModel;\r\n                const dataSourceSettings = component.get(\"options\").get(\"Basics.Data\");\r\n                let dataSourceMapping;\r\n                const mapping = {\r\n                    key: undefined,\r\n                    value: undefined,\r\n                    mappings: undefined,\r\n                };\r\n                const subscriptionKey = _.uniqueId(\"queryMapperUpgrade_\");\r\n\r\n                if (\r\n                    _.isObject(dataSourceSettings) &&\r\n                    dataSourceSettings._dashboardsType === \"data\"\r\n                ) {\r\n                    dataModel = doc.get(\"data\").getByPath(dataSourceSettings.value);\r\n                }\r\n\r\n                if (dataModel && componentMapping && componentMapping.length) {\r\n                    dataSourceMapping = dataModel.get(\"_mappings\") || {};\r\n\r\n                    // subscribe to get column info\r\n                    dataModel.subscribe(\r\n                        subscriptionKey,\r\n                        {\r\n                            onData: function(meta, data) {\r\n                                var meta = meta.columns.collection.map(\"id\");\r\n                                dataModel.unsubscribe(subscriptionKey);\r\n\r\n                                mapping.key = meta[0] || \"\";\r\n                                mapping.value = meta[1] || \"\";\r\n                                mapping.mappings = dataSourceMapping.mappings || {};\r\n\r\n                                // merge component mapping with existing data source mapping\r\n                                _.each(componentMapping, function(m) {\r\n                                    if (m.Viewstate instanceof Backbone.Model) {\r\n                                        mapping.mappings[m.Key] = {\r\n                                            _dashboardsType: \"viewstate\",\r\n                                            value: m.Viewstate.path,\r\n                                        };\r\n                                    } else {\r\n                                        // m.Viewstate can be undefined in some dashboards so will be removed from object\r\n                                        // setting to empty string ensures the key is retained\r\n                                        mapping.mappings[m.Key] = m.Viewstate || \"\";\r\n                                    }\r\n                                });\r\n\r\n                                dataModel.set(\"_mappings\", mapping);\r\n                                dataModel.apply();\r\n                            },\r\n                        },\r\n                        false,\r\n                    );\r\n                }\r\n            };\r\n\r\n            const processWidgets = function(widgetCollection) {\r\n                const widgetsToRemove = [];\r\n\r\n                const processComponent = function(component) {\r\n                    const subComponents = component.get(\"components\");\r\n                    const subWidgets = component.get(\"widgets\");\r\n\r\n                    if (component && component.get(\"key\") === \"Popup\") {\r\n                        processPopup(component);\r\n                    } else if (component && component.get(\"key\") === \"QueryMapper\") {\r\n                        processQueryMapper(component);\r\n                    } else if (subComponents && !subComponents.isEmpty()) {\r\n                        // tabs only - check child components\r\n                        subComponents.each(function(subComponent) {\r\n                            if (\r\n                                component &&\r\n                                _.includes([\"Popup\", \"QueryMapper\"], component.get(\"key\"))\r\n                            ) {\r\n                                subComponents.remove(subComponent);\r\n                            }\r\n\r\n                            processComponent(subComponent);\r\n                        });\r\n                    } else if (subWidgets && !subWidgets.isEmpty()) {\r\n                        // check child widgets\r\n                        processWidgets(subWidgets);\r\n                    }\r\n                };\r\n\r\n                const processWidget = function(widget) {\r\n                    const component = widget.get(\"component\");\r\n\r\n                    if (component) { \r\n                        \r\n                        if(_.includes([\"Popup\", \"QueryMapper\"], component.get(\"key\"))) {\r\n                            widgetsToRemove.push(widget);\r\n                        }\r\n\r\n                        processComponent(component);\r\n                    }\r\n                };\r\n\r\n                widgetCollection.each(function(widget) {\r\n                    processWidget(widget);\r\n                });\r\n\r\n                // remove query mapper widgets\r\n                widgetCollection.remove(widgetsToRemove);\r\n            };\r\n\r\n            doc.get(popupMode ? \"popups\" : \"screens\").each(function(x) {\r\n                processWidgets(x.get(\"widgets\"));\r\n            });\r\n        }\r\n\r\n        static renameCookie(doc: Document) {\r\n            const cookies = {\r\n                // eslint-disable-next-line prettier/prettier\r\n                \"viewStateDialogSize\": \"dashboard-viewStateDialog-size\",\r\n                // eslint-disable-next-line prettier/prettier\r\n                \"viewStateDialogPosition\": \"dashboard-viewStateDialog-position\",\r\n                // eslint-disable-next-line prettier/prettier\r\n                \"viewStateDialogWeights\": \"dashboard-viewStateDialog-weights\",\r\n                \"kx-datadialog-settings\": \"dashboard-datadialog-settings\",\r\n            };\r\n\r\n            _.each(cookies, function(newKey, oldKey) {\r\n                const cValue = $.cookie(oldKey);\r\n\r\n                $.removeCookie(oldKey, { path: \"/\" });\r\n                $.cookie(newKey, cValue);\r\n            });\r\n        }\r\n\r\n        commandSet(json) {\r\n            const oldJSON = _.mapValues(json, (value, key) => this.previous(key));\r\n\r\n            const c = new Command(\r\n                \"Set Options\",\r\n                [],\r\n                [new Todo(CommandOp.Set, \"\", json)],\r\n                [new Todo(CommandOp.Set, \"\", oldJSON)],\r\n            );\r\n\r\n            this.postCommand(this, c);\r\n        }\r\n\r\n        defaults(): object {\r\n            const viewState = new DocumentViewModel(\r\n                {\r\n                    selected: {\r\n                        _viewType: true,\r\n                        _default: \"0\",\r\n                        value: \"\",\r\n                    },\r\n                    \".settings\": new Backbone.Model(),\r\n                },\r\n                { root: true },\r\n                this,\r\n            );\r\n\r\n            // create screens collection and populate with screens\r\n            const screensCollection = new ScreenCollection([], {}, this);\r\n            screensCollection.add(new Screen({}, {}, screensCollection));\r\n\r\n            return {\r\n                id: null,\r\n                name: \"My New Dashboard\",\r\n                creationDate: null,\r\n                lastUpdateDate: null,\r\n                thumb: null,\r\n                screenDetails: [],\r\n                screens: screensCollection,\r\n                popups: new PopupCollection([], {}, this),\r\n                tags: [],\r\n                // convert kx-darkroom -> dark, kx-light -> light\r\n                dashboardTheme: _.capitalize(\r\n                    ($.cookie(\"dashboard-theme\") || \"dark\").replace(/(kx-|room)/g, \"\"),\r\n                ),\r\n                themeSwitchable: true,\r\n\r\n                saveTimestamp: null,\r\n\r\n                // layout params, equal to screen model\r\n                // undefined properties will be populated when screen is loaded\r\n                //  check DocumentView.js passScreenPropertiesToDocumentModel function\r\n                relativeHeight: undefined,\r\n                rowCount: undefined,\r\n                rowHeight: undefined,\r\n                colCount: 36,\r\n                floatable: true,\r\n\r\n                viewState: viewState,\r\n                data: new DocumentDataModel({}, null, \"\", viewState, true),\r\n                permissionEntity: null,\r\n\r\n                worksheetPadding: 10,\r\n                widgetsSpacing: 0,\r\n                borderColor: \"000000\",\r\n                borderBackground: \"000000\",\r\n                transparentBackground: true, //--\r\n                borderWidth: 0,\r\n                borderRounding: 0,\r\n                borderSpacing: 0,\r\n                borderShadow: false,\r\n                saveViewerState: \"Enabled\",\r\n                enableShareDashboard: false,\r\n                notifications: null,\r\n                showLoadingIndicators: true,\r\n                unsavedViewerPrompt: false,\r\n                advancedCss: \"\",\r\n                cssClasses: \"\",\r\n            };\r\n        }\r\n\r\n        doCommand(path: Array<string>, todos: Array<Todo>) {\r\n            if (path.length > 0) {\r\n                const key = path.pop();\r\n                if ([\"screens\", \"popups\", \"data\", \"viewState\"].indexOf(key) != -1) {\r\n                    return this.get(key).doCommand(path, todos);\r\n                } else {\r\n                    throw \"Unsupported command key\";\r\n                }\r\n            } else {\r\n                todos.forEach(t => {\r\n                    this.set(t.payload);\r\n                });\r\n            }\r\n        }\r\n\r\n        determineMaterialChange() {\r\n            if (this.changed && !_.isEmpty(_.omit(this.changed, this.IMMATERIAL_ATTRIBUTES))) {\r\n                this.trigger(\"materialChange\");\r\n            }\r\n        }\r\n\r\n        onViewStateInit() {\r\n            this.get(\"viewState\").postInitialize();\r\n\r\n            const cssClasses = this.get(\"cssClasses\");\r\n            if (cssClasses && cssClasses._dashboardsType === \"viewstate\") {\r\n                this.set(\"cssClasses\", this.get(\"viewState\").getByPath(cssClasses.value), {\r\n                    silent: true,\r\n                });\r\n            }\r\n\r\n            this.get(\"popups\").postInitialize(this.get(\"viewState\"));\r\n\r\n            this.viewStateInit = true;\r\n        }\r\n\r\n        saveDelayed(errorHandler) {\r\n            const screenDetails = [];\r\n\r\n            // clear delayed save\r\n            if (this.saveTimeout) {\r\n                clearTimeout(this.saveTimeout);\r\n            }\r\n\r\n            this.saveTimeout = setTimeout(() => this.saveNow(errorHandler), this.SAVE_DELAY);\r\n        }\r\n\r\n        saveNow(errorHandler, successHandler?) {\r\n            const self = this,\r\n                screenDetails = [];\r\n\r\n            if (_.isEmpty(this.get(\"screens\").models)) {\r\n                errorHandler(\"Document is empty, skipping save.\");\r\n                Log.Warn(\"Document is empty, skipping save.\");\r\n                return;\r\n            }\r\n\r\n            // clear delayed save\r\n            if (this.saveTimeout) {\r\n                clearTimeout(this.saveTimeout);\r\n            }\r\n\r\n            Log.Info(\"SAVE\", this.id);\r\n\r\n            // set updated date\r\n            this.set(\r\n                {\r\n                    lastUpdateDate: new Date().toUTCString(),\r\n                },\r\n                { silent: true },\r\n            );\r\n\r\n            _.each(this.get(\"screens\").models, function(m) {\r\n                screenDetails.push({ label: m.get(\"name\"), value: m.id });\r\n            });\r\n            this.set({ screenDetails: screenDetails });\r\n\r\n            this.set(\r\n                {\r\n                    thumb:\r\n                        this.get(\"screens\").models.length > 0\r\n                            ? this.get(\"screens\").models[0].get(\"thumb\")\r\n                            : null,\r\n                },\r\n                { silent: true },\r\n            );\r\n\r\n            // update document view state\r\n            const attributes = $.extend(true, {}, this.attributes);\r\n\r\n            // Convert any docDataModels to their path for notifications\r\n            this.setDataProperties(attributes.notifications);\r\n            this.setDataProperties(attributes.shortcuts);\r\n\r\n            attributes.popups.each(popup => {\r\n                // attempting to recursively set widgets causes stack overflow\r\n                popup.set(self.setDataProperties(_.omit(popup.attributes, \"widgets\")), {\r\n                    silent: true,\r\n                });\r\n            });\r\n\r\n            attributes.cssClasses = this.setViewStateProperty(attributes.cssClasses);\r\n\r\n            this.save(attributes, {\r\n                error: errorHandler,\r\n                success: function(model) {\r\n                    Log.Info(\"success\", arguments);\r\n                    self.trigger(\"documentSaved\");\r\n                    // mark as not changed\r\n                    self.set(\"wasChanged\", false);\r\n                    if (successHandler) {\r\n                        successHandler(model);\r\n                    }\r\n                },\r\n            });\r\n        }\r\n\r\n        silentCast(key, ObjType, options?) {\r\n            if (!(this.get(key) instanceof ObjType)) {\r\n                this.set(key, new ObjType(this.get(key), options, this), { silent: true });\r\n            }\r\n        }\r\n\r\n        setDataProperties(root) {\r\n            if (root) {\r\n                for (const key in root) {\r\n                    if (root[key] && root[key].path) {\r\n                        if (root[key] instanceof DocumentDataModel) {\r\n                            root[key] = {\r\n                                _dashboardsType: \"data\",\r\n                                value: root[key].path,\r\n                            };\r\n                        } else if (root[key] instanceof DocumentViewModel) {\r\n                            root[key] = {\r\n                                _dashboardsType: \"viewstate\",\r\n                                value: root[key].path,\r\n                            };\r\n                        }\r\n                    } else if (typeof root[key] === \"object\") {\r\n                        root[key] = this.setDataProperties(root[key]);\r\n                    }\r\n                }\r\n                return root;\r\n            }\r\n        }\r\n\r\n        setViewStateProperty(viewstate) {\r\n            if (viewstate instanceof DocumentViewModel) {\r\n                viewstate = {\r\n                    _dashboardsType: \"viewstate\",\r\n                    value: viewstate.path,\r\n                };\r\n            }\r\n\r\n            return viewstate;\r\n        }\r\n\r\n        toJSON() {\r\n            // Clone Attributes\r\n            const attributes = $.extend(true, {}, this.attributes);\r\n\r\n            // Convert any docDataModels to their path\r\n            this.setDataProperties(attributes.notifications);\r\n            this.setDataProperties(attributes.shortcuts);\r\n\r\n            attributes.popups.each(popup => {\r\n                // attempting to recursively set widgets causes stack overflow\r\n                popup.set(this.setDataProperties(_.omit(popup.attributes, \"widgets\")));\r\n            });\r\n\r\n            attributes.cssClasses = this.setViewStateProperty(attributes.cssClasses);\r\n            return attributes;\r\n        }\r\n\r\n        toJSONClone() {\r\n            // Clone Attributes\r\n            const attributes = _.cloneDeep(this.attributes);\r\n\r\n            // Convert any docDataModels to their path\r\n            this.setDataProperties(attributes.notifications);\r\n            this.setDataProperties(attributes.shortcuts);\r\n\r\n            attributes.popups.each(popup => {\r\n                // attempting to recursively set widgets causes stack overflow\r\n                // popup.set(this.setDataProperties(_.omit(popup.attributes, 'widgets')));\r\n                popup.attributes = _.extend(\r\n                    this.setDataProperties(_.omit(popup.attributes, \"widgets\")),\r\n                    { widgets: popup.get(\"widgets\") },\r\n                );\r\n            });\r\n\r\n            attributes.cssClasses = this.setViewStateProperty(attributes.cssClasses);\r\n            return attributes;\r\n        }\r\n\r\n        parseCastAndListen(data, key, ObjType, events: string, createFn?: Function) {\r\n            const self = this;\r\n\r\n            // if data and data[key] present but not of ObjType\r\n            if (data && data[key] && !(data[key] instanceof ObjType)) {\r\n                // cast\r\n                data[key] = createFn ? createFn(data[key]) : new ObjType(data[key], {}, this);\r\n            }\r\n        }\r\n\r\n        postCommand(sender: object, command: Command) {\r\n            if (sender instanceof ScreenCollection) {\r\n                command.path.push(\"screens\");\r\n            } else if (sender instanceof PopupCollection) {\r\n                command.path.push(\"popups\");\r\n            } else if (sender instanceof DocumentDataModel) {\r\n                command.path.push(\"data\");\r\n            } else if (sender instanceof DocumentViewModel) {\r\n                command.path.push(\"viewState\");\r\n            }\r\n\r\n            // TODO gk maybe this should be here and document collection should be singleton\r\n            // command.path.push(this.id);\r\n\r\n            this.trigger(\"postCommand\");\r\n            this.set(\"wasChanged\", true);\r\n\r\n            return Document.parent && Document.parent.postCommand(this, command);\r\n        }\r\n\r\n        parse(data) {\r\n            const cssClasses = this.get(\"cssClasses\");\r\n            if (cssClasses && cssClasses._dashboardsType === \"viewstate\") {\r\n                this.set(\"cssClasses\", this.get(\"viewState\").getByPath(cssClasses.value));\r\n            }\r\n\r\n            // cast and listen to models\r\n            this.parseCastAndListen(data, \"viewState\", DocumentViewModel, \"change\", function(d) {\r\n                return new DocumentViewModel(\r\n                    d,\r\n                    {\r\n                        root: true,\r\n                    },\r\n                    this,\r\n                );\r\n            });\r\n            this.parseCastAndListen(data, \"data\", DocumentDataModel, \"change\", function(d) {\r\n                return new DocumentDataModel(d, null, \"\", data[\"viewState\"], true);\r\n            });\r\n            this.parseCastAndListen(data, \"screens\", ScreenCollection, \"change add remove\");\r\n\r\n            this.parseCastAndListen(data, \"popups\", PopupCollection, \"change add remove\");\r\n\r\n            if (this.viewStateInit) this.get(\"popups\").postInitialize(this.get(\"viewState\"));\r\n\r\n            // convert shortcut data sources to models\r\n            _.each(data.shortcuts, shortcut => {\r\n                const source = shortcut.Data;\r\n\r\n                if (source && source._dashboardsType === \"data\") {\r\n                    shortcut.Data = data.data.getByPath(source.value);\r\n                }\r\n            });\r\n\r\n            return data;\r\n        }\r\n\r\n        upgrade() {\r\n            let i, upgrade;\r\n\r\n            if (_.keys(this.attributes).length > 0) {\r\n                // find next available upgrade\r\n                i =\r\n                    QuickBase.Document.upgrades.indexOf(\r\n                        _.find(QuickBase.Document.upgrades, {\r\n                            version: this.get(\"version\"),\r\n                        }),\r\n                    ) + 1;\r\n\r\n                for (i; i < QuickBase.Document.upgrades.length; i += 1) {\r\n                    upgrade = QuickBase.Document.upgrades[i];\r\n                    upgrade.fn(this);\r\n                    this.set(\"version\", upgrade.version);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    export class DocumentCollection extends Backbone.Collection<QuickBase.Document> {\r\n        static singleton: DocumentCollection;\r\n\r\n        constructor(models, options) {\r\n            super(models, options);\r\n            if (DocumentCollection.singleton) {\r\n                throw \"Singleton Error! DocumentCollection() invoked 2x.\";\r\n            }\r\n            DocumentCollection.singleton = this;\r\n        }\r\n\r\n        getSortedDocuments() {\r\n            // sort by defaultdash, starred, name\r\n            return this.sortBy(function(m) {\r\n                const isDefault = _.includes(m.get(\"tags\"), \"defaultdash\") ? 1 : 0,\r\n                    isStarred = _.includes(m.get(\"tags\"), \"starred\") ? 1 : 0;\r\n                return 3 - (isDefault * 2 + isStarred) + m.get(\"name\");\r\n            });\r\n        }\r\n\r\n        static requiredAccessLevel = null;\r\n    }\r\n\r\n    DocumentCollection.prototype.model = Document;\r\n}\r\n","/*global Backbone*/ // eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class AppViewModel extends Backbone.Model implements Commandable {\n        constructor(attributes, options) {\n            super(attributes, options);\n            Document.parent = this;\n\n            this.listenTo(this, \"change:selectedDocumentId\", this.resetCommands.bind(this));\n        }\n\n        defaults(): object {\n            return {\n                commands: [],\n                commandIndex: -1,\n                buildMode: true,\n                isInspecting: false,\n                selectedDocumentId: null,\n                selectedScreenId: null,\n                selectedWidgetId: null,\n                selectedSubComponent: null,\n                userConfigurable: false,\n                componentsPanel: new Backbone.Model({\n                    search: null,\n                }),\n            };\n        }\n\n        goToCommandIndex(index: number): void {\n            const commandIndex = this.get(\"commandIndex\");\n            const commands = this.get(\"commands\");\n            const doc = DocumentCollection.singleton.get(this.get(\"selectedDocumentId\"));\n\n            // TODO NF - hack for long click undo\n            if (index === commandIndex) {\n                index = index - 1;\n            }\n\n            if (index > commandIndex) {\n                // for cycle forward\n                for (let i = commandIndex + 1; i <= index; i++) {\n                    if (i >= 0 && i < commands.length) {\n                        doc.doCommand(_.clone(commands[i].path), commands[i].todo);\n                    }\n                }\n            } else if (index < commandIndex) {\n                // for cycle back\n                for (let i = commandIndex; i > index; i--) {\n                    if (i >= 0 && i < commands.length) {\n                        // path get altered by doCommand hence clone\n                        doc.doCommand(_.clone(commands[i].path), commands[i].undo);\n                    }\n                }\n            }\n\n            this.set(\"commandIndex\", index);\n        }\n\n        doCommand(path: Array<string>, todos: Array<Todo>): void {\n            // not really doing anything here\n        }\n\n        postCommand(sender: object, command: Command): void {\n            const commands = this.get(\"commands\");\n            const index = this.get(\"commandIndex\");\n\n            // remove any elements in the redo queue\n            if (index < commands.length - 1) {\n                commands.splice(index + 1, commands.length - index - 1);\n            }\n\n            commands.push(command);\n            Log.Info(\"AppViewModel::onCommand\", this.get(\"commands\"));\n            this.goToCommandIndex(index + 1);\n        }\n\n        redo(): void {\n            this.goToCommandIndex(this.get(\"commandIndex\") + 1);\n        }\n\n        resetCommands(): void {\n            this.set(\"commands\", [], { silent: true });\n            this.set(\"commandIndex\", -1, { silent: true });\n            this.trigger(\"change:commandIndex\");\n        }\n\n        undo(): void {\n            this.goToCommandIndex(this.get(\"commandIndex\") - 1);\n        }\n    }\n}\n","/// <reference types=\"handlebars\" />\n//@ts-ignore 2300\nnamespace QuickBase { \nexport class T {\n\nstatic 'AboutDialog': (obj?: any) => string = Handlebars.template({\"1\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var stack1, alias1=container.lambda, alias2=container.escapeExpression;\n\n  return \"            <tr>\\r\\n                <td>Delta Control Host:</td>\\r\\n                <td>\"\n    + alias2(alias1(((stack1 = (depth0 != null ? depth0.dashboardControlDetails : depth0)) != null ? stack1.dchost : stack1), depth0))\n    + \"</td>\\r\\n            </tr>\\r\\n            <tr>\\r\\n                <td>Delta Control Port:</td>\\r\\n                <td>\"\n    + alias2(alias1(((stack1 = (depth0 != null ? depth0.dashboardControlDetails : depth0)) != null ? stack1.dcport : stack1), depth0))\n    + \"</td>\\r\\n            </tr>\\r\\n            <tr>\\r\\n                <td>Delta Control TLS:</td>\\r\\n                <td>\"\n    + alias2(alias1(((stack1 = (depth0 != null ? depth0.dashboardControlDetails : depth0)) != null ? stack1.dctls : stack1), depth0))\n    + \"</td>\\r\\n            </tr>\\r\\n            <tr>\\r\\n                <td>KDB Banner:</td>\\r\\n                <td>\"\n    + alias2(alias1(((stack1 = (depth0 != null ? depth0.dashboardControlDetails : depth0)) != null ? stack1.bannerText : stack1), depth0))\n    + \"</td>\\r\\n            </tr>\\r\\n            <tr>\\r\\n                <td>KDB Version:</td>\\r\\n                <td>\"\n    + alias2(alias1(((stack1 = (depth0 != null ? depth0.dashboardControlDetails : depth0)) != null ? stack1.kdbVersion : stack1), depth0))\n    + \"</td>\\r\\n            </tr>\\r\\n            <tr>\\r\\n                <td>KDB Release Date:</td>\\r\\n                <td>\"\n    + alias2(alias1(((stack1 = (depth0 != null ? depth0.dashboardControlDetails : depth0)) != null ? stack1.releaseDate : stack1), depth0))\n    + \"</td>\\r\\n            </tr>\\r\\n            <tr>\\r\\n                <td>KDB Update Date:</td>\\r\\n                <td>\"\n    + alias2(alias1(((stack1 = (depth0 != null ? depth0.dashboardControlDetails : depth0)) != null ? stack1.updateDate : stack1), depth0))\n    + \"</td>\\r\\n            </tr>\\r\\n\";\n},\"3\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=\"function\", alias4=container.escapeExpression;\n\n  return \"            <tr>\\r\\n                <td>\"\n    + alias4(((helper = (helper = helpers.key || (depth0 != null ? depth0.key : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{\"name\":\"key\",\"hash\":{},\"data\":data}) : helper)))\n    + \":</td>\\r\\n                <td>\"\n    + alias4(((helper = (helper = helpers.value || (depth0 != null ? depth0.value : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{\"name\":\"value\",\"hash\":{},\"data\":data}) : helper)))\n    + \"</td>\\r\\n            </tr>\\r\\n\";\n},\"compiler\":[7,\">= 4.0.0\"],\"main\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var stack1, helper, options, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=\"function\", alias4=container.escapeExpression, buffer = \n  \"<div class=\\\"splash\\\">\\r\\n    <div class=\\\"version\\\">\"\n    + alias4(((helper = (helper = helpers.PackageName || (depth0 != null ? depth0.PackageName : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{\"name\":\"PackageName\",\"hash\":{},\"data\":data}) : helper)))\n    + \"</div>\\r\\n    <div class=\\\"scroll\\\">\\r\\n        <p>Copyright in Kx Dashboards belongs to First Derivatives plc.  First Derivatives plc 2009-2018. All rights reserved. Use of the software is subject to the terms of First Derivatives plcs license agreement. Kx and kdb+ are trademarks of Kx Systems Inc.<br/>Kx System Inc. is a subsidiary of First Derivatives plc. Portions of the Kx Dashboards software use code and/or materials under license from third-party suppliers.</p>\\r\\n        <table style=\\\"width: 100%;\\\">\\r\\n            <tr>\\r\\n                <td>\"\n    + alias4((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"User Name\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \":</td>\\r\\n                <td>\"\n    + alias4(((helper = (helper = helpers.userName || (depth0 != null ? depth0.userName : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{\"name\":\"userName\",\"hash\":{},\"data\":data}) : helper)))\n    + \"</td>\\r\\n            </tr>\\r\\n            <!--\\r\\n            <tr>\\r\\n                <td>\"\n    + alias4((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Delta Client Host\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \":</td>\\r\\n                <td>\"\n    + alias4(((helper = (helper = helpers.DeltaClientHost || (depth0 != null ? depth0.DeltaClientHost : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{\"name\":\"DeltaClientHost\",\"hash\":{},\"data\":data}) : helper)))\n    + \"</td>\\r\\n            </tr>\\r\\n            <tr>\\r\\n                <td>\"\n    + alias4((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Delta Client Port\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \":</td>\\r\\n                <td>\"\n    + alias4(((helper = (helper = helpers.DeltaClientPort || (depth0 != null ? depth0.DeltaClientPort : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{\"name\":\"DeltaClientPort\",\"hash\":{},\"data\":data}) : helper)))\n    + \"</td>\\r\\n            </tr>\\r\\n            <tr>\\r\\n                <td>&nbsp;</td>\\r\\n            </tr>\\r\\n            <tr>\\r\\n                <td>\"\n    + alias4((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Delta Control\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \":</td>\\r\\n            </tr>-->\\r\\n\"\n    + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.isLite : depth0),{\"name\":\"unless\",\"hash\":{},\"fn\":container.program(1, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"            <tr>\\r\\n                <td>&nbsp;</td>\\r\\n            </tr>\\r\\n            <tr>\\r\\n                <td>\"\n    + alias4((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"UI Components\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \":</td>\\r\\n            </tr>\\r\\n\";\n  stack1 = ((helper = (helper = helpers.paths || (depth0 != null ? depth0.paths : depth0)) != null ? helper : alias2),(options={\"name\":\"paths\",\"hash\":{},\"fn\":container.program(3, data, 0),\"inverse\":container.noop,\"data\":data}),(typeof helper === alias3 ? helper.call(alias1,options) : helper));\n  if (!helpers.paths) { stack1 = helpers.blockHelperMissing.call(depth0,stack1,options)}\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + \"        </table>\\r\\n    </div>\\r\\n</div>\";\n},\"useData\":true});\nstatic 'AreYouSureDialog': (obj?: any) => string = Handlebars.template({\"1\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var helper;\n\n  return \"<p>\\r\\n    \"\n    + container.escapeExpression(((helper = (helper = helpers.message || (depth0 != null ? depth0.message : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === \"function\" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{\"name\":\"message\",\"hash\":{},\"data\":data}) : helper)))\n    + \"\\r\\n</p>\\r\\n\";\n},\"3\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});\n\n  return \"<p>\\r\\n    Components \"\n    + ((stack1 = helpers[\"if\"].call(alias1,(depth0 != null ? depth0.dashChanged : depth0),{\"name\":\"if\",\"hash\":{},\"fn\":container.program(4, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"have unsaved changes:\\r\\n    <ul>\\r\\n\"\n    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.components : depth0),{\"name\":\"each\",\"hash\":{},\"fn\":container.program(6, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"    </ul>\\r\\n</p>\\r\\n\";\n},\"4\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    return \"also \";\n},\"6\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var stack1, alias1=container.lambda, alias2=container.escapeExpression;\n\n  return \"        <li><span title=\\\"\"\n    + alias2(alias1((depth0 != null ? depth0.widget : depth0), depth0))\n    + \"\\\">\"\n    + alias2(alias1((depth0 != null ? depth0.component : depth0), depth0))\n    + \"</span>\"\n    + ((stack1 = helpers[\"if\"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.message : depth0),{\"name\":\"if\",\"hash\":{},\"fn\":container.program(7, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"</li>\\r\\n\";\n},\"7\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    return \": \"\n    + container.escapeExpression(container.lambda((depth0 != null ? depth0.message : depth0), depth0));\n},\"compiler\":[7,\">= 4.0.0\"],\"main\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});\n\n  return ((stack1 = helpers[\"if\"].call(alias1,(depth0 != null ? depth0.dashChanged : depth0),{\"name\":\"if\",\"hash\":{},\"fn\":container.program(1, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + ((stack1 = helpers[\"if\"].call(alias1,(depth0 != null ? depth0.components : depth0),{\"name\":\"if\",\"hash\":{},\"fn\":container.program(3, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"<p>Would you like to save?</p>\\r\\n<div class=\\\"error-info\\\" style=\\\"color: red;\\\">\\r\\n    There was an error saving this dashboard.\\r\\n\\r\\n    <ul class=\\\"error-list\\\"></ul>\\r\\n</div>\";\n},\"useData\":true});\nstatic 'ComponentView': (obj?: any) => string = Handlebars.template({\"compiler\":[7,\">= 4.0.0\"],\"main\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression;\n\n  return \"<div class=\\\"border-div\\\">\\r\\n    <div class=\\\"title-div\\\"></div>\\r\\n    <div class=\\\"app-div dashboard-dark\\\"></div>\\r\\n</div>\\r\\n\\r\\n<div class=\\\"errorMessage ui-state-header\\\">\\r\\n    <div class=\\\"errorPanel ui-state-error\\\">\\r\\n        <div class=\\\"errorTitle\\\"><i class=\\\"fa fa-exclamation-triangle\\\"></i><span>\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Error\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</span></div>\\r\\n        <span class=\\\"errorText\\\"></span>\\r\\n    </div>\\r\\n    <div class=\\\"errorPanel ui-state-warning\\\">\\r\\n        <div class=\\\"errorTitle\\\"><i class=\\\"fa fa-exclamation-circle\\\"></i><span>\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Warning\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</span></div>\\r\\n        <span class=\\\"errorText\\\"></span>\\r\\n    </div>\\r\\n    <div class=\\\"errorPanel ui-state-highlight\\\">\\r\\n        <div class=\\\"errorTitle\\\"><i class=\\\"fa fa-info-circle\\\"></i><span>\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Info\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</span></div>\\r\\n        <span class=\\\"errorText\\\"></span>\\r\\n    </div>\\r\\n</div>\\r\\n\\r\\n<div class=\\\"queryStatus ui-state-header\\\">\\r\\n    <div class=\\\"statusPanel Error ui-state-error\\\">\\r\\n        <div class=\\\"statusTitle\\\"><i class=\\\"fa fa-exclamation-triangle\\\"></i><span>\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Error\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</span></div>\\r\\n        <span class=\\\"statusText\\\"></span>\\r\\n    </div>\\r\\n    <div class=\\\"statusPanel Warning ui-state-warning\\\">\\r\\n        <div class=\\\"statusTitle\\\"><i class=\\\"fa fa-exclamation-circle\\\"></i><span>\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Warning\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</span></div>\\r\\n        <span class=\\\"statusText\\\"></span>\\r\\n    </div>\\r\\n    <div class=\\\"statusPanel Info ui-state-highlight\\\">\\r\\n        <div class=\\\"statusTitle\\\"><i class=\\\"fa fa-info-circle\\\"></i><span>\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Info\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</span></div>\\r\\n        <span class=\\\"statusText\\\"></span>\\r\\n    </div>\\r\\n    <div class=\\\"statusPanel Loading ui-state-highlight\\\">\\r\\n        <div class=\\\"statusTitle\\\"><i class=\\\"fa fa-spinner fa-pulse\\\"></i><span>\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Loading\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</span></div>\\r\\n        <span class=\\\"statusText\\\"></span>\\r\\n    </div>\\r\\n<div class=\\\"statusPanel NoResults ui-state-highlight\\\">\\r\\n        <div class=\\\"statusTitle\\\"><i class=\\\"fa fa-info-circle\\\"></i><span>\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"No Results\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</span></div>\\r\\n        <span class=\\\"statusText\\\"></span>\\r\\n    </div>\\r\\n</div>\\r\\n\\r\\n<div class=\\\"progress-bar-div\\\" style=\\\"width: 100%; height: 100%; overflow: hidden; position: absolute; left: 0; top: 0; z-index: 999;\\\">\\r\\n    <div class=\\\"loading\\\" style=\\\"display: table; width: 100%; height: 100%; max-height: 100%; opacity: 0.9; overflow: hidden;\\\">\\r\\n        <div style=\\\"display: table-cell; width: 100%; height: 100%; max-height: 100%; vertical-align: middle; text-align: center;\\\">\\r\\n            <svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 32 32\\\" width=\\\"32\\\" height=\\\"32\\\" fill=\\\"#ffffff\\\">\\r\\n                <circle cx=\\\"16\\\" cy=\\\"3\\\" r=\\\"0\\\">\\r\\n                    <animate attributeName=\\\"r\\\" values=\\\"0;3;0;0\\\" dur=\\\"1s\\\" repeatCount=\\\"indefinite\\\" begin=\\\"0\\\" keySplines=\\\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\\\" calcMode=\\\"spline\\\" />\\r\\n                </circle>\\r\\n                <circle transform=\\\"rotate(45 16 16)\\\" cx=\\\"16\\\" cy=\\\"3\\\" r=\\\"0\\\">\\r\\n                    <animate attributeName=\\\"r\\\" values=\\\"0;3;0;0\\\" dur=\\\"1s\\\" repeatCount=\\\"indefinite\\\" begin=\\\"0.125s\\\" keySplines=\\\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\\\" calcMode=\\\"spline\\\" />\\r\\n                </circle>\\r\\n                <circle transform=\\\"rotate(90 16 16)\\\" cx=\\\"16\\\" cy=\\\"3\\\" r=\\\"0\\\">\\r\\n                    <animate attributeName=\\\"r\\\" values=\\\"0;3;0;0\\\" dur=\\\"1s\\\" repeatCount=\\\"indefinite\\\" begin=\\\"0.25s\\\" keySplines=\\\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\\\" calcMode=\\\"spline\\\" />\\r\\n                </circle>\\r\\n                <circle transform=\\\"rotate(135 16 16)\\\" cx=\\\"16\\\" cy=\\\"3\\\" r=\\\"0.567031\\\">\\r\\n                    <animate attributeName=\\\"r\\\" values=\\\"0;3;0;0\\\" dur=\\\"1s\\\" repeatCount=\\\"indefinite\\\" begin=\\\"0.375s\\\" keySplines=\\\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\\\" calcMode=\\\"spline\\\" />\\r\\n                </circle>\\r\\n                <circle transform=\\\"rotate(180 16 16)\\\" cx=\\\"16\\\" cy=\\\"3\\\" r=\\\"1.82452\\\">\\r\\n                    <animate attributeName=\\\"r\\\" values=\\\"0;3;0;0\\\" dur=\\\"1s\\\" repeatCount=\\\"indefinite\\\" begin=\\\"0.5s\\\" keySplines=\\\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\\\" calcMode=\\\"spline\\\" />\\r\\n                </circle>\\r\\n                <circle transform=\\\"rotate(225 16 16)\\\" cx=\\\"16\\\" cy=\\\"3\\\" r=\\\"2.88475\\\">\\r\\n                    <animate attributeName=\\\"r\\\" values=\\\"0;3;0;0\\\" dur=\\\"1s\\\" repeatCount=\\\"indefinite\\\" begin=\\\"0.625s\\\" keySplines=\\\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\\\" calcMode=\\\"spline\\\" />\\r\\n                </circle>\\r\\n                <circle transform=\\\"rotate(270 16 16)\\\" cx=\\\"16\\\" cy=\\\"3\\\" r=\\\"2.1029\\\">\\r\\n                    <animate attributeName=\\\"r\\\" values=\\\"0;3;0;0\\\" dur=\\\"1s\\\" repeatCount=\\\"indefinite\\\" begin=\\\"0.75s\\\" keySplines=\\\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\\\" calcMode=\\\"spline\\\" />\\r\\n                </circle>\\r\\n                <circle transform=\\\"rotate(315 16 16)\\\" cx=\\\"16\\\" cy=\\\"3\\\" r=\\\"0.60761\\\">\\r\\n                    <animate attributeName=\\\"r\\\" values=\\\"0;3;0;0\\\" dur=\\\"1s\\\" repeatCount=\\\"indefinite\\\" begin=\\\"0.875s\\\" keySplines=\\\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\\\" calcMode=\\\"spline\\\" />\\r\\n                </circle>\\r\\n                <circle transform=\\\"rotate(180 16 16)\\\" cx=\\\"16\\\" cy=\\\"3\\\" r=\\\"1.82452\\\">\\r\\n                    <animate attributeName=\\\"r\\\" values=\\\"0;3;0;0\\\" dur=\\\"1s\\\" repeatCount=\\\"indefinite\\\" begin=\\\"0.5s\\\" keySplines=\\\"0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8;0.2 0.2 0.4 0.8\\\" calcMode=\\\"spline\\\" />\\r\\n                </circle>\\r\\n            </svg>\\r\\n            <div class=\\\"loadingText\\\" style=\\\"font-weight: bold; margin-top: 7px; font-size: 11px; letter-spacing: 1px;\\\">\\r\\n                \"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"loading\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \" \"\n    + alias3(((helper = (helper = helpers.componentName || (depth0 != null ? depth0.componentName : depth0)) != null ? helper : alias2),(typeof helper === \"function\" ? helper.call(alias1,{\"name\":\"componentName\",\"hash\":{},\"data\":data}) : helper)))\n    + \"...\\r\\n            </div>\\r\\n        </div>\\r\\n    </div>\\r\\n</div>\";\n},\"useData\":true});\nstatic 'DocumentSelector': (obj?: any) => string = Handlebars.template({\"1\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var helper, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=\"function\", alias4=container.escapeExpression;\n\n  return \"    <option value=\\\"\"\n    + alias4(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{\"name\":\"id\",\"hash\":{},\"data\":data}) : helper)))\n    + \"\\\">\"\n    + alias4(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : alias2),(typeof helper === alias3 ? helper.call(alias1,{\"name\":\"name\",\"hash\":{},\"data\":data}) : helper)))\n    + \"</option>\\r\\n\";\n},\"compiler\":[7,\">= 4.0.0\"],\"main\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var stack1;\n\n  return \"<select>\\r\\n\"\n    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : (container.nullContext || {}),depth0,{\"name\":\"each\",\"hash\":{},\"fn\":container.program(1, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"</select>\\r\\n\";\n},\"useData\":true});\nstatic 'DocumentView': (obj?: any) => string = Handlebars.template({\"compiler\":[7,\">= 4.0.0\"],\"main\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    return \"<div class=\\\"screen-view-div\\\">\\r\\n</div>\\r\\n\\r\\n\";\n},\"useData\":true});\nstatic 'InBrowserNotification': (obj?: any) => string = Handlebars.template({\"1\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var helper;\n\n  return \"    <i class=\\\"icon fa fa-\"\n    + container.escapeExpression(((helper = (helper = helpers.icon || (depth0 != null ? depth0.icon : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === \"function\" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{\"name\":\"icon\",\"hash\":{},\"data\":data}) : helper)))\n    + \"\\\"></i>\\r\\n\";\n},\"3\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var helper;\n\n  return \"    <div class=\\\"ttl\\\">\"\n    + container.escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === \"function\" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{\"name\":\"title\",\"hash\":{},\"data\":data}) : helper)))\n    + \"</div>\\r\\n\";\n},\"5\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var stack1, helper;\n\n  return \"    <div class=\\\"msg\\\">\"\n    + ((stack1 = ((helper = (helper = helpers.message || (depth0 != null ? depth0.message : depth0)) != null ? helper : helpers.helperMissing),(typeof helper === \"function\" ? helper.call(depth0 != null ? depth0 : (container.nullContext || {}),{\"name\":\"message\",\"hash\":{},\"data\":data}) : helper))) != null ? stack1 : \"\")\n    + \"</div>\\r\\n\";\n},\"compiler\":[7,\">= 4.0.0\"],\"main\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {});\n\n  return \"<div class=\\\"inBrowserNotification\\\">\\r\\n\"\n    + ((stack1 = helpers[\"if\"].call(alias1,(depth0 != null ? depth0.icon : depth0),{\"name\":\"if\",\"hash\":{},\"fn\":container.program(1, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"\\r\\n\"\n    + ((stack1 = helpers[\"if\"].call(alias1,(depth0 != null ? depth0.title : depth0),{\"name\":\"if\",\"hash\":{},\"fn\":container.program(3, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"\\r\\n\"\n    + ((stack1 = helpers[\"if\"].call(alias1,(depth0 != null ? depth0.message : depth0),{\"name\":\"if\",\"hash\":{},\"fn\":container.program(5, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"\\r\\n    <i class=\\\"fa fa-times-circle\\\"></i>\\r\\n</div>\";\n},\"useData\":true});\nstatic 'LoginDialog': (obj?: any) => string = Handlebars.template({\"compiler\":[7,\">= 4.0.0\"],\"main\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression;\n\n  return \"<div class=\\\"login-container quick-base login-dialog ui-widget ui-widget-content ui-corner-all ui-front\\\">\\r\\n    <div class=\\\"logo\\\"></div>\\r\\n    <div class=\\\"login-form user-login-form open\\\">\\r\\n\\r\\n        <div class=\\\"input-container\\\" style=\\\"margin-top: 7px\\\">\\r\\n\\r\\n            <span>\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"User\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \":\\r\\n            </span>\\r\\n            <span>\\r\\n                <input class=\\\"username\\\" tabindex=\\\"1\\\" type=\\\"text\\\" name=\\\"username\\\" />\\r\\n            </span>\\r\\n\\r\\n        </div>\\r\\n        <div class=\\\"input-container\\\" style=\\\"margin-top: 11px;\\\">\\r\\n            <span >\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Password\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \":\\r\\n            </span>\\r\\n            <span>\\r\\n                <input class=\\\"password\\\" tabindex=\\\"2\\\" type=\\\"password\\\" name=\\\"password\\\" />\\r\\n            </span>\\r\\n        </div>\\r\\n        <div class=\\\"forgot-info\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"forgot password\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"?</div>\\r\\n        <div class=\\\"loginErrorPanel\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,(depth0 != null ? depth0.An : depth0),(depth0 != null ? depth0.error : depth0),(depth0 != null ? depth0.has : depth0),(depth0 != null ? depth0.occurred : depth0),depth0,{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</div>\\r\\n    </div>\\r\\n    <div class=\\\"login-form forgot-password-form\\\">\\r\\n        <div class=\\\"form-text\\\">Reset Password</div>\\r\\n        <div class=\\\"input-container\\\">\\r\\n            <span>\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"User\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \":\\r\\n            </span>\\r\\n            <span>\\r\\n                <input class=\\\"reset-username\\\" type=\\\"text\\\"/>\\r\\n            </span>\\r\\n        </div>\\r\\n        <div class=\\\"reset-password-error\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Please enter valid user name\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</div>\\r\\n    </div>\\r\\n    <div class=\\\"login-form password-reset-info\\\">\\r\\n        <div class=\\\"recovery-response form-text\\\"></div>\\r\\n    </div>\\r\\n    <div class=\\\"login-button-panel ui-dialog-buttonpane ui-helper-clearfix\\\">\\r\\n        <button class=\\\"login-btn ui-button ui-widget\\\" tabindex=\\\"3\\\" ></button>\\r\\n        <button class=\\\"reset-btn ui-button ui-widget\\\"></button>\\r\\n        <button class=\\\"back-btn ui-button ui-widget\\\"></button>\\r\\n    </div>\\r\\n</div>\";\n},\"useData\":true});\nstatic 'ProfileMenu': (obj?: any) => string = Handlebars.template({\"1\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var alias1=container.escapeExpression;\n\n  return \"            <option value=\\\"\"\n    + alias1(container.lambda((depth0 != null ? depth0.id : depth0), depth0))\n    + \"\\\">\"\n    + alias1((helpers.t || (depth0 && depth0.t) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.name : depth0),{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</option>\\r\\n\";\n},\"3\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var alias1=container.lambda, alias2=container.escapeExpression;\n\n  return \"                <option value=\\\"\"\n    + alias2(alias1((depth0 != null ? depth0.value : depth0), depth0))\n    + \"\\\">\"\n    + alias2(alias1((depth0 != null ? depth0.label : depth0), depth0))\n    + \"</option>\\r\\n\";\n},\"5\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var stack1, helper, alias1=depth0 != null ? depth0 : (container.nullContext || {});\n\n  return \"            <optgroup label=\\\"\"\n    + container.escapeExpression(((helper = (helper = helpers.key || (data && data.key)) != null ? helper : helpers.helperMissing),(typeof helper === \"function\" ? helper.call(alias1,{\"name\":\"key\",\"hash\":{},\"data\":data}) : helper)))\n    + \"\\\">\\r\\n\"\n    + ((stack1 = helpers.each.call(alias1,depth0,{\"name\":\"each\",\"hash\":{},\"fn\":container.program(3, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"            </optgroup>\\r\\n\";\n},\"7\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var alias1=container.lambda, alias2=container.escapeExpression;\n\n  return \"            <option value=\\\"\"\n    + alias2(alias1((depth0 != null ? depth0.value : depth0), depth0))\n    + \"\\\">\"\n    + alias2(alias1((depth0 != null ? depth0.label : depth0), depth0))\n    + \"</option>\\r\\n\";\n},\"9\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var stack1;\n\n  return \"    <li data-options=\\\"document-breadcrumbs\\\" class=\\\"breadcrumbs \"\n    + ((stack1 = helpers[\"if\"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.showBreadcrumbs : depth0),{\"name\":\"if\",\"hash\":{},\"fn\":container.program(10, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"\\\">\\r\\n        <label>Show Selection Breadcrumb</label>\\r\\n        <i class=\\\"fa fa-check ui-checkboxradio-icon\\\" />\\r\\n    </li>\\r\\n\";\n},\"10\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    return \"checked\";\n},\"12\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    return \"    <li class=\\\"ext-link\\\" data-options=\\\"open-viewer\\\">\"\n    + container.escapeExpression((helpers.t || (depth0 && depth0.t) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),\"Open Viewer\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"<i class=\\\"fa fa-external-link\\\"\\r\\n            aria-hidden=\\\"true\\\"></i></li>\\r\\n\";\n},\"14\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var stack1;\n\n  return ((stack1 = helpers[\"if\"].call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.isLite : depth0),{\"name\":\"if\",\"hash\":{},\"fn\":container.program(15, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\");\n},\"15\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    return \"    <li class=\\\"ext-link\\\" data-options=\\\"open-editor\\\">\"\n    + container.escapeExpression((helpers.t || (depth0 && depth0.t) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),\"Open Editor\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"<i class=\\\"fa fa-external-link\\\"\\r\\n            aria-hidden=\\\"true\\\"></i></li>\\r\\n\";\n},\"17\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    return \"    <li data-options=\\\"login-history\\\">\"\n    + container.escapeExpression((helpers.t || (depth0 && depth0.t) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),\"Login History\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</li>\\r\\n\";\n},\"19\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    return \"    <li data-options=\\\"helpguide\\\">\"\n    + container.escapeExpression((helpers.t || (depth0 && depth0.t) || helpers.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}),\"Help\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</li>\\r\\n\";\n},\"21\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression;\n\n  return \"    <li data-options=\\\"logout-local\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Local Logout\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</li>\\r\\n    <li data-options=\\\"logout-global\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Global Logout\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</li>\\r\\n\";\n},\"23\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var stack1;\n\n  return ((stack1 = helpers.unless.call(depth0 != null ? depth0 : (container.nullContext || {}),(depth0 != null ? depth0.isLite : depth0),{\"name\":\"unless\",\"hash\":{},\"fn\":container.program(24, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\");\n},\"24\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression;\n\n  return \"    <li data-options=\\\"change-password\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Change Password\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</li>\\r\\n    <li data-options=\\\"logout\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Logout\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</li>\\r\\n\";\n},\"compiler\":[7,\">= 4.0.0\"],\"main\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var stack1, alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression;\n\n  return \"<div class=\\\"row theme\\\">\\r\\n    <div class=\\\"label\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Editor Theme\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</div>\\r\\n    <div class=\\\"control\\\">\\r\\n        <select style=\\\"width: 100%\\\" class=\\\"select-theme\\\">\\r\\n\"\n    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.themes : depth0),{\"name\":\"each\",\"hash\":{},\"fn\":container.program(1, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"        </select>\\r\\n    </div>\\r\\n</div>\\r\\n<div class=\\\"row viewer-theme\\\">\\r\\n    <div class=\\\"label\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Theme\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</div>\\r\\n    <div class=\\\"control\\\">\\r\\n        <select style=\\\"width: 100%\\\" class=\\\"select-viewer-theme\\\">\\r\\n\"\n    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.themes : depth0),{\"name\":\"each\",\"hash\":{},\"fn\":container.program(1, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"        </select>\\r\\n    </div>\\r\\n</div>\\r\\n<!-- <div class=\\\"row language\\\">\\r\\n    <div class=\\\"label\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Language\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</div>\\r\\n    <div class=\\\"control\\\">\\r\\n        <select style=\\\"width: 100%\\\" class=\\\"select-language\\\">\\r\\n            <option value=\\\"en\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"English\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</option>\\r\\n            <option value=\\\"zh-HK\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Chinese HK\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</option>\\r\\n            <option value=\\\"de\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"German\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</option>\\r\\n            <option value=\\\"ja\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Japanese\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</option>\\r\\n            <option value=\\\"ar\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Arabic\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</option>\\r\\n        </select>\\r\\n    </div>\\r\\n</div> -->\\r\\n<div class=\\\"row timezone\\\">\\r\\n    <div class=\\\"label\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Timezone\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</div>\\r\\n    <div class=\\\"control\\\">\\r\\n        <select style=\\\"width: 100%\\\" class=\\\"select-timezone\\\">\\r\\n            <optgroup label=\\\"Major\\\">\\r\\n\"\n    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.majorTimezones : depth0),{\"name\":\"each\",\"hash\":{},\"fn\":container.program(3, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"            </optgroup>\\r\\n\"\n    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.timezones : depth0),{\"name\":\"each\",\"hash\":{},\"fn\":container.program(5, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"        </select>\\r\\n    </div>\\r\\n</div>\\r\\n<div class=\\\"row log-level\\\">\\r\\n    <div class=\\\"label\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Log Level\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</div>\\r\\n    <div class=\\\"control\\\">\\r\\n        <select style=\\\"width: 100%\\\" class=\\\"select-log-level\\\">\\r\\n\"\n    + ((stack1 = helpers.each.call(alias1,(depth0 != null ? depth0.logLevel : depth0),{\"name\":\"each\",\"hash\":{},\"fn\":container.program(7, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"        </select>\\r\\n    </div>\\r\\n</div>\\r\\n<ul class=\\\"buttonset\\\">\\r\\n\"\n    + ((stack1 = helpers[\"if\"].call(alias1,(depth0 != null ? depth0.editor : depth0),{\"name\":\"if\",\"hash\":{},\"fn\":container.program(9, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + ((stack1 = helpers[\"if\"].call(alias1,(depth0 != null ? depth0.editor : depth0),{\"name\":\"if\",\"hash\":{},\"fn\":container.program(12, data, 0),\"inverse\":container.program(14, data, 0),\"data\":data})) != null ? stack1 : \"\")\n    + ((stack1 = helpers.unless.call(alias1,(depth0 != null ? depth0.isLite : depth0),{\"name\":\"unless\",\"hash\":{},\"fn\":container.program(17, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + \"    <li data-options=\\\"about\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"About\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</li>\\r\\n\"\n    + ((stack1 = helpers[\"if\"].call(alias1,(depth0 != null ? depth0.editor : depth0),{\"name\":\"if\",\"hash\":{},\"fn\":container.program(19, data, 0),\"inverse\":container.noop,\"data\":data})) != null ? stack1 : \"\")\n    + ((stack1 = helpers[\"if\"].call(alias1,(depth0 != null ? depth0.saml : depth0),{\"name\":\"if\",\"hash\":{},\"fn\":container.program(21, data, 0),\"inverse\":container.program(23, data, 0),\"data\":data})) != null ? stack1 : \"\")\n    + \"</ul>\";\n},\"useData\":true});\nstatic 'fileExporter': (obj?: any) => string = Handlebars.template({\"compiler\":[7,\">= 4.0.0\"],\"main\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    var alias1=depth0 != null ? depth0 : (container.nullContext || {}), alias2=helpers.helperMissing, alias3=container.escapeExpression;\n\n  return \"<div class=\\\"pnlButtons\\\">\\r\\n    <span class=\\\"lnksExport link-disabled\\\">\\r\\n        <i class=\\\"fa fa-fw fa-download\\\" title=\\\"\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Data\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"\\\"></i>\\r\\n        <a class=\\\"lnkExcelExport\\\" title=\\\"\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Download the current dataset in Excel format\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Excel\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</a>\\r\\n        <a class=\\\"lnkCsvExport\\\" title=\\\"\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Download the current dataset in CSV format\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"CSV\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</a>\\r\\n        <a class=\\\"lnkFullExport\\\" title=\\\"\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Download the full dataset from the server\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Full\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</a>\\r\\n        <a class=\\\"lnkDownloadScreenshot\\\" title=\\\"\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"Download a PNG image of the chart\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"\\\">\"\n    + alias3((helpers.t || (depth0 && depth0.t) || alias2).call(alias1,\"PNG\",{\"name\":\"t\",\"hash\":{},\"data\":data}))\n    + \"</a>\\r\\n    </span> \\r\\n</div> \\r\\n\";\n},\"useData\":true});\nstatic 'popup': (obj?: any) => string = Handlebars.template({\"compiler\":[7,\">= 4.0.0\"],\"main\":function(container:any,depth0:any,helpers:any,partials:any,data:any) {\n    return \"<div class=\\\"dialog\\\">\\n    <div class=\\\"content-panel\\\" tabindex=\\\"1\\\"></div>\\n</div>\";\n},\"useData\":true});\n}\n}","/*global DashboardListView*/\r\n/// <reference path=\"../templates/combined.ts\" />\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class AboutDialog extends Backbone.View<Backbone.Model> {\r\n        $dialog: JQuery = null;\r\n        $nameInput: JQuery = null;\r\n        container: JQuery = null;\r\n\r\n        appModel = null;\r\n        viewModel: DocumentViewModel = null;\r\n\r\n        constructor(options) {\r\n            super(options);\r\n\r\n            this.appModel = options.appModel;\r\n            this.container = options.container;\r\n            this.viewModel = options.viewModel;\r\n\r\n            this.el.className = \"quick-base window dashboard-name-prompt\";\r\n            this.$el.html(\r\n                T.AboutDialog(\r\n                    _.extend(\r\n                        {\r\n                            DeltaClientHost: location.hostname,\r\n                            DeltaClientPort: location.port\r\n                                ? location.port\r\n                                : location.protocol == \"https:\"\r\n                                ? 443\r\n                                : 80,\r\n                        },\r\n                        this.appModel.toJSON(),\r\n                    ),\r\n                ),\r\n            );\r\n\r\n            this.$nameInput = this.$el.find(\".name-input\");\r\n\r\n            this.$dialog = this.$el[\"dialog\"](\r\n                _.extend(\r\n                    {\r\n                        appendTo: this.container,\r\n                        dialogClass: \"quick-base about-dialog\",\r\n                        title: t(\"About\"),\r\n                        resizable: true,\r\n                        height: 329,\r\n                        width: 470,\r\n                        modal: true,\r\n                        autoOpen: true,\r\n                        draggable: true,\r\n                        open: () => {\r\n                            // add a dialog icon\r\n                            $('<i class=\"fa fa-info-circle\" />').insertBefore(\r\n                                this.$el.parent().find(\".ui-dialog-title\"),\r\n                            );\r\n                        },\r\n                        close: () => {\r\n                            this.remove();\r\n                        },\r\n                    },\r\n                    options,\r\n                ),\r\n            );\r\n        }\r\n\r\n        remove() {\r\n            // remove event handlers\r\n            this.stopListening();\r\n            this.$el.off();\r\n\r\n            // remove from dom\r\n            return Backbone.View.prototype.remove.call(this);\r\n        }\r\n    }\r\n}\r\n","/*global _, $, Backbone, console, Conv, T, Tools */\r\n/// <reference path=\"../templates/combined.ts\" />\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class AccordionView extends Backbone.View<Backbone.Model> {\r\n        HEADING_HEIGHT = 28;\r\n        onUpdate: (sections: Array<any>) => void;\r\n        debouncedRemoveAnimate: () => void;\r\n        sections: Array<any>;\r\n\r\n        constructor(options) {\r\n            super();\r\n\r\n            this.onUpdate = options.onUpdate;\r\n\r\n            // deep clone options.sections\r\n            this.sections = options.sections || [];\r\n\r\n            this.$el = options.el;\r\n            this.$el.addClass(\"dash-accordion accordion\");\r\n\r\n            this.sections.forEach((section, i) => {\r\n                if (section.$el) {\r\n                    section.$heading = section.$el.find(section.$heading);\r\n                    section.$content = section.$el.find(section.$content);\r\n\r\n                    section.$el.addClass(\"section\");\r\n\r\n                    section.$heading.click(() => {\r\n                        this.onClick(section);\r\n                    });\r\n                }\r\n            });\r\n\r\n            this.debouncedRemoveAnimate = _.debounce(() => {\r\n                this.$el.removeClass(\"animate\");\r\n                if (this.onUpdate) {\r\n                    this.onUpdate(this.sections);\r\n                }\r\n            }, 300);\r\n\r\n            this.updateLayout(false);\r\n        }\r\n\r\n        adjustWeights(sections: Array<any>, heights: Array<number>) {\r\n            const totalWeight = this.sum(\r\n                    _.map(sections, function(s) {\r\n                        return s.weight;\r\n                    }),\r\n                ),\r\n                totalHeight = this.sum(heights);\r\n\r\n            _.each(sections, function(s, i) {\r\n                s.weight = totalWeight * (heights[i] / totalHeight);\r\n            });\r\n        }\r\n\r\n        onClick(section: any) {\r\n            section.isExpanded = !section.isExpanded;\r\n            this.updateLayout(true);\r\n        }\r\n\r\n        onSectionResize(caller, event, ui) {\r\n            let self = this,\r\n                i,\r\n                progress = 0,\r\n                section,\r\n                callerHeight = caller.$el.height(),\r\n                delta = callerHeight - ui[\"originalSize\"][\"height\"],\r\n                height,\r\n                sections = [caller],\r\n                heights = [callerHeight];\r\n\r\n            //console.log(callerHeight, delta);\r\n\r\n            // start with the sections after the caller - balance space from siblings below\r\n            for (i = self.sections.indexOf(caller) + 1; i < self.sections.length; i += 1) {\r\n                section = self.sections[i];\r\n\r\n                // skip non expanded sections\r\n                if (!section.isExpanded || section.fixed) {\r\n                    continue;\r\n                }\r\n\r\n                // can't shrink more than minimum\r\n                height = Math.max(self.HEADING_HEIGHT, section.startHeight - (delta - progress));\r\n\r\n                // update progress for next if any delta left\r\n                progress += Math.min(section.startHeight - self.HEADING_HEIGHT, delta - progress);\r\n\r\n                //console.log(section.$header.text());\r\n                section.$el.height(height + \"px\");\r\n\r\n                // store altered section and heights\r\n                sections.push(section);\r\n                heights.push(height);\r\n\r\n                // delta complete\r\n                if (progress === delta) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // redraw\r\n            self.adjustWeights(sections, heights);\r\n        }\r\n\r\n        resize() {\r\n            this.updateLayout(false);\r\n        }\r\n\r\n        setExpanded(index, isExpanded, animate) {\r\n            animate = animate || true;\r\n            this.sections[index].isExpanded = isExpanded;\r\n            this.updateLayout(animate);\r\n        }\r\n\r\n        sum(list) {\r\n            return _.reduce(\r\n                list,\r\n                function(memo, num) {\r\n                    return memo + num;\r\n                },\r\n                0,\r\n            );\r\n        }\r\n\r\n        updateLayout(animate?: boolean) {\r\n            let self = this,\r\n                height = self.$el.height(),\r\n                visibleWeight,\r\n                ratio,\r\n                visibleSections,\r\n                availableHeight = height;\r\n\r\n            self.$el.toggleClass(\"animate\", animate);\r\n            visibleSections = _.filter(self.sections, { isExpanded: true });\r\n\r\n            // subtract minimum heights\r\n            availableHeight -=\r\n                (self.sections.length - visibleSections.length) * self.HEADING_HEIGHT;\r\n\r\n            // subtract expanded fixed sections\r\n            availableHeight -= this.sum(\r\n                _.map(\r\n                    _.filter(visibleSections, function(section) {\r\n                        return section.isExpanded && section.fixed;\r\n                    }),\r\n                    function(section) {\r\n                        return section.fixed;\r\n                    },\r\n                ),\r\n            );\r\n\r\n            visibleWeight = this.sum(\r\n                _.map(visibleSections, function(section) {\r\n                    return section.weight;\r\n                }),\r\n            );\r\n\r\n            ratio = availableHeight / visibleWeight;\r\n\r\n            _.each(self.sections, function(section, i) {\r\n                // toggle class\r\n                section.$el.toggleClass(\"expanded\", section.isExpanded);\r\n\r\n                // set height\r\n                if (section.isExpanded) {\r\n                    section.$el.height((section.fixed || section.weight * ratio) + \"px\");\r\n                } else {\r\n                    section.$el.height(0);\r\n                }\r\n\r\n                if (section.resize) {\r\n                    section.resize();\r\n                }\r\n\r\n                // configure resize for sections with neighbor expanded after\r\n                if (\r\n                    section.isResizable &&\r\n                    section.isExpanded &&\r\n                    !section.fixed &&\r\n                    i < self.sections.length - 1 &&\r\n                    _.some(self.sections.slice(i + 1), function(s) {\r\n                        return s.isExpanded && !s.fixed;\r\n                    })\r\n                ) {\r\n                    // init\r\n                    section.resizeable = section.$el[\"resizable\"]({\r\n                        handles: \"s\",\r\n                        resize: $.proxy(self.onSectionResize, self, section),\r\n                        start: function() {\r\n                            _.each(self.sections, function(s) {\r\n                                s.startHeight = s.$el.height();\r\n                            });\r\n\r\n                            section.$el[\"resizable\"](\r\n                                \"option\",\r\n                                \"maxHeight\",\r\n                                self.$el.height() -\r\n                                    (self.sections.length - 1) * self.HEADING_HEIGHT,\r\n                            );\r\n                        },\r\n                        stop: function() {\r\n                            self.updateLayout();\r\n                        },\r\n                    });\r\n                } else if (section.resizeable) {\r\n                    // destroy\r\n                    section.$el[\"resizable\"](\"destroy\");\r\n                    delete section.resizeable;\r\n                }\r\n            });\r\n\r\n            if (animate) {\r\n                this.debouncedRemoveAnimate();\r\n            } else {\r\n                if (self.onUpdate) {\r\n                    self.onUpdate(self.sections);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","/// <reference types=\"backbone\"/>\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export abstract class CustomEvents {\n        constructor() {\n            _.extend(this, Backbone.Events);\n        }\n\n        on(eventName: string, callback?: Function, context?: any): any {\n            return;\n        }\n        off(eventName?: string, callback?: Function, context?: any): any {\n            return;\n        }\n        trigger(eventName: string, ...args: any[]): any {\n            return;\n        }\n        bind(eventName: string, callback: Function, context?: any): any {\n            return;\n        }\n        unbind(eventName?: string, callback?: Function, context?: any): any {\n            return;\n        }\n\n        once(events: string, callback: Function, context?: any): any {\n            return;\n        }\n        listenTo(object: any, events: string, callback: Function): any {\n            return;\n        }\n        listenToOnce(object: any, events: string, callback: Function): any {\n            return;\n        }\n        stopListening(object?: any, events?: string, callback?: Function): any {\n            return;\n        }\n    }\n}\n","/// <reference path=\"../classes/log.ts\" />\r\n/// <reference path=\"CustomEvents.ts\"/>\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export interface DocNode {\r\n        id: string;\r\n        label: string;\r\n        model: QuickBase.DocumentDataModel | QuickBase.DocumentViewModel;\r\n        visited: boolean;\r\n    }\r\n\r\n    export class DocumentGraph extends CustomEvents {\r\n        nodes: { [index: string]: DocNode } = {};\r\n        edges: { [index: string]: Array<string> } = {};\r\n        edgesR: { [index: string]: Array<string> } = {};\r\n        hierarchical: boolean;\r\n        subscriptions: { [index: string]: any } = {};\r\n        activeViewStateToSubscriptions: { [index: string]: DocumentViewModel } = {};\r\n        onNodeUpdate;\r\n\r\n        getDataSourceByPath: (string) => DocumentDataModel;\r\n\r\n        constructor(\r\n            viewState: DocumentViewModel,\r\n            dataSources: Array<DocumentDataModel>,\r\n            getDataSourceByPath,\r\n            onNodeUpdate,\r\n        ) {\r\n            super();\r\n            this.getDataSourceByPath = getDataSourceByPath;\r\n            this.onNodeUpdate = onNodeUpdate;\r\n\r\n            const vsl = viewState.getViewStateList();\r\n            vsl.forEach(vsi => {\r\n                if (vsi.model.get(\"_type\") === \"dict\") {\r\n                    const vsNodeId = this.addNode(\"vs\", vsi.path, vsi.model);\r\n                    _.each(vsi.model.get(\"value\"), value => {\r\n                        if (value && value.path) {\r\n                            const valueNodeId = this.addNode(\"vs\", value.path, value);\r\n                            this.addEdge({ fromNodeId: valueNodeId, toNodeId: vsNodeId });\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n\r\n            _.each(dataSources, (ds: DocumentDataModel) => {\r\n                if (ds && ds.path) {\r\n                    const dsNodeId = this.addNode(\"ds\", ds.path, ds);\r\n\r\n                    // input view states\r\n                    _.each(ds.getViewStateDict(), (vs: DocumentViewModel) => {\r\n                        if (vs && vs.path) {\r\n                            const vsNodeId = this.addNode(\"vs\", vs.path, vs);\r\n                            this.addEdge({ fromNodeId: vsNodeId, toNodeId: dsNodeId });\r\n                        }\r\n                    });\r\n\r\n                    // output view state\r\n                    _.each(ds.getMappedViewStates(), (vs: DocumentViewModel) => {\r\n                        if (vs && vs.path) {\r\n                            const vsNodeId = this.addNode(\"vs\", vs.path, vs);\r\n                            this.addEdge({ fromNodeId: dsNodeId, toNodeId: vsNodeId });\r\n                        }\r\n                    });\r\n\r\n                    // input data sources\r\n                    if (ds.get(\"_dataType\") === \"virtual\") {\r\n                        _.each(\r\n                            _.filter(ds.get(\"_virtualParams\"), { type: \"datasource\" }).map(\r\n                                d => d[\"value\"],\r\n                            ),\r\n                            (dsPath: string) => {\r\n                                const dsParam = this.getDataSourceByPath(dsPath);\r\n                                if (dsParam) {\r\n                                    const dsNode2Id = this.addNode(\"ds\", dsPath, ds);\r\n                                    this.addEdge({ fromNodeId: dsNode2Id, toNodeId: dsNodeId });\r\n                                } else {\r\n                                    Log.Warn(\r\n                                        \"DocumentGraph: \" +\r\n                                            ds.path +\r\n                                            \" has invalid source parameter  \" +\r\n                                            ds.path,\r\n                                    );\r\n                                }\r\n                            },\r\n                        );\r\n                    }\r\n                }\r\n            });\r\n\r\n            if (_.isUndefined(this.hierarchical)) {\r\n                this.hierarchical = _.keys(this.nodes).length < 20;\r\n            }\r\n        }\r\n\r\n        private static addEdgeToCollection(\r\n            edgeCollection: { [index: string]: Array<string> },\r\n            fromNodeId: string,\r\n            toNodeId: string,\r\n        ): void {\r\n            const edgeNodeList = edgeCollection[fromNodeId];\r\n            if (edgeNodeList) {\r\n                if (edgeNodeList.indexOf(toNodeId) === -1) {\r\n                    edgeNodeList.push(toNodeId);\r\n                }\r\n            } else edgeCollection[fromNodeId] = [toNodeId];\r\n        }\r\n\r\n        /**\r\n         * gets all of the associated query mappers for a dataform\r\n         *\r\n         * @remarks\r\n         * This method is used by DataForm\r\n         *\r\n         * @param viewStatePaths - viewstates represented in the form\r\n         * @param dataSourcePaths - additional data sources used by this form, dropdown list etc.\r\n         * @param propertyViewStates - viewstate used by properties of this form\r\n         * @returns The datasources that are need to be cloned\r\n         */\r\n        public getFormDataSources(\r\n            viewStatePaths: Array<string>,\r\n            dataSourcePaths: Array<string>,\r\n            propertyViewStates: Array<string>,\r\n        ): Array<any> {\r\n            // get DSs that are changed by the form fields / viewstates themselves\r\n            const vsInNodes = this.getRelatedDataSources(\r\n                _.map(viewStatePaths, vs => \"vs:\" + vs),\r\n                this.edges,\r\n            );\r\n\r\n            // get DSs from viewStates are written to\r\n            const vsOutNodes = this.getRelatedDataSources(\r\n                _.map(viewStatePaths, vs => \"vs:\" + vs),\r\n                this.edgesR,\r\n            );\r\n\r\n            // get DSs that influence our dropdowns etc.\r\n            const dsNodes = this.getRelatedDataSources(\r\n                _.map(dataSourcePaths, ds => \"ds:\" + ds),\r\n                this.edgesR,\r\n            );\r\n\r\n            // get DSs that change our properties\r\n            const propertyNodes = this.getRelatedDataSources(\r\n                _.map(propertyViewStates, vs => \"vs:\" + vs),\r\n                this.edgesR,\r\n            );\r\n\r\n            // remove group prefix from Id\r\n            return _.map(\r\n                _.union(\r\n                    // DS where fields change drop-downs etc\r\n                    _.intersection(vsInNodes, dsNodes),\r\n                    // DS where fields change fields\r\n                    _.intersection(vsInNodes, vsOutNodes),\r\n                    // DS where fields change properties\r\n                    propertyNodes,\r\n                ),\r\n                nodeId => this.nodes[nodeId].model,\r\n            );\r\n        }\r\n\r\n        public unsubscribeAll(): void {\r\n            _.each(this.subscriptions, node => this.unsubscribe(node.source));\r\n            _.each(this.activeViewStateToSubscriptions, m => this.unsubscribeViewStates(m));\r\n        }\r\n\r\n        private addEdge({ fromNodeId, toNodeId }: { fromNodeId: string; toNodeId: string }): void {\r\n            DocumentGraph.addEdgeToCollection(this.edges, fromNodeId, toNodeId);\r\n            DocumentGraph.addEdgeToCollection(this.edgesR, toNodeId, fromNodeId);\r\n        }\r\n\r\n        private addNode(group: \"vs\" | \"ds\", nodeId: string, model): string {\r\n            const uid = group + \":\" + nodeId;\r\n            if (!this.nodes[uid]) {\r\n                this.nodes[uid] = {\r\n                    id: uid,\r\n                    label: nodeId,\r\n                    model: model,\r\n                    visited: false,\r\n                };\r\n            }\r\n\r\n            if (this.onNodeUpdate) {\r\n                if (group === \"ds\" && model.agent.subscriberCount()) {\r\n                    this.subscribe(model as DocumentDataModel, this.onNodeUpdate(uid), uid);\r\n                }\r\n                if (group === \"vs\") {\r\n                    this.activeViewStateToSubscriptions[model.path] = model;\r\n                    this.listenTo(\r\n                        model as DocumentViewModel,\r\n                        \"change:value\",\r\n                        this.onNodeUpdate(uid),\r\n                    );\r\n                }\r\n            }\r\n\r\n            return uid;\r\n        }\r\n\r\n        private breadthFirstSearch(\r\n            nodeId: string,\r\n            edges: { [index: string]: Array<string> },\r\n        ): string[] {\r\n            _.each(this.nodes, n => {\r\n                n.visited = false;\r\n            });\r\n            return this.visitAndMeetNeighbors(nodeId, edges);\r\n        }\r\n\r\n        private getDataSourceKey(dataSource): string {\r\n            if (!dataSource) {\r\n                return undefined;\r\n            }\r\n            return dataSource.path || dataSource.cid;\r\n        }\r\n\r\n        private getRelatedDataSources(\r\n            paths: Array<string>,\r\n            edges: { [index: string]: Array<string> },\r\n        ): Array<string> {\r\n            // get a flat list of all related node Ids\r\n            const nodeIds = _.reduce(\r\n                paths,\r\n                (memo, path) => memo.concat(this.breadthFirstSearch(path, edges)),\r\n                [],\r\n            );\r\n            // return a unique list of data source node ids\r\n            return _.uniq(nodeIds.filter(nodeId => nodeId.indexOf(\"ds\") === 0));\r\n        }\r\n\r\n        private subscribe(source, callback, uid, raw?, pagingInfo?): boolean {\r\n            const dataSourceKey = this.getDataSourceKey(source);\r\n\r\n            if (this.subscriptions[dataSourceKey]) {\r\n                // Already subscribed\r\n                this.subscriptions[dataSourceKey].callback = callback;\r\n                return false;\r\n            }\r\n\r\n            // New subscription\r\n            this.subscriptions[dataSourceKey] = {\r\n                source: source,\r\n                onData: callback,\r\n            };\r\n\r\n            this.subscriptions[dataSourceKey].key = _.uniqueId(uid + \"_\");\r\n\r\n            source.subscribe(\r\n                this.subscriptions[dataSourceKey].key,\r\n                this.subscriptions[dataSourceKey],\r\n                raw,\r\n                pagingInfo,\r\n            );\r\n\r\n            return true;\r\n        }\r\n\r\n        private unsubscribe(source): void {\r\n            const dataSourceKey = this.getDataSourceKey(source);\r\n            if (this.subscriptions[dataSourceKey]) {\r\n                source.unsubscribe(this.subscriptions[dataSourceKey].key);\r\n                delete this.subscriptions[dataSourceKey];\r\n            }\r\n        }\r\n\r\n        private unsubscribeViewStates(model): void {\r\n            _.each(this.activeViewStateToSubscriptions, (value, key) => {\r\n                const vs = model.getByPath(key);\r\n                this.stopListening(vs, \"change:value\");\r\n                delete this.activeViewStateToSubscriptions[key];\r\n            });\r\n        }\r\n\r\n        private visitAndMeetNeighbors(\r\n            nodeId: string,\r\n            edges: { [index: string]: Array<string> },\r\n        ): string[] {\r\n            let visited: Array<string> = [];\r\n            if (this.nodes[nodeId]) {\r\n                if (!this.nodes[nodeId].visited) {\r\n                    this.nodes[nodeId].visited = true;\r\n                    visited.push(nodeId);\r\n\r\n                    const neighbors = edges[nodeId];\r\n                    if (neighbors) {\r\n                        visited = _.reduce(\r\n                            neighbors,\r\n                            (memo, nodeId) =>\r\n                                memo.concat(this.visitAndMeetNeighbors(nodeId, edges)),\r\n                            visited,\r\n                        );\r\n                    }\r\n                } else {\r\n                    // TODO: handle cycle - show warning\r\n                }\r\n            }\r\n            return visited;\r\n        }\r\n    }\r\n}\r\n","namespace QuickBase {\n    interface INotificationObj {\n        title: string;\n        message: string;\n        icon: string;\n    }\n\n    interface ITriggers {\n        template: string;\n        source: DocumentDataModel | undefined;\n        icon: string;\n        sound: string;\n    }\n\n    interface ISoundConfig {\n        sound: string;\n    }\n\n    export class DatasourceNotifier {\n        private sendNotification: (id: string, obj: INotificationObj, sound: ISoundConfig) => void;\n        private datasources: { [index: string]: any } = {};\n        private templates: { [index: string]: any } = {};\n        private triggers: ITriggers[];\n\n        constructor(show: (id: string, obj: INotificationObj, sound: ISoundConfig) => void) {\n            this.triggers = [];\n            this.sendNotification = show;\n        }\n\n        public onTriggerChange(triggers) {\n            this.triggers = triggers;\n            const cids = triggers.map((x) => {\n                if (x.source) {\n                    return x.source.cid;\n                }\n            });\n\n            // Ensure we are subscribed to each datasource\n            triggers.forEach((trigger) => {\n                const { template, source, icon, sound } = trigger;\n                // For Each trigger ensure we are subscribed\n                if (source && !this.datasources[source.cid]) {\n                    this.datasources[source.cid] = new NotificationListener(source, template, icon, sound, this.sendNotification);\n                } else if (source) {\n                    this.datasources[source.cid].updateTemplate(template, icon, sound);\n                }\n            })\n\n            const unsubscriptions = Object.keys(this.datasources).filter((cid) => {\n                return cids.indexOf(cid) === -1;\n            });\n\n            unsubscriptions.forEach(cid => {\n                this.datasources[cid].unsubscribe();\n                this.datasources[cid] = undefined;\n                delete this.datasources[cid];\n            })\n\n        }\n    }\n\n    class NotificationListener {\n        private template: HandlebarsTemplateDelegate<any>;\n        private sendNotification: (id: string, obj: INotificationObj, sound: ISoundConfig) => void;\n        private source: DocumentDataModel;\n        private icon: string;\n        private sound: string;\n\n        constructor(\n            source: DocumentDataModel,\n            template: string,\n            icon: string,\n            sound: string,\n            sendNotification: (id: string, obj: INotificationObj, sound: ISoundConfig) => void\n        ) {\n            this.source = source;\n            this.sound = sound;\n            this.icon = icon;\n            this.template = Handlebars.compile(template);\n            this.sendNotification = sendNotification;\n            this.subscribe();\n        }\n\n        public updateTemplate(template, icon, sound) {\n            this.template = Handlebars.compile(template);\n            this.icon = icon;\n            this.sound = sound;\n        }\n\n        private subscribe() {\n            this.source.subscribe('notifications', this);\n            this.source.dataSet.noBackground = true;\n        }\n\n        public unsubscribe() {\n            this.source.unsubscribe('notifications')\n        }\n\n        public onData(collection, changeset) {\n            // Do We Notify on Reset, Add or Both?\n            if (changeset.add && changeset.add.length) {\n                changeset.add.forEach((row) => {\n                    // Omit Row Index (we don't want to display this field in notifications)\n                    row = _.omit(row, ['_rowIndex']);\n                    const message = this.template(row);\n                    const title = this.source.path;\n                    const sound = this.sound;\n                    const icon = this.icon;\n\n                    this.sendNotification('datasource-notifications', { title, message, icon }, { sound });\n                })\n            }\n        }\n    }\n}","/*global _,$,console,Backbone */\r\n/// <reference path=\"DatasourceNotifications.ts\" />\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class NotificationManager {\r\n        private static pendingNotifications = [];\r\n        private static pendingNotificationsTimeoutId;\r\n        private static $pnlNotifications: JQuery;\r\n        private static documentDataModel: DocumentDataModel;\r\n\r\n        private static readonly AGGREGATED_ID = \"AGGREGATED_NOTIFICATION\";\r\n\r\n        private static hasNotified = false;\r\n        private static suspendedAudioNotifications = {};\r\n\r\n        private static readonly MEDIA_LOCATION =\r\n            require.toUrl(\"QuickBase\").replace(\"/main\", \"\") + \"/notifications/\";\r\n        private static readonly ICON_LOCATION =\r\n            require.toUrl(\"QuickBase\").replace(\"/main\", \"\") + \"/images/black/\";\r\n        private static readonly ICON_LOCATION_LIGHT =\r\n            require.toUrl(\"QuickBase\").replace(\"/main\", \"\") + \"/images/white/\";\r\n        private static readonly NOTIFICATION_SOUNDS = [\r\n            \"beep\",\r\n            \"beepbeep\",\r\n            \"ding\",\r\n            \"exquisite\",\r\n            \"long-expected\",\r\n            \"festive\",\r\n            \"job-done\",\r\n            \"arcade\",\r\n            \"echo\",\r\n            \"case-closed\",\r\n            \"none\",\r\n        ];\r\n\r\n        private static readonly SCHEMA = {\r\n            type: \"object\",\r\n            title: \"Properties\",\r\n            properties: {\r\n                Notifications: {\r\n                    type: \"object\",\r\n                    title: \"Notifications\",\r\n                    options: {\r\n                        collapsed: true,\r\n                    },\r\n                    properties: {\r\n                        _Version: {\r\n                            type: \"string\",\r\n                            //don't forget making appropriate changes to upgradeConfigToRecentVersion()\r\n                            default: \"4.2.0s2\",\r\n                            options: {\r\n                                hidden: true,\r\n                            },\r\n                        },\r\n                        Enabled: {\r\n                            title: \"Enabled\",\r\n                            propertyOrder: 100,\r\n                            type: \"boolean\",\r\n                            format: \"checkbox\",\r\n                            default: true,\r\n                        },\r\n                        InBrowserNotifications: {\r\n                            title: \"InBrowser\",\r\n                            propertyOrder: 110,\r\n                            type: \"boolean\",\r\n                            format: \"checkbox\",\r\n                            default: false,\r\n                        },\r\n                        Position: {\r\n                            title: \"Position\",\r\n                            propertyOrder: 120,\r\n                            type: \"string\",\r\n                            enum: [\r\n                                \"Top Left\",\r\n                                \"Top Center\",\r\n                                \"Top Right\",\r\n                                \"Center Left\",\r\n                                \"Center Center\",\r\n                                \"Center Right\",\r\n                                \"Bottom Left\",\r\n                                \"Bottom Center\",\r\n                                \"Bottom Right\",\r\n                            ],\r\n                            default: \"Bottom Right\",\r\n                        },\r\n                        MaxVisibleCount: {\r\n                            title: \"Max Count\",\r\n                            propertyOrder: 130,\r\n                            type: \"number\",\r\n                            minimum: 1,\r\n                            default: 3,\r\n                        },\r\n                        FadeOut: {\r\n                            title: \"FadeOut (s)\",\r\n                            propertyOrder: 140,\r\n                            type: \"number\",\r\n                            minimum: 0,\r\n                            default: 5,\r\n                        },\r\n                        Icon: {\r\n                            title: \"Icon\",\r\n                            propertyOrder: 150,\r\n                            type: \"icon\",\r\n                            default: \"fa-bell-o\",\r\n                            iconTypes: \"fa\",\r\n                        },\r\n                        Sound: {\r\n                            title: \"Sound\",\r\n                            propertyOrder: 160,\r\n                            type: \"string\",\r\n                            enum: NotificationManager.NOTIFICATION_SOUNDS,\r\n                            default: \"beep\",\r\n                        },\r\n                        SoundVolume: {\r\n                            title: \"Sound Volume\",\r\n                            propertyOrder: 170,\r\n                            type: \"number\",\r\n                            format: \"range\",\r\n                            minimum: 0,\r\n                            maximum: 100,\r\n                            default: 100,\r\n                        },\r\n                        Grouping: {\r\n                            title: \"Group Notifications\",\r\n                            propertyOrder: 180,\r\n                            type: \"boolean\",\r\n                            format: \"checkbox\",\r\n                            default: false,\r\n                        },\r\n                        GroupingInterval: {\r\n                            title: \"Grouping Interval (s)\",\r\n                            propertyOrder: 190,\r\n                            type: \"number\",\r\n                            minimum: 0,\r\n                            default: 1,\r\n                        },\r\n                        triggers: {\r\n                            title: \"Additional Triggers\",\r\n                            type: \"array\",\r\n                            items: {\r\n                                type: \"object\",\r\n                                id: \"arrItem\",\r\n                                additionalProperties: false,\r\n                                options: {\r\n                                    collapsed: true,\r\n                                },\r\n                                title: \"Datasource Trigger\",\r\n                                properties: {\r\n                                    source: {\r\n                                        type: \"data\",\r\n                                        propertyOrder: 100,\r\n                                        title: \"Datasource\",\r\n                                    },\r\n                                    template: {\r\n                                        type: \"tooltipTemplate\",\r\n                                        propertyOrder: 101,\r\n                                        title: \"Notification Template\",\r\n                                        default: \"{{#each this}}{{@key}}: {{this}}\\n{{/each}}\",\r\n                                    },\r\n                                    sound: {\r\n                                        title: \"Sound\",\r\n                                        propertyOrder: 103,\r\n                                        type: \"string\",\r\n                                        enum: NotificationManager.NOTIFICATION_SOUNDS,\r\n                                        default: \"beep\",\r\n                                    },\r\n                                    icon: {\r\n                                        title: \"Icon\",\r\n                                        iconTypes: \"fa\",\r\n                                        propertyOrder: 102,\r\n                                        type: \"icon\",\r\n                                        //using fontawesome icons for inbrowser notifications and\r\n                                        // *.png files which have to be located in the dist folder\r\n                                        default: \"fa-bell-o\",\r\n                                    },\r\n                                },\r\n                            },\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n        };\r\n\r\n        private static DEFAULT_JSON = {\r\n            Notifications: _.mapValues(\r\n                NotificationManager.SCHEMA.properties.Notifications.properties,\r\n                \"default\",\r\n            ),\r\n        };\r\n\r\n        private static currentSettings = NotificationManager.DEFAULT_JSON;\r\n\r\n        private static readonly datasourceNotifier = new DatasourceNotifier(\r\n            NotificationManager.show,\r\n        );\r\n\r\n        private static generateAggregatedMessage(notifications) {\r\n            const toReturn = [];\r\n\r\n            _.each(notifications, function(n) {\r\n                let finalMessage;\r\n\r\n                //n[1] is visualConfig\r\n                if (n && n[1]) {\r\n                    finalMessage = n[1].message || \"\";\r\n\r\n                    //cut only to 40 chars (API doesn't show more than approx. 40 chars per line)\r\n                    toReturn.push(\r\n                        finalMessage.length > 37\r\n                            ? finalMessage.substring(0, 37) + \" ..\"\r\n                            : finalMessage,\r\n                    );\r\n                }\r\n            });\r\n\r\n            return toReturn.join(\"\\r\\n\");\r\n        }\r\n\r\n        private static generateAudio(sound: string) {\r\n            const now = _.now(),\r\n                suspendedUntil = NotificationManager.suspendedAudioNotifications[sound];\r\n\r\n            if (suspendedUntil === undefined || now > suspendedUntil) {\r\n                NotificationManager.suspendedAudioNotifications[sound] = now + 5000;\r\n                return new Audio(NotificationManager.MEDIA_LOCATION + sound + \".mp3\");\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        private static notify(widgetId: string, visualConfig?: any, soundConfig?: any) {\r\n            let SETTINGS = NotificationManager.currentSettings.Notifications,\r\n                title,\r\n                message,\r\n                icon,\r\n                useVisualFallback,\r\n                $notification;\r\n\r\n            //grouping\r\n            if (\r\n                widgetId !== NotificationManager.AGGREGATED_ID &&\r\n                SETTINGS.Grouping &&\r\n                SETTINGS.GroupingInterval\r\n            ) {\r\n                if (NotificationManager.pendingNotifications.length === 0) {\r\n                    NotificationManager.pendingNotificationsTimeoutId = setTimeout(function() {\r\n                        if (NotificationManager.pendingNotifications.length > 1) {\r\n                            NotificationManager.notify(\r\n                                NotificationManager.AGGREGATED_ID,\r\n                                {\r\n                                    title:\r\n                                        \"\" +\r\n                                        NotificationManager.pendingNotifications.length +\r\n                                        \" alerts received\",\r\n                                    message: NotificationManager.generateAggregatedMessage(\r\n                                        NotificationManager.pendingNotifications,\r\n                                    ),\r\n                                },\r\n                                true,\r\n                            );\r\n                        } else {\r\n                            //only one alert pending\r\n                            NotificationManager.pendingNotifications[0][0] =\r\n                                NotificationManager.AGGREGATED_ID;\r\n                            NotificationManager.notify.apply(\r\n                                NotificationManager,\r\n                                NotificationManager.pendingNotifications[0],\r\n                            );\r\n                        }\r\n\r\n                        NotificationManager.pendingNotificationsTimeoutId = undefined;\r\n                        NotificationManager.pendingNotifications = [];\r\n                    }, SETTINGS.GroupingInterval * 1000);\r\n                }\r\n\r\n                NotificationManager.pendingNotifications.push(_.concat([], arguments));\r\n                return;\r\n            }\r\n\r\n            // Sound notification\r\n            // Sound Config {String|Boolean} if boolean use default, else use sound config object.\r\n            if (soundConfig && SETTINGS.SoundVolume && \"Audio\" in window) {\r\n                try {\r\n                    let audio;\r\n                    if (_.isBoolean(soundConfig) && SETTINGS.Sound !== \"none\") {\r\n                        audio = NotificationManager.generateAudio(SETTINGS.Sound);\r\n                    } else if (soundConfig.sound != \"none\") {\r\n                        audio = NotificationManager.generateAudio(soundConfig.sound);\r\n                    }\r\n\r\n                    if (audio) {\r\n                        audio.volume = SETTINGS.SoundVolume / 100;\r\n                        audio\r\n                            .play()\r\n                            .then(() => {\r\n                                // Play Started Succesfully\r\n                            })\r\n                            .catch(() => {\r\n                                // Auto Play Was Prevented\r\n                                if (!NotificationManager.hasNotified) {\r\n                                    debugger;\r\n                                    //TODO: gk\r\n                                    NotificationManager.notify(\"Notification API\", {\r\n                                        icon: \"fa-volume-off\",\r\n                                        message:\r\n                                            \"Your browser is blocking notification audio, interact with the page to enable audio.\",\r\n                                        title: \"Notification Audio Error\",\r\n                                    });\r\n                                    NotificationManager.hasNotified = true;\r\n                                }\r\n                            });\r\n                    }\r\n                } catch (e) {\r\n                    Log.Error(\"Audio API ERROR\", arguments);\r\n                }\r\n            }\r\n\r\n            //visual notification\r\n            if (visualConfig) {\r\n                useVisualFallback =\r\n                    SETTINGS.InBrowserNotifications ||\r\n                    !(\"Notification\" in window) ||\r\n                    Notification.permission === \"denied\";\r\n\r\n                title = visualConfig.title || \"Alert\";\r\n                message = visualConfig.message || \"\";\r\n\r\n                icon = visualConfig.icon\r\n                    ? visualConfig.icon\r\n                    : SETTINGS.Icon !== \"none\"\r\n                    ? SETTINGS.Icon\r\n                    : null;\r\n\r\n                // Remove \"fa-\" from icon\r\n                icon = icon.substring(3);\r\n\r\n                if (useVisualFallback) {\r\n                    //init notification panel\r\n                    if (!NotificationManager.$pnlNotifications) {\r\n                        NotificationManager.$pnlNotifications = $(\"<div></div>\", {\r\n                            class: \"pnlInBrowserNotifications\",\r\n                        }).appendTo($(\".document-view\"));\r\n\r\n                        const btnCloseClick = function() {\r\n                            const $el = $(this).closest(\".inBrowserNotification\"),\r\n                                fadeOutId = $el.data(\"fadeOutId\");\r\n\r\n                            //remove existing time out\r\n                            if (fadeOutId) {\r\n                                clearTimeout(fadeOutId);\r\n                            }\r\n\r\n                            $el.remove();\r\n                        };\r\n\r\n                        NotificationManager.$pnlNotifications.on(\"click\", \"i\", btnCloseClick);\r\n                        NotificationManager.$pnlNotifications.on(\r\n                            \"dblclick\",\r\n                            \".inBrowserNotification\",\r\n                            btnCloseClick,\r\n                        );\r\n                    }\r\n\r\n                    //reposition, configuration might have changed\r\n                    NotificationManager.positionPanel(\r\n                        NotificationManager.$pnlNotifications,\r\n                        SETTINGS.Position,\r\n                    );\r\n\r\n                    //remove oldest alert\r\n                    if (\r\n                        NotificationManager.$pnlNotifications.children().length >=\r\n                        SETTINGS.MaxVisibleCount\r\n                    ) {\r\n                        NotificationManager.$pnlNotifications\r\n                            .children()\r\n                            .first()\r\n                            .remove();\r\n                    }\r\n\r\n                    //create & display alert\r\n                    $notification = $(\r\n                        T.InBrowserNotification({\r\n                            title: title,\r\n                            message: message.replace(/\\r\\n/g, \"<br/>\"),\r\n                            icon: icon,\r\n                        }),\r\n                    ).appendTo(NotificationManager.$pnlNotifications);\r\n\r\n                    //setup fade out\r\n                    if (SETTINGS.FadeOut) {\r\n                        $notification.data(\r\n                            \"fadeOutId\",\r\n                            setTimeout(\r\n                                $notification.remove.bind($notification),\r\n                                SETTINGS.FadeOut * 1000,\r\n                            ),\r\n                        );\r\n                    }\r\n                } else {\r\n                    try {\r\n                        const notification = new Notification(title, {\r\n                            //https://developer.mozilla.org/en-US/docs/Web/API/Notification/body\r\n                            body: message,\r\n                            icon: icon\r\n                                ? NotificationManager.isWindows10()\r\n                                    ? NotificationManager.ICON_LOCATION_LIGHT + icon + \".png\"\r\n                                    : NotificationManager.ICON_LOCATION + icon + \".png\"\r\n                                : undefined,\r\n                            //sound not supported as of march 2018\r\n                            //https://developer.mozilla.org/en-US/docs/Web/API/Notification/sound\r\n                            silent: true,\r\n                        });\r\n\r\n                        if (SETTINGS.FadeOut) {\r\n                            var removeNotification = function() {\r\n                                notification.close();\r\n                                window.removeEventListener(\"beforeunload\", removeNotification);\r\n                            };\r\n\r\n                            notification.onshow = function() {\r\n                                setTimeout(removeNotification, SETTINGS.FadeOut * 1000);\r\n                            };\r\n\r\n                            window.addEventListener(\"beforeunload\", removeNotification);\r\n                        }\r\n                    } catch (e) {\r\n                        Log.Error(\"Notification API ERROR\", arguments);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        static positionPanel($pnlNotifications, position) {\r\n            const newClasses = {\r\n                \"Top Left\": \"\",\r\n                \"Top Center\": \"position_center\",\r\n                \"Top Right\": \"position_right\",\r\n                \"Center Left\": \"position_middle\",\r\n                \"Center Center\": \"position_middle position_center\",\r\n                \"Center Right\": \"position_middle position_right\",\r\n                \"Bottom Left\": \"position_bottom\",\r\n                \"Bottom Center\": \"position_bottom position_center\",\r\n                \"Bottom Right\": \"position_bottom position_right\",\r\n            }[position];\r\n\r\n            //can change depending on settings\r\n            $pnlNotifications\r\n                .removeClass(\"position_middle position_bottom position_center position_right\")\r\n                .addClass(newClasses);\r\n        }\r\n\r\n        static isWindows10() {\r\n            return window.navigator.userAgent.search(/(Windows 10.0)|(Windows NT 10.0)/) >= 0;\r\n        }\r\n\r\n        //called when dashboard is loaded\r\n        public static setOptions(options) {\r\n            NotificationManager.currentSettings = options;\r\n            NotificationManager.datasourceNotifier.onTriggerChange(\r\n                options.Notifications.triggers || [],\r\n            );\r\n\r\n            if (NotificationManager.pendingNotificationsTimeoutId) {\r\n                clearTimeout(NotificationManager.pendingNotificationsTimeoutId);\r\n                NotificationManager.pendingNotificationsTimeoutId = undefined;\r\n                NotificationManager.pendingNotifications = [];\r\n            }\r\n        }\r\n\r\n        public static show(widgetId: string, visualConfig?: any, soundConfig?: any) {\r\n            let origArgs;\r\n\r\n            if (NotificationManager.currentSettings.Notifications.Enabled) {\r\n                if (\r\n                    NotificationManager.currentSettings.Notifications.InBrowserNotifications ||\r\n                    !(\"Notification\" in window) ||\r\n                    Notification.permission === \"granted\" ||\r\n                    Notification.permission === \"denied\"\r\n                ) {\r\n                    //if API is blocked, use fallback anyway\r\n                    NotificationManager.notify(widgetId, visualConfig, soundConfig);\r\n                } else {\r\n                    origArgs = arguments;\r\n\r\n                    Notification.requestPermission(function() {\r\n                        //rerun this function, Notification.permission should be set now\r\n                        NotificationManager.show.apply(this, origArgs);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        static upgradeConfig(cfg) {\r\n            //use defaults if no config found\r\n            if (cfg) {\r\n                // upgrade cfg\r\n                let version, recentVersion;\r\n\r\n                version = cfg.Notifications._Version;\r\n                recentVersion = NotificationManager.DEFAULT_JSON.Notifications._Version;\r\n\r\n                if (version !== recentVersion) {\r\n                    //updates go here\r\n                    cfg.Notifications._Version = recentVersion;\r\n                }\r\n            } else {\r\n                cfg = NotificationManager.DEFAULT_JSON;\r\n            }\r\n\r\n            // convert paths to models\r\n            cfg.Notifications.triggers = cfg.Notifications.triggers\r\n                ? cfg.Notifications.triggers.map(trigger => {\r\n                      const source = trigger.source;\r\n                      return {\r\n                          ...trigger,\r\n                          source:\r\n                              source._dashboardsType === \"data\"\r\n                                  ? NotificationManager.documentDataModel.getByPath(source.value)\r\n                                  : source,\r\n                      };\r\n                  })\r\n                : [];\r\n            return cfg;\r\n        }\r\n\r\n        public static setDocumentDataModel(docDataModel) {\r\n            this.documentDataModel = docDataModel;\r\n        }\r\n\r\n        public static CONFIG = {\r\n            SCHEMA: NotificationManager.SCHEMA,\r\n            upgradeConfig: NotificationManager.upgradeConfig,\r\n        };\r\n    }\r\n}\r\n","/*global _,$,console,Backbone */\r\n/// <reference path=\"../classes/log.ts\"/>\r\n/// <reference path=\"../classes/ComponentInterface.ts\"/>\r\n/// <reference path=\"../views/AppView.ts\"/>\r\n/// <reference path=\"../models/DocumentViewModel.ts\"/>\r\n/// <reference path=\"DocumentGraph.ts\"/>\r\n/// <reference path=\"NotificationManager.ts\"/>\r\n/// <reference path=\"CustomEvents.ts\"/>\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    /**\r\n     * API for Component interaction with Dashboards\r\n     * @class\r\n     */\r\n    export class ComponentApi extends CustomEvents implements ComponentInterface {\r\n        appKey: string;\r\n        autosaveDashboardId: string;\r\n        componentId: string;\r\n        dashboardAppModel: Backbone.DeepModel;\r\n        dashboardViewModel: DocumentViewModel;\r\n        deltaClient: win.Client;\r\n        deltaClientLib: QuickBase.DeltaClientLib;\r\n        docDataModel: DocumentDataModel;\r\n        docViewModel: DocumentViewModel;\r\n        genericTooltip: QuickBase.GenericTooltip;\r\n        saveSettingsNowDebounced = _.debounce(this.saveSettingsNow.bind(this), 100);\r\n        settingsModel: Backbone.DeepModel;\r\n        tooltipSubscriptionKey: string;\r\n        quickView: boolean;\r\n        widgetId: string;\r\n\r\n        activeViewStateToPropertyPaths = {};\r\n        propertyPathsToViewStates = {};\r\n\r\n        activeViewStateToSubscriptions = {};\r\n        subscriptionsToViewStates = {};\r\n        viewStateSubscriptions = {};\r\n\r\n        interface = {}; // list of methods/references that will be exposed to the component\r\n        subscriptions = {}; // stores subscription info when a component subscribes to a datasource\r\n\r\n        constructor(options) {\r\n            //debugger;\r\n            super();\r\n            let methods = [];\r\n\r\n            // dashboard variables\r\n            this.appKey = options.appKey;\r\n            this.componentId = options.componentId;\r\n            this.dashboardAppModel = options.dashboardAppModel;\r\n            this.dashboardViewModel = options.dashboardViewModel;\r\n            this.deltaClient = options.deltaClient;\r\n            this.deltaClientLib = options.deltaClientLib;\r\n            this.docDataModel = options.docDataModel;\r\n            this.docViewModel = options.docViewModel;\r\n            this.settingsModel = options.settingsModel;\r\n            this.quickView = options.quickView;\r\n            this.widgetId = options.widgetId;\r\n\r\n            this.activeViewStateToPropertyPaths = {};\r\n            this.propertyPathsToViewStates = {};\r\n\r\n            this.interface = {}; // list of methods/references that will be exposed to the component\r\n            this.subscriptions = {}; // stores subscription info when a component subscribes to a datasource\r\n\r\n            // build list of methods\r\n            methods = _.union(methods, ComponentApi.API_METHODS);\r\n\r\n            if (options.advancedMethods) {\r\n                // this could be updated to only include advanced methods for certain components\r\n                methods = _.union(methods, ComponentApi.ADVANCED_METHODS);\r\n            }\r\n\r\n            _.each(\r\n                methods,\r\n                _.bind(function(method) {\r\n                    if (_.isFunction(this[method])) {\r\n                        this.interface[method] = _.bind(this[method], this);\r\n                    } else if (!_.isUndefined(this[method])) {\r\n                        this.interface[method] = this[method];\r\n                    }\r\n                }, this),\r\n            );\r\n\r\n            // listen for view state name changes\r\n            this.listenTo(this.docViewModel, \"change\", function(model, value) {\r\n                let oldKey, newKey;\r\n\r\n                // a view state rename involves two changes - unsetting the old path and setting the new one\r\n\r\n                if (value && value.unset) {\r\n                    // unset operation\r\n                    // however, an unset view state may be a delete or a rename\r\n                    this.renamingViewState =\r\n                        (model.path ? model.path + \"/\" : \"\") + _.first(_.keys(model.changed));\r\n\r\n                    _.defer(\r\n                        _.bind(function() {\r\n                            // a renamed view state will be set immediately, trigger a change and be and handled below\r\n                            // a deleted view state won't trigger another change\r\n                            // so resetting renamingViewState here avoids deleted view states conflicting with future changes\r\n                            this.renamingViewState = null;\r\n                        }, this),\r\n                    );\r\n                } else if (this.renamingViewState) {\r\n                    // set operation\r\n                    oldKey = this.renamingViewState;\r\n                    newKey = (model.path ? model.path + \"/\" : \"\") + _.first(_.keys(model.changed));\r\n\r\n                    if (oldKey !== newKey) {\r\n                        // update activeViewStateToPropertyPaths\r\n                        if (this.activeViewStateToPropertyPaths[oldKey]) {\r\n                            this.activeViewStateToPropertyPaths[\r\n                                newKey\r\n                            ] = this.activeViewStateToPropertyPaths[oldKey];\r\n                            delete this.activeViewStateToPropertyPaths[oldKey];\r\n                        }\r\n\r\n                        // update activeViewStateToSubscriptions\r\n                        if (this.activeViewStateToSubscriptions[oldKey]) {\r\n                            this.activeViewStateToSubscriptions[\r\n                                newKey\r\n                            ] = this.activeViewStateToSubscriptions[oldKey];\r\n                            delete this.activeViewStateToSubscriptions[oldKey];\r\n                        }\r\n\r\n                        // update propertyPathsToViewStates\r\n                        _.each(\r\n                            this.propertyPathsToViewStates,\r\n                            _.bind(function(viewState, propertyPath) {\r\n                                if (viewState === oldKey) {\r\n                                    this.propertyPathsToViewStates[propertyPath] = newKey;\r\n                                }\r\n                            }, this),\r\n                        );\r\n\r\n                        // update subscriptionsToViewStates\r\n                        _.each(\r\n                            this.subscriptionsToViewStates,\r\n                            _.bind(function(viewStates, subscriptionId) {\r\n                                _.each(viewStates, function(viewState, i) {\r\n                                    if (viewState === oldKey) {\r\n                                        this.subscriptionsToViewStates[subscriptionId][i] = newKey;\r\n                                    }\r\n                                });\r\n                            }, this),\r\n                        );\r\n                    }\r\n\r\n                    this.renamingViewState = null;\r\n                } else {\r\n                    this.renamingViewState = null;\r\n                }\r\n            });\r\n        }\r\n\r\n        // static variables\r\n        static readonly ADVANCED_METHODS = [\"deltaClient\"];\r\n\r\n        static readonly NAMESPACE_SEPARATOR = \":\";\r\n\r\n        static readonly API_METHODS = [\r\n            \"destroySettings\",\r\n            \"doActions\",\r\n            \"exportData\",\r\n            \"getProperty\",\r\n            \"getPropertyMeta\",\r\n            \"getDataSourceMap\",\r\n            \"getViewState\",\r\n            \"getTemplateViewStates\",\r\n            \"hideErrorMessage\",\r\n            \"hideQueryStatus\",\r\n            \"isBuildMode\",\r\n            \"isSelected\",\r\n            \"loadApp\",\r\n            \"loadSetting\",\r\n            \"navigate\",\r\n            \"page\",\r\n            \"removeTooltip\",\r\n            \"saveSetting\",\r\n            \"setProperty\",\r\n            \"setTooltip\",\r\n            \"setViewState\",\r\n            \"showErrorMessage\",\r\n            \"showNotification\",\r\n            \"showQueryStatus\",\r\n            \"subscribe\",\r\n            \"subscribeTemplateViewStates\",\r\n            \"unsubscribe\",\r\n            \"unsubscribeTemplateViewStates\",\r\n            \"updateTable\",\r\n        ];\r\n\r\n        public getDataSourceMap(viewStatePaths, dataSourcePaths, propertyViewStates) {\r\n            const docId = this.dashboardViewModel.get(\"selectedDocumentId\"),\r\n                doc = this.dashboardAppModel.get(\"documents\").get(docId);\r\n\r\n            try {\r\n                const graph = new DocumentGraph(\r\n                    doc.get(\"viewState\"),\r\n                    doc.get(\"data\").flatten(), // flat list of data sources\r\n                    doc.get(\"data\").getByPath.bind(doc.get(\"data\")),\r\n                    null,\r\n                );\r\n\r\n                return graph.getFormDataSources(\r\n                    viewStatePaths,\r\n                    dataSourcePaths,\r\n                    propertyViewStates,\r\n                );\r\n            } catch (e) {\r\n                console.error(\"ComponentApi.getDataSourceMap error\", e);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Converts fields of the given type in options to their corresponding model\r\n         * @param {String} type\r\n         * @param {Object} schema\r\n         * @param {Object} options\r\n         */\r\n        public convertPathsToModels(type, schema, options) {\r\n            let self = this,\r\n                converter,\r\n                leaf = function(obj, path) {\r\n                    path = path.split(\".\");\r\n                    let res = obj;\r\n                    for (let i = 0; i < path.length; i++) {\r\n                        if (res) {\r\n                            res = res[path[i]];\r\n                        }\r\n                    }\r\n                    return res;\r\n                },\r\n                properties,\r\n                separator = Backbone.DeepModel.keyPathSeparator;\r\n\r\n            if (!type) {\r\n                return false;\r\n            }\r\n\r\n            switch (type) {\r\n                case \"data\":\r\n                    converter = $.proxy(self.docDataModel.getByPath, self.docDataModel);\r\n                    break;\r\n                case \"viewstate\":\r\n                    converter = $.proxy(self.docViewModel.getByPath, self.docViewModel);\r\n                    break;\r\n            }\r\n\r\n            // get the list of properties in schema that match the given type\r\n            properties = self.getPropertiesByType(type, schema.properties, schema.definitions);\r\n\r\n            _.each(properties, function(dataProperty) {\r\n                let model, path, prop, splitProp;\r\n\r\n                // remove editor keywords to get back to simple dot notation\r\n                prop = dataProperty.replace(/\\.properties/g, \"\");\r\n                prop = prop.replace(/\\.oneOf\\.\\d+/g, \"\");\r\n\r\n                splitProp = prop.split(\".items.\");\r\n\r\n                if (splitProp.length > 1) {\r\n                    // path contains an array\r\n                    const arrayPath = splitProp[0],\r\n                        arrayItemSuffix = splitProp[1],\r\n                        array = options.get(arrayPath);\r\n\r\n                    _.each(array, function(arrayItem, i) {\r\n                        path = leaf(arrayItem, arrayItemSuffix);\r\n\r\n                        if (path) {\r\n                            if (path[\"_dashboardsType\"]) {\r\n                                path = path.value;\r\n                            }\r\n\r\n                            if (typeof path === \"string\") {\r\n                                model = converter(path);\r\n\r\n                                if (!model) {\r\n                                    model = {};\r\n                                }\r\n\r\n                                options.set(\r\n                                    arrayPath + separator + i + separator + arrayItemSuffix,\r\n                                    model,\r\n                                    { silent: true },\r\n                                );\r\n                            }\r\n                        }\r\n                    });\r\n                } else {\r\n                    path = options.get(prop);\r\n\r\n                    if (path) {\r\n                        if (path[\"_dashboardsType\"]) {\r\n                            path = path.value;\r\n                        }\r\n\r\n                        if (typeof path === \"string\") {\r\n                            model = converter(path);\r\n\r\n                            if (!model) {\r\n                                model = {};\r\n                            }\r\n\r\n                            //model.path = path;\r\n                            options.set(prop, model, { silent: true });\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Remove entry for current component in .settings\r\n         */\r\n        public destroySettings() {\r\n            let settings;\r\n\r\n            // return if not in quickView\r\n            if (!this.quickView) {\r\n                return;\r\n            }\r\n\r\n            settings = this.docViewModel.get(\".settings\");\r\n            if (!settings) {\r\n                return;\r\n            }\r\n            settings.unset(this.componentId);\r\n        }\r\n\r\n        /**\r\n         * Export the full dataset from a datasource, using DeltaClient ExportApi.export\r\n         * @param {Object} source\r\n         * @param {Object} callback - called with url to file\r\n         * @param {Object} options - e.g. can include focus for pivot queries\r\n         */\r\n        public exportData(source, callback, options) {\r\n            if (this.getSourceType(source) === \"data\") {\r\n                source.exportData(\r\n                    function(url) {\r\n                        if (\r\n                            (navigator.userAgent.toLowerCase().indexOf(\"firefox\") > -1 ||\r\n                                navigator.userAgent.toLowerCase().indexOf(\"safari\") > -1) &&\r\n                            navigator.userAgent.toLowerCase().indexOf(\"chrome\") === -1\r\n                        ) {\r\n                            const link = document.createElement(\"a\");\r\n                            link.setAttribute(\"href\", url);\r\n                            link.setAttribute(\"download\", \"\"); // avoid save prompts\r\n                            document.body.appendChild(link);\r\n                            link.click();\r\n                            document.body.removeChild(link);\r\n                        } else {\r\n                            // fallback to opening file in new window\r\n                            window.open(url, \"_blank\");\r\n                        }\r\n\r\n                        if (_.isFunction(callback)) {\r\n                            callback(url);\r\n                        }\r\n                    },\r\n                    function(data) {\r\n                        Log.Error(\"Export Data error\" + (data ? \": \" + data.toString() : \"\"));\r\n\r\n                        if (_.isFunction(callback)) {\r\n                            callback();\r\n                        }\r\n                    },\r\n                    options,\r\n                );\r\n            } else {\r\n                if (_.isFunction(callback)) {\r\n                    callback();\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Execute the actions provided by the actions editor from PropertiesPanel\r\n         * @param {Array} actions\r\n         */\r\n        public doActions(actions, propertyPath) {\r\n            const self = this,\r\n                navigationOptions = {\r\n                    dashboard: \"<none>\",\r\n                    screen: \"<none>\",\r\n                    target: \"\",\r\n                };\r\n\r\n            _.each(actions, function(action, i) {\r\n                if (!action[\"_Type\"]) {\r\n                    // a navigation action bound to a viewstate\r\n                    if (_.isObject(action)) {\r\n                        action[\"_Type\"] = \"nav\";\r\n                    } else {\r\n                        action = {\r\n                            _Type: \"nav\",\r\n                            Value: action,\r\n                        };\r\n                    }\r\n                }\r\n\r\n                const index = action[\"_PropertyIndex\"] || i;\r\n                const path = (propertyPath || \"Actions\") + \".\" + index;\r\n\r\n                switch (action[\"_Type\"]) {\r\n                    case \"map\":\r\n                        const current = self.getPropertyMeta(path + \".Current\");\r\n                        const target = self.getPropertyMeta(path + \".Target\");\r\n                        let valueToSet;\r\n\r\n                        if (!navigationOptions[\"viewstate\"]) {\r\n                            navigationOptions[\"viewstate\"] = {};\r\n                        }\r\n\r\n                        if (current) {\r\n                            valueToSet =\r\n                                current.type === \"viewstate\" ? current.value : action[\"Current\"];\r\n\r\n                            if (Tools.isKDBTemporal(valueToSet)) {\r\n                                valueToSet = Tools.convertKDBTemporalToMoment(\r\n                                    valueToSet,\r\n                                ).toDashString();\r\n                            }\r\n\r\n                            if (target && target.type === \"viewstate\" && target.path) {\r\n                                // setting a viewstate in the current dashboard\r\n                                self.setProperty(path + \".Target\", valueToSet);\r\n                            } else {\r\n                                // adding to outgoing viewstates to set in the target dashboard\r\n                                navigationOptions[\"viewstate\"][action[\"Target\"]] = valueToSet;\r\n                            }\r\n                        }\r\n\r\n                        break;\r\n                    case \"nav\":\r\n                        const navProperty = self.getPropertyMeta(path + \".SelectDashboardScreen\");\r\n\r\n                        // TODO NF - temporary workaround to get current view state value\r\n                        // until DocumentViewModel listens for dict child changes\r\n                        const navOptions =\r\n                            navProperty.type === \"viewstate\"\r\n                                ? navProperty.value\r\n                                : action[\"SelectDashboardScreen\"];\r\n\r\n                        if (_.isString(navOptions)) {\r\n                            // dashboard name\r\n                            navigationOptions[\"dashboard\"] = navOptions;\r\n                            navigationOptions[\"screen\"] = null;\r\n                        } else if (_.isObject(action)) {\r\n                            if (action[\"SelectDashboardScreen._dashboardsType\"]) {\r\n                                // nested nav object\r\n                                _.extend(navigationOptions, {\r\n                                    dashboard: action[\"SelectDashboardScreen.dashboard\"],\r\n                                    screen: action[\"SelectDashboardScreen.screen\"],\r\n                                });\r\n                            } else if (_.isObject(navOptions)) {\r\n                                _.extend(navigationOptions, navOptions);\r\n                            }\r\n                        }\r\n\r\n                        if (action[\"Target\"]) {\r\n                            navigationOptions.target = action[\"Target\"];\r\n                        }\r\n\r\n                        break;\r\n                    case \"query\":\r\n                        action[\"DataSource\"] &&\r\n                            action[\"DataSource\"].forceExecute(undefined, action[\"callback\"]);\r\n                        break;\r\n                    case \"url\":\r\n                        let url = action[\"Url\"];\r\n\r\n                        if (/\\S+/g.test(url)) {\r\n                            // add protocol if none is specified\r\n                            if (!/^https?:\\/\\//i.test(url)) {\r\n                                url = \"//\" + url;\r\n                            }\r\n\r\n                            window.open(url, (action[\"Target\"] || \"_blank\"));\r\n                        }\r\n                        break;\r\n                }\r\n            });\r\n\r\n            if (\r\n                !(navigationOptions.dashboard === \"<none>\" && navigationOptions.screen === \"<none>\")\r\n            ) {\r\n                self.navigate(navigationOptions);\r\n            }\r\n        }\r\n\r\n        public removeTooltip(): void {\r\n            this.unsubscribeTemplateViewStates(this.tooltipSubscriptionKey);\r\n            this.tooltipSubscriptionKey = \"\";\r\n            this.genericTooltip?.remove();\r\n            delete this.genericTooltip;\r\n        }\r\n\r\n        public setTooltip(props: QuickBase.TooltipOptions): QuickBase.GenericTooltip {\r\n            if (this.genericTooltip) {\r\n                this.genericTooltip.updateTooltip(props);\r\n            } else {\r\n                this.genericTooltip = new QuickBase.GenericTooltip(\r\n                    _.extend(props, {\r\n                        cssClass: this.appKey + \"-tooltip\",\r\n                    }),\r\n                );\r\n            }\r\n\r\n            this.unsubscribeTemplateViewStates(this.tooltipSubscriptionKey);\r\n            this.tooltipSubscriptionKey = this.subscribeTemplateViewStates(\r\n                this.genericTooltip.text,\r\n                viewStates => {\r\n                    this.genericTooltip.renderTemplate(viewStates);\r\n                },\r\n            );\r\n\r\n            return this.genericTooltip;\r\n        }\r\n\r\n        /**\r\n         * Extract view states from the the given template\r\n         * @param {String} template\r\n         * @returns {Array} viewstates\r\n         */\r\n        private extractTemplateViewStates(template) {\r\n            const vsRx = /\\$[^$]*\\$/gi;\r\n            const matches = template.match(vsRx);\r\n\r\n            return _.map(_.uniq(matches), (s: string) => {\r\n                const vs = this.docViewModel.getByPath(\r\n                    s.substring(1, s.length - 1).replace(/\\./g, \"/\"),\r\n                );\r\n\r\n                if (vs) {\r\n                    return vs.path;\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Returns the id for the given dashboard name\r\n         * @param {String} dashName\r\n         * @returns {guid} dash GUID\r\n         */\r\n        private getDashboardId(dashName) {\r\n            let self = this,\r\n                dash;\r\n\r\n            // find the dash if name is given, or default to current dash\r\n            if (dashName === \"<none>\") {\r\n                dash = null;\r\n            } else if (!dashName || dashName === \"<this>\") {\r\n                dash = this.dashboardAppModel\r\n                    .get(\"documents\")\r\n                    .get(this.dashboardViewModel.get(\"selectedDocumentId\"));\r\n            } else {\r\n                dash = this.dashboardAppModel.get(\"documents\").find(function(d) {\r\n                    return d.get(\"name\") === dashName;\r\n                });\r\n            }\r\n\r\n            return dash ? dash[\"id\"] : \"<none>\";\r\n        }\r\n\r\n        /**\r\n         * Returns the id for the given screen name\r\n         * @param {guid} dashId\r\n         * @param {String} screenName\r\n         * @returns {guid} screen GUID\r\n         */\r\n        private getScreenId(dashId, screenName) {\r\n            let screen, screenId;\r\n\r\n            const dash = this.dashboardAppModel.get(\"documents\").get(dashId);\r\n\r\n            if (dash) {\r\n                if (!screenName || screenName === \"<none>\") {\r\n                    // no screen given, use first\r\n                    screen = dash.get(\"screenDetails\")[0];\r\n\r\n                    if (screen) {\r\n                        screenId = screen.value;\r\n                    }\r\n                } else if (dash.has(\"screens\")) {\r\n                    // current dash (may not have been saved to screenDetails yet)\r\n                    const screenModel = dash.get(\"screens\").find((s: Screen) => {\r\n                        return s.get(\"name\") === screenName;\r\n                    });\r\n\r\n                    if (screenModel) {\r\n                        screenId = screenModel.id;\r\n                    }\r\n                } else {\r\n                    // other dashes\r\n                    screen = _.find(dash.get(\"screenDetails\"), (s: any) => {\r\n                        return s[\"label\"] === screenName;\r\n                    });\r\n\r\n                    if (screen) {\r\n                        screenId = screen.value;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return screenId || \"<none>\";\r\n        }\r\n\r\n        /**\r\n         * Returns the key for the given datasource, either path or id\r\n         * @param {Object} dataSource\r\n         * @returns {String} key\r\n         */\r\n        private getDataSourceKey(dataSource) {\r\n            if (!dataSource) {\r\n                return false;\r\n            }\r\n\r\n            return dataSource.path || dataSource.cid;\r\n        }\r\n\r\n        /**\r\n         * Convert a dictionary's children from viewstate models to their value\r\n         * Also listens for changes to these models and passes them to callback\r\n         * @param {Object} dict - object of keys with viewstate models as their values\r\n         * @param {ComponentApi~changesetCallback} callback\r\n         * @returns {Object} The value of the dictionary\r\n         */\r\n        private getDictValue(dict) {\r\n            const self = this,\r\n                returnObject = {};\r\n\r\n            if (dict.get(\"_type\") !== \"dict\" || typeof dict.get(\"value\") !== \"object\") {\r\n                return dict.get(\"value\");\r\n            }\r\n\r\n            _.each(dict.get(\"value\"), function(value, key) {\r\n                var path, value, viewstateModel;\r\n\r\n                if (value instanceof QuickBase.DocumentViewModel) {\r\n                    path = value.path;\r\n                } else if (value instanceof Backbone.Model) {\r\n                    returnObject[key] = value.get(\"value\");\r\n                } else if (_.isObject(value) && value[\"name\"]) {\r\n                    // value is a viewstate object, path is value['name']\r\n                    path = value[\"name\"];\r\n                } else if (_.isString(value) && value.match(DocumentDataModel.PARAMETER_RX)) {\r\n                    path = value.substring(2, value.length - 2);\r\n                }\r\n\r\n                if (path) {\r\n                    viewstateModel = self.docViewModel.getByPath(path);\r\n\r\n                    if (viewstateModel) {\r\n                        returnObject[key] = viewstateModel.get(\"value\");\r\n                    } else {\r\n                        returnObject[key] = value;\r\n                    }\r\n                } else {\r\n                    returnObject[key] = value;\r\n                }\r\n            });\r\n\r\n            return returnObject;\r\n        }\r\n\r\n        /**\r\n         * Recursive function to pick out properties with the given type\r\n         * @param {String} type - e.g. 'data' or 'viewstate'\r\n         * @param {Object} root - the object to search\r\n         * @param {String} path - the path to the root in the base object\r\n         * @param {Object} properties - array of keys for properties found so far\r\n         * @returns {Array} List of paths for properties with the given type\r\n         */\r\n        private getPropertiesByType(\r\n            type: string,\r\n            root: any,\r\n            definitions?: any,\r\n            path?: string,\r\n            properties?: any,\r\n        ) {\r\n            const self = this,\r\n                separator = Backbone.DeepModel.keyPathSeparator;\r\n\r\n            if (!path) {\r\n                path = \"\";\r\n            }\r\n\r\n            if (!definitions) {\r\n                definitions = {};\r\n            }\r\n\r\n            if (!properties) {\r\n                properties = [];\r\n            }\r\n\r\n            if (root) {\r\n                if (root.type === type) {\r\n                    // we have found a property matching the required type\r\n                    properties.push(path);\r\n                } else if (root && root.constructor === Object) {\r\n                    // check through each property of the object\r\n                    _.each(root, function(value, key) {\r\n                        if (key === \"$ref\") {\r\n                            // json editor reference - get value from definitions\r\n                            self.getPropertiesByType(\r\n                                type,\r\n                                definitions[value.replace(\"#/definitions/\", \"\")],\r\n                                definitions,\r\n                                path,\r\n                                properties,\r\n                            );\r\n                        } else {\r\n                            self.getPropertiesByType(\r\n                                type,\r\n                                value,\r\n                                definitions,\r\n                                (path ? path + separator : \"\") + key,\r\n                                properties,\r\n                            );\r\n                        }\r\n                    });\r\n                } else if (root && root.constructor === Array) {\r\n                    // check through each element of the array\r\n                    _.each(root, function(value, i) {\r\n                        self.getPropertiesByType(\r\n                            type,\r\n                            value,\r\n                            definitions,\r\n                            (path ? path + separator : \"\") + i,\r\n                            properties,\r\n                        );\r\n                    });\r\n                }\r\n            }\r\n\r\n            return _.uniq(properties);\r\n        }\r\n\r\n        /**\r\n         * Returns property value for a given path\r\n         * @param {String} path\r\n         * @returns {Object} Property value\r\n         */\r\n        public getProperty(path) {\r\n            let self = this,\r\n                property,\r\n                type,\r\n                value;\r\n\r\n            if (!path) return null;\r\n\r\n            property = this.settingsModel.get(path);\r\n            type = this.getSourceType(property);\r\n\r\n            switch (type) {\r\n                case \"data\":\r\n                    value = null;\r\n                    break;\r\n                case \"viewstate\":\r\n                    value = this.getPropertyValue(property);\r\n                    break;\r\n                default:\r\n                    value = property;\r\n            }\r\n\r\n            return value;\r\n        }\r\n\r\n        /**\r\n         * Returns property information for a given path\r\n         * @param {String} path\r\n         * @returns {Object} Property information\r\n         */\r\n        public getPropertyMeta(path) {\r\n            let self = this,\r\n                property,\r\n                type,\r\n                defaultValue,\r\n                viewstateType,\r\n                value;\r\n\r\n            if (!path) return null;\r\n\r\n            property = this.settingsModel.get(path);\r\n\r\n            // if undefined or null\r\n            if (property == undefined) return null;\r\n\r\n            type = this.getSourceType(property);\r\n\r\n            switch (type) {\r\n                case \"data\":\r\n                    value = null;\r\n                    break;\r\n                case \"viewstate\":\r\n                    value = this.getPropertyValue(property);\r\n                    defaultValue = property.get(\"_default\");\r\n                    viewstateType = property.get(\"_type\");\r\n                    break;\r\n                default:\r\n                    value = property;\r\n            }\r\n\r\n            return {\r\n                path: property.path || null,\r\n                type: type,\r\n                value: value,\r\n                viewstateType: viewstateType || null,\r\n                defaultValue: defaultValue || null,\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Return the actual value of a given property (i.e. extracting from model if necessary)\r\n         * If given property is a model, also listens for changes and calls callback\r\n         * @param {*} property - the property to process\r\n         * @returns {*} value\r\n         */\r\n        public getPropertyValue(property: any) {\r\n            if (this.getSourceType(property) === \"viewstate\") {\r\n                // If property is a dict we need to convert the child viewstate models to their values\r\n                return property.get(\"_type\") === \"dict\"\r\n                    ? this.getDictValue(property)\r\n                    : property.get(\"value\");\r\n            }\r\n\r\n            return property;\r\n        }\r\n\r\n        /**\r\n         * Determine the dashboard type of the source, 'data' or 'viewstate'\r\n         * @param {Object} model\r\n         * @returns {String} type\r\n         */\r\n        private getSourceType(source) {\r\n            if (!source) {\r\n                return null;\r\n            } else if (source instanceof DocumentViewModel) {\r\n                return \"viewstate\";\r\n            } else if (source.get && source.get(\"_viewType\")) {\r\n                return \"viewstate\";\r\n            } else if (source.has && source.has(\"_default\") && source.has(\"value\")) {\r\n                return \"viewstate\";\r\n            } else if (source instanceof DocumentDataModel) {\r\n                return \"data\";\r\n            } else if (source.subscribe && source.unsubscribe) {\r\n                return \"data\";\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Generate a subscription key for the given path\r\n         * @param {String} path\r\n         * @returns {String} key\r\n         */\r\n        private getSubscriptionKey(path) {\r\n            let key = this.appKey ? this.appKey + \" \" : \"\";\r\n            key += path || this.widgetId;\r\n            return _.uniqueId(key + \":\");\r\n        }\r\n\r\n        /**\r\n         * Extract view states from template and pass back their values\r\n         * @param {String} template\r\n\r\n         */\r\n        public getTemplateViewStates = function(template) {\r\n            return this.processTemplateViewStates(\r\n                this.getViewStates(this.extractTemplateViewStates(template)),\r\n            );\r\n        };\r\n\r\n        /**\r\n         * Get the value of a given viewstate model\r\n         * @param {Object} viewState - model\r\n         * @returns {String} The value of the model\r\n         */\r\n        // TODO NF - remove?\r\n        public getViewState(viewState) {\r\n            if (!viewState || !viewState.attributes) {\r\n                // Invalid viewstate\r\n                return false;\r\n            }\r\n\r\n            return viewState.get(\"value\");\r\n        }\r\n\r\n        /**\r\n         * Get the values of the given viewstates\r\n         * @param {Array} viewStates - paths to viewstates\r\n         * @returns {Object} The value of the model\r\n         */\r\n        public getViewStates(viewStates) {\r\n            return _.zipObject(\r\n                viewStates,\r\n                _.map(viewStates, v => {\r\n                    const model = this.docViewModel.getByPath(v);\r\n                    if (model) return model.get(\"value\");\r\n                }),\r\n            );\r\n        }\r\n\r\n        public hideErrorMessage() {\r\n            this.trigger(\"hideErrorMessage\");\r\n        }\r\n\r\n        public hideQueryStatus() {\r\n            this.trigger(\"hideQueryStatus\");\r\n        }\r\n\r\n        /**\r\n         * Determines if the dashboard is in build mode\r\n         * @returns {Boolean} True if in build mode\r\n         */\r\n        public isBuildMode() {\r\n            return this.dashboardViewModel.get(\"buildMode\") && !this.quickView;\r\n        }\r\n\r\n        /**\r\n         * Determines if the component is selected\r\n         * @returns {Boolean} True if the component is selected\r\n         */\r\n        public isSelected() {\r\n            const selectedWidget = this.dashboardViewModel.get(\"selectedWidget\");\r\n            if (selectedWidget) {\r\n                return selectedWidget.id === this.widgetId;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Load a given app using requireJS and pass it a new API interface\r\n         * @param {String} key\r\n         * @param {Object} element\r\n         * @param {Object} settings - either a Backbone model or an object containing the new app's settings\r\n         * @param {Object} options - an object of options to pass to the app initialize function\r\n         * @returns {Object} appView\r\n         */\r\n        public loadApp(key, element, settings, options, callback, namespace) {\r\n            if (!key || !element) {\r\n                return;\r\n            }\r\n\r\n            if (!namespace) {\r\n                namespace = key;\r\n            }\r\n\r\n            new AppView(\r\n                _.extend(\r\n                    {},\r\n                    {\r\n                        el: element,\r\n                        key: key,\r\n                        settings: settings,\r\n                        appOptions: options,\r\n                        callback: function(app) {\r\n                            if (_.isFunction(callback)) {\r\n                                callback(app);\r\n                            }\r\n                        },\r\n                        namespace: this.componentId + ComponentApi.NAMESPACE_SEPARATOR + namespace,\r\n                    },\r\n                    _.pick(this, AppView.COMMON_OPTIONS),\r\n                ),\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Load a setting from the .settings viewstate\r\n         * @param {String} key\r\n         * @returns {String} Value\r\n         */\r\n        public loadSetting(key, namespace) {\r\n            let componentKey, modelKey, settings;\r\n\r\n            // return if no key or not in quickView\r\n            if (!key || !this.quickView) {\r\n                return null;\r\n            }\r\n\r\n            settings = this.docViewModel.get(\".settings\");\r\n\r\n            componentKey = this.componentId;\r\n\r\n            if (namespace) {\r\n                componentKey += ComponentApi.NAMESPACE_SEPARATOR + namespace;\r\n            }\r\n\r\n            if (settings) {\r\n                const componentViewState = settings.get(componentKey);\r\n                if (componentViewState) {\r\n                    return componentViewState.get(key);\r\n                } else {\r\n                    return null;\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Navigate to a given dashboard/screen\r\n         * @param {String|Object} options - Either a dashboard name or an object containing target dashboard, screen and/or viewstate parameters to pass\r\n         * @returns {Number} Sum of a and b\r\n         */\r\n        public navigate(options) {\r\n            let dashboard = null,\r\n                dashboardModel = null,\r\n                dashboardId = null,\r\n                screen = null,\r\n                screenId = null,\r\n                viewStateParameters,\r\n                viewstateString = \"\";\r\n\r\n            // options can be:\r\n            // (1)\r\n            // 'My Dashboard'\r\n\r\n            // or\r\n\r\n            // (2)\r\n            // {\r\n            //    'dashboard': '#dashguid',\r\n            //    'screen': '#screenguid'\r\n            // }\r\n\r\n            // or\r\n\r\n            // (3)\r\n            // {\r\n            //   'dashboard': 'My Dashboard',\r\n            //   'screen':'My Screen'\r\n            // }\r\n\r\n            // (2) and (3) can be mixed, e.g. dashguid and screen name\r\n\r\n            // viewstate can also be added to (2) and (3)\r\n            // {\r\n            //   'viewstate': {\r\n            //     'selected': 'my new value'\r\n            //   }\r\n            // }\r\n\r\n            if (_.isString(options)) {\r\n                // simple dashboard name (1)\r\n                const dashboardName = options;\r\n                if (this.dashboardAppModel.get(\"documents\").get(dashboardName)) {\r\n                    dashboardId = dashboardName;\r\n                } else {\r\n                    dashboardId = this.getDashboardId(dashboardName);\r\n                }\r\n                screenId = \"<none>\";\r\n            } else if (_.isObject(options)) {\r\n                dashboard = options[\"dashboard\"];\r\n                screen = options[\"screen\"];\r\n                viewStateParameters = options[\"viewstate\"];\r\n\r\n                // backwards compatability\r\n                if (dashboard instanceof Backbone.Model) {\r\n                    dashboard = dashboard.get(\"value\");\r\n                } else if (_.isObject(dashboard) && dashboard.id) {\r\n                    dashboard = dashboard.id;\r\n                }\r\n\r\n                if (screen instanceof Backbone.Model) {\r\n                    screen = screen.get(\"value\");\r\n                } else if (_.isObject(screen) && screen.id) {\r\n                    screen = screen.id;\r\n                }\r\n\r\n                if (dashboard === \"<this>\") {\r\n                    dashboard = this.dashboardViewModel.get(\"selectedDocumentId\");\r\n                }\r\n\r\n                dashboardModel = this.dashboardAppModel.get(\"documents\").get(dashboard);\r\n\r\n                if (dashboardModel) {\r\n                    // use dashboard id if model exists (2)\r\n                    dashboardId = dashboard;\r\n                } else {\r\n                    // otherwise assume it's a dashboard name and try to find the id (3)\r\n                    dashboardId = this.getDashboardId(dashboard);\r\n                    dashboardModel = this.dashboardAppModel.get(\"documents\").get(dashboardId);\r\n                }\r\n\r\n                if (dashboardModel) {\r\n                    if (\r\n                        _.isEmpty(dashboardModel.get(\"screenDetails\")) &&\r\n                        Helpers.validateGuid(screen)\r\n                    ) {\r\n                        // screenDetails isn't populated so we can't check if screen exists\r\n                        // but screen looks like an id so pass it to the dashboard\r\n                        screenId = screen;\r\n                    } else if (\r\n                        _.find(dashboardModel.get(\"screenDetails\"), function(screenDetails) {\r\n                            return screenDetails.value === screen;\r\n                        })\r\n                    ) {\r\n                        // use screen id if it exists in dashboard (2)\r\n                        screenId = screen;\r\n                    } else {\r\n                        // otherwise assume it's a screen name and try to find the id (3)\r\n                        screenId = this.getScreenId(dashboardId, screen);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // convert viewstate parameters to a url query string\r\n            if (_.isObject(viewStateParameters) && !_.isEmpty(viewStateParameters)) {\r\n                viewstateString =\r\n                    \"?viewstate=\" + encodeURIComponent(JSON.stringify(viewStateParameters));\r\n            }\r\n\r\n            // call Backbone.router navigate\r\n            if (dashboardId && screenId && dashboardId !== \"<none>\") {\r\n                if (\r\n                    options.target === \"_blank\" ||\r\n                    (\"FSBL\" in window && dashboardId !== window[\"finApi\"][\"documentId\"])\r\n                ) {\r\n                    // open in new window with viewstate parameters in url\r\n                    let url = \"#\" + dashboardId;\r\n\r\n                    url += screenId ? \"/\" + screenId : \"\";\r\n                    url += viewstateString ? viewstateString : \"\";\r\n\r\n                    (window as Window).open(url);\r\n                } else {\r\n                    if (screenId === \"<none>\") {\r\n                        // dashboard only\r\n                        this.dashboardAppModel\r\n                            .get(\"router\")\r\n                            .navigate(dashboardId + viewstateString, { trigger: true });\r\n                    } else {\r\n                        // dashboard + screen\r\n                        this.dashboardAppModel\r\n                            .get(\"router\")\r\n                            .navigate(dashboardId + \"/\" + screenId + viewstateString, {\r\n                                trigger: true,\r\n                            });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Notify view state subscriber with current values\r\n         * @param {Object} source\r\n         */\r\n        private notifyViewStateSubscriber = function(subscriptionId) {\r\n            const callback = this.viewStateSubscriptions[subscriptionId];\r\n            const viewStates = this.subscriptionsToViewStates[subscriptionId];\r\n\r\n            _.isFunction(callback) && callback(this.getViewStates(viewStates));\r\n        };\r\n\r\n        /**\r\n         * Page a given data source\r\n         * @param {Object} source\r\n         */\r\n        public page(source, options) {\r\n            if (!_.isObject(options) || this.getSourceType(source) !== \"data\") {\r\n                return false;\r\n            }\r\n\r\n            options = _.pick(options, \"_pagingType\", \"_pagingNum\", \"_pageSize\", \"_pageSort\");\r\n\r\n            source.set(options);\r\n        }\r\n\r\n        /**\r\n         * Takes a nested object and returns a shallow object keyed with the path names,\r\n         * converting viewstates to their values and listening for their changes\r\n         * e.g. { \"level1.level2\": \"value\" }\r\n         *\r\n         * @param  {Object}      root - Nested object e.g. { level1: { level2: 'value' } }\r\n         * @param  {Function}    callback - the function to call if a viewstate changes (e.g. onSettingsChange)\r\n         * @param  {String}      path - used internally to recursively build the path for each property relative to the root\r\n         * @param  {String}      arrayPath - used internally to recursively build the path for properties relative to their parent array\r\n         * @param  {Object}      properties - used internally build the object that will be returned\r\n         * @return {Object}      Shallow object with path names e.g. { 'level1.level2': 'value' }\r\n         */\r\n        public processSettings(settings, changeCallback) {\r\n            let self = this,\r\n                processedSettings,\r\n                processPath,\r\n                separator = Backbone.DeepModel.keyPathSeparator;\r\n\r\n            processPath = function(root, path, arrayPath, properties) {\r\n                let nextArrayPath, nextPath, nextValue, propertyPath, propertyValue;\r\n\r\n                if (!path) {\r\n                    path = \"\";\r\n                }\r\n\r\n                if (!properties) {\r\n                    properties = {};\r\n                }\r\n\r\n                // path is the full path to the property in the model and will be used by the getPropertyValue callback\r\n                // propertyPath is the path that will be used when setting the value in the properties object\r\n                // propertyPath may be relative to the property's parent array, in which case arrayPath is used\r\n                propertyPath = !_.isUndefined(arrayPath) ? arrayPath : path;\r\n\r\n                // recursively process objects/array, passing their children back to processSettings\r\n                if (root && root.constructor === Object && !_.isEmpty(root)) {\r\n                    // process object children, appending their key to the current path\r\n                    _.each(root, function(value, key) {\r\n                        nextValue = value;\r\n                        nextPath = (path ? path + separator : \"\") + key;\r\n                        nextArrayPath = (arrayPath ? arrayPath + separator : \"\") + key;\r\n\r\n                        processPath(nextValue, nextPath, nextArrayPath, properties);\r\n                    });\r\n                } else if (root && root.constructor === Array && !_.isEmpty(root)) {\r\n                    if (_.keys(root).length < root.length) {\r\n                        // Backbone.DeepModel changedAttributes will return arrays with undefined children if only one item has changed\r\n                        // _.keys(root) will give us the index of the changed item and we can return it with a dot syntax path, ignoring the undefined children\r\n                        _.each(_.keys(root), function(key) {\r\n                            nextValue = root[key];\r\n                            nextPath = (path ? path + separator : \"\") + key;\r\n                            nextArrayPath = (arrayPath ? arrayPath + separator : \"\") + key;\r\n                            processPath(nextValue, nextPath, nextArrayPath, properties);\r\n                        });\r\n                    } else {\r\n                        // process array children, appending their index to the current path\r\n                        _.each(root, function(value, i) {\r\n                            if (!properties[propertyPath]) {\r\n                                properties[propertyPath] = [];\r\n                            }\r\n\r\n                            // set arrayPath to '' because we are setting these properties within the array rather than in the root properties object\r\n                            nextValue = value;\r\n                            nextPath = (path ? path + separator : \"\") + i;\r\n                            nextArrayPath = \"\";\r\n\r\n                            properties[propertyPath][i] = processPath(\r\n                                nextValue,\r\n                                nextPath,\r\n                                nextArrayPath,\r\n                                null,\r\n                            );\r\n                        });\r\n                    }\r\n                } else {\r\n                    if (self.getSourceType(root) === \"viewstate\") {\r\n                        // add to listeners\r\n                        if (!self.activeViewStateToPropertyPaths[root.path]) {\r\n                            self.activeViewStateToPropertyPaths[root.path] = [path];\r\n                            self.listenTo(root, \"change:value\", function(model, value) {\r\n                                const props = self.activeViewStateToPropertyPaths[model.path];\r\n\r\n                                if (model.get(\"_type\") === \"dict\") {\r\n                                    // value is a set of key/value pairs corresponding to the dictionary's properties\r\n                                    value = _.transform(value, (r, v, k) => {\r\n                                        // each pair may equal a view state, so we must extract its property value\r\n                                        r[k] = self.getPropertyValue(v);\r\n                                    });\r\n                                }\r\n\r\n                                const changeObj = _.zipObject(\r\n                                    props,\r\n                                    _.times(props.length, _.constant(value)),\r\n                                );\r\n                                changeCallback && changeCallback(changeObj);\r\n                            });\r\n                        } else if (\r\n                            self.activeViewStateToPropertyPaths[root.path].indexOf(path) === -1\r\n                        ) {\r\n                            self.activeViewStateToPropertyPaths[root.path].push(path);\r\n                        }\r\n\r\n                        // update property reference dictionary\r\n                        self.propertyPathsToViewStates[path] = root.path;\r\n                    }\r\n\r\n                    // get property value\r\n                    propertyValue = self.getPropertyValue(root);\r\n\r\n                    // set property value on return obj\r\n                    if (!_.isUndefined(propertyValue)) {\r\n                        if (!propertyPath) {\r\n                            // root is a simple value so we just convert it and pass it back\r\n                            return propertyValue;\r\n                        } else {\r\n                            properties[propertyPath] = propertyValue;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return properties;\r\n            };\r\n\r\n            // process settings\r\n            processedSettings = processPath(settings);\r\n\r\n            // stopListening and remove dereferenced view states\r\n            _.each(self.activeViewStateToPropertyPaths, function(value, key) {\r\n                // filter property paths to only those pointing to this view state\r\n                const activePaths = _.filter(value, function(p) {\r\n                    return (\r\n                        self.propertyPathsToViewStates[p] === key &&\r\n                        self.getSourceType(self.settingsModel.get(p)) === \"viewstate\"\r\n                    );\r\n                });\r\n\r\n                // if view state is referenced by >0 properties\r\n                if (activePaths.length > 0) {\r\n                    self.activeViewStateToPropertyPaths[key] = activePaths;\r\n                } else {\r\n                    // else remove viewstate and stop listening\r\n                    const vs = self.docViewModel.getByPath(key);\r\n                    self.stopListening(vs, \"change:value\");\r\n                    delete self.activeViewStateToPropertyPaths[key];\r\n                }\r\n            });\r\n\r\n            return processedSettings;\r\n        }\r\n\r\n        private processTemplateViewStates(viewStates) {\r\n            return _.mapKeys(viewStates, (v, k) => \"$\" + k.replace(/\\//g, \".\") + \"$\");\r\n        }\r\n\r\n        /**\r\n         * Save a setting to the .settings viewstate\r\n         * @param {String} key\r\n         * @param {String} value\r\n         */\r\n        public saveSetting(key, value, namespace) {\r\n            let componentKey, componentViewState, version, settings;\r\n\r\n            // return if no key or not in quickView\r\n            if (!key || !this.quickView) {\r\n                return;\r\n            }\r\n\r\n            componentKey = this.componentId;\r\n\r\n            if (namespace) {\r\n                componentKey += ComponentApi.NAMESPACE_SEPARATOR + namespace;\r\n            }\r\n\r\n            settings = this.docViewModel.get(\".settings\");\r\n            if (!settings) {\r\n                settings = new Backbone.Model();\r\n                this.docViewModel.set(\".settings\", settings);\r\n            }\r\n\r\n            componentViewState = settings.get(componentKey);\r\n\r\n            if (!componentViewState) {\r\n                // create new view state model for this component id\r\n                componentViewState = new Backbone.Model();\r\n                this.docViewModel.get(\".settings\").set(componentKey, componentViewState);\r\n                componentViewState.set(\"version\", 0);\r\n            }\r\n\r\n            // save settings for current component in the view state\r\n            componentViewState.set(key, value);\r\n\r\n            // make sure that debounced call doesn't change different dashboard\r\n            this.autosaveDashboardId = this.getDashboardId(null);\r\n            this.saveSettingsNowDebounced();\r\n        }\r\n\r\n        private saveSettingsNow() {\r\n            const dashboardId = this.getDashboardId(null);\r\n\r\n            // check due to debounced call\r\n            if (this.autosaveDashboardId === dashboardId) {\r\n                const currentSettings = this.docViewModel.get(\".settings\");\r\n\r\n                // fetch first, viewstates have to stay intact\r\n                new DocumentViewModel({ id: dashboardId }, null).fetch({\r\n                    success: function(mdl) {\r\n                        // overwrite just user settings, keep viewstates intact\r\n                        mdl.set(\".settings\", currentSettings);\r\n                        mdl.save(\r\n                            {},\r\n                            {\r\n                                error: function() {\r\n                                    Log.Error(\"Autosave user settings FAILED\", dashboardId);\r\n                                },\r\n                                success: function() {\r\n                                    Log.Info(\"Autosave user settings SUCCEEDED\", dashboardId);\r\n                                },\r\n                            },\r\n                        );\r\n                    }.bind(this),\r\n                    error: function(mdl, errorMessage) {\r\n                        if (\r\n                            this.dashboardAppModel.get(\"isLite\") &&\r\n                            errorMessage === \"Record Not Found\"\r\n                        ) {\r\n                            // necessary to create a record in local storage, then rerun autosave\r\n                            // calls to local storage are synchronous\r\n                            new DocumentViewModel({ id: dashboardId }, null).save(\r\n                                {},\r\n                                {\r\n                                    success: function() {\r\n                                        this.saveSettingsNow();\r\n                                    }.bind(this),\r\n                                },\r\n                            );\r\n                        } else {\r\n                            Log.Error(\"Unable to fetch user settings for Autosave\", dashboardId);\r\n                        }\r\n                    }.bind(this),\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Set the property at path to the given value\r\n         * @param {String} path\r\n         * @param {*} value\r\n         */\r\n        public setProperty(path: string, value: any, options?: any) {\r\n            let self = this,\r\n                single = true,\r\n                property;\r\n\r\n            // If property is a viewstate, set its value\r\n            // Otherwise, set the given value in the settings model\r\n\r\n            // TODO NF - should it set the value in .settings instead of modifying settings model?\r\n\r\n            if (!path) {\r\n                return;\r\n            }\r\n\r\n            property = this.settingsModel.get(path);\r\n\r\n            if (this.getSourceType(property) === \"viewstate\") {\r\n                property.setModelValue(value);\r\n            } else {\r\n                // TODO NF - allowing components to pass options (e.g. silent)\r\n                // is a temporary fix for ChartJS so it can set Layers on startup\r\n                // without triggering the unsaved changes icon\r\n                this.settingsModel.set(\r\n                    path,\r\n                    value,\r\n                    _.extend({}, options, {\r\n                        propertyPath: path,\r\n                    }),\r\n                );\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Set the value of the given viewstate model\r\n         * @param {Object} viewState - model\r\n         * @param {*} value\r\n         * @returns {Boolean} Sum of a and b\r\n         */\r\n        // TODO NF - remove?\r\n        public setViewState(viewState, value) {\r\n            if (!viewState || !viewState.attributes) {\r\n                // Invalid viewstate\r\n                return false;\r\n            }\r\n\r\n            return viewState.set(\"value\", value);\r\n        }\r\n\r\n        public showErrorMessage(errorObj) {\r\n            this.trigger(\"showErrorMessage\", errorObj);\r\n        }\r\n\r\n        public showNotification(visualConfig?: any, soundConfig?: any) {\r\n            NotificationManager.show(this.widgetId, visualConfig, soundConfig);\r\n        }\r\n\r\n        public showQueryStatus(errorObj) {\r\n            this.trigger(\"showQueryStatus\", errorObj);\r\n        }\r\n\r\n        /**\r\n         * Updates the table in kdb\r\n         * @param {String} source\r\n         * @param {Object} options\r\n         * @param {Function} successFunc - success callback\r\n         * @param {Function} errorFunc - error callback\r\n         * @returns undefined\r\n         */\r\n        public updateTable(source, options, successFunc, errorFunc) {\r\n            const successFn = function() {\r\n                successFunc();\r\n\r\n                // update subscriptions / force refresh\r\n                source.isDirty = true;\r\n                source.forceInternalReset = true;\r\n                source.execute();\r\n            };\r\n\r\n            if (this.getSourceType(source) === \"data\") {\r\n                options.query = source ? source.get(\"_updateQueryString\") : \"\";\r\n                options.connection = source ? source.get(\"_connection\") : \"\";\r\n                options.updateType = source ? source.get(\"_updateType\") : \"\";\r\n                options.updateAnalytic = source ? source.get(\"_updateAnalytic\") : \"\";\r\n\r\n                options.updateParams = source.bindViewStateToKdbParams(\r\n                    source.get(\"_updateQueryParams\"),\r\n                );\r\n\r\n                DeltaClientLib.updateTable(options, successFn, errorFunc);\r\n\r\n                //if (subscriptions[dataSourceKey]) {\r\n                //    // Already subscribed\r\n                //    subscriptions[dataSourceKey].callback = callback;\r\n                //    return false;\r\n                //}\r\n\r\n                //// New subscription\r\n                //subscriptions[dataSourceKey] = {\r\n                //    source: source,\r\n                //    onData: callback\r\n                //};\r\n\r\n                //subscriptions[dataSourceKey].key = (source.path)\r\n                //    //? options.self.widgetId + '_' + source.path : _.uniqueId(options.self.widgetId + '_');\r\n                //    ? options.model.id + '_' + source.path : _.uniqueId(options.self.widgetId + '_');\r\n\r\n                //source.subscribe(subscriptions[dataSourceKey].key, subscriptions[dataSourceKey]);\r\n            } else {\r\n                // do somreting\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Subscribe to a given source\r\n         * @param {Object} source\r\n         * @param {ComponentApi~sourceCallback} callback\r\n         */\r\n        public subscribe = function(source, callback, raw?: boolean, pagingInfo?: object) {\r\n            let dataSourceKey;\r\n\r\n            switch (this.getSourceType(source)) {\r\n                case \"data\":\r\n                    dataSourceKey = this.getDataSourceKey(source);\r\n\r\n                    if (this.subscriptions[dataSourceKey]) {\r\n                        // Already subscribed\r\n                        this.subscriptions[dataSourceKey].callback = callback;\r\n                        return false;\r\n                    }\r\n\r\n                    // New subscription\r\n                    this.subscriptions[dataSourceKey] = {\r\n                        key: this.getSubscriptionKey(source.path),\r\n                        source: source,\r\n                        onData: callback,\r\n                    };\r\n\r\n                    source.subscribe(\r\n                        this.subscriptions[dataSourceKey].key,\r\n                        this.subscriptions[dataSourceKey],\r\n                        raw,\r\n                        pagingInfo,\r\n                    );\r\n                    break;\r\n                default:\r\n                    Log.Warn(\"Source type not implemented\");\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Extract view states from template and pass their values to callback\r\n         * @param {String} template\r\n         * @param {ComponentApi~sourceCallback} callback\r\n         */\r\n        public subscribeTemplateViewStates = function(template, callback) {\r\n            return this.subscribeViewStates(\r\n                this.extractTemplateViewStates(template),\r\n                viewStates => {\r\n                    callback(this.processTemplateViewStates(viewStates));\r\n                },\r\n            );\r\n        };\r\n\r\n        /**\r\n         * Subscribe to view states and pass their values to callback\r\n         * @param {Array<string>} array\r\n         * @param {ComponentApi~sourceCallback} callback\r\n         */\r\n        private subscribeViewStates = function(viewStates: string[], callback: Function) {\r\n            const subscriptionId = _.uniqueId(\"vs_\");\r\n\r\n            this.viewStateSubscriptions[subscriptionId] = callback;\r\n            this.subscriptionsToViewStates[subscriptionId] = [];\r\n\r\n            // replace each viewstate name in the template with its value\r\n            _.each(viewStates, (vsPath: string) => {\r\n                const vs = this.docViewModel.getByPath(vsPath);\r\n\r\n                if (vs) {\r\n                    this.subscriptionsToViewStates[subscriptionId].push(vs.path);\r\n\r\n                    if (!this.activeViewStateToSubscriptions[vs.path]) {\r\n                        this.activeViewStateToSubscriptions[vs.path] = [subscriptionId];\r\n                        this.listenTo(vs, \"change:value\", function(model, value) {\r\n                            _.each(\r\n                                this.activeViewStateToSubscriptions[model.path],\r\n                                subscriptionId => {\r\n                                    this.notifyViewStateSubscriber(subscriptionId);\r\n                                },\r\n                            );\r\n                        });\r\n                    } else if (\r\n                        this.activeViewStateToSubscriptions[vs.path].indexOf(subscriptionId) === -1\r\n                    ) {\r\n                        this.activeViewStateToSubscriptions[vs.path].push(subscriptionId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            // pass initial value\r\n            this.notifyViewStateSubscriber(subscriptionId);\r\n\r\n            return subscriptionId;\r\n        };\r\n\r\n        /**\r\n         * Unsubscribe from a given source\r\n         * @param {Object} source\r\n         */\r\n        public unsubscribe = function(source) {\r\n            let dataSourceKey;\r\n\r\n            switch (this.getSourceType(source)) {\r\n                case \"data\":\r\n                    dataSourceKey = this.getDataSourceKey(source);\r\n\r\n                    if (this.subscriptions[dataSourceKey]) {\r\n                        // Unsubscribe\r\n                        source.unsubscribe(this.subscriptions[dataSourceKey].key);\r\n                        delete this.subscriptions[dataSourceKey];\r\n                    }\r\n                    break;\r\n                case \"viewstate\":\r\n                    this.stopListening(source, \"change:value\");\r\n                    break;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Unsubscribe from all subscribed sources\r\n         */\r\n        public unsubscribeAll = function() {\r\n            const self = this;\r\n\r\n            _.each(this.subscriptions, function(subscription, dataSourceKey) {\r\n                subscription.source.unsubscribe(subscription.key);\r\n                delete self.subscriptions[dataSourceKey];\r\n            });\r\n\r\n            _.defer(function() {\r\n                _.each(self.activeViewStateToPropertyPaths, function(value, key) {\r\n                    const vs = self.docViewModel.getByPath(key);\r\n                    self.stopListening(vs, \"change:value\");\r\n                    delete self.activeViewStateToPropertyPaths[key];\r\n                });\r\n\r\n                _.each(self.activeViewStateToSubscriptions, function(value, key) {\r\n                    const vs = self.docViewModel.getByPath(key);\r\n                    self.stopListening(vs, \"change:value\");\r\n                    delete self.activeViewStateToSubscriptions[key];\r\n                });\r\n            });\r\n        };\r\n\r\n        /**\r\n         * Unsubscribe for a given subscriptionId\r\n         * @param {Object} source\r\n         */\r\n        private unsubscribeViewStates = function(subscriptionId) {\r\n            if (this.viewStateSubscriptions[subscriptionId]) {\r\n                _.each(this.subscriptionsToViewStates[subscriptionId], vs => {\r\n                    this.activeViewStateToSubscriptions[vs] = _.without(\r\n                        this.activeViewStateToSubscriptions[vs],\r\n                        subscriptionId,\r\n                    );\r\n\r\n                    if (\r\n                        _.isEmpty(this.activeViewStateToSubscriptions[vs]) &&\r\n                        _.isEmpty(this.activeViewStateToPropertyPaths[vs])\r\n                    ) {\r\n                        const model = this.docViewModel.getByPath(vs);\r\n                        this.stopListening(model, \"change:value\");\r\n                        delete this.activeViewStateToSubscriptions[vs];\r\n                    }\r\n                });\r\n\r\n                delete this.subscriptionsToViewStates[subscriptionId];\r\n                delete this.viewStateSubscriptions[subscriptionId];\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Unsubscribe for a given subscriptionId\r\n         * @param {Object} source\r\n         */\r\n        public unsubscribeTemplateViewStates = function(subscriptionId) {\r\n            this.unsubscribeViewStates(subscriptionId);\r\n        };\r\n\r\n        /**\r\n         * Callback that passes a changeList back to a component\r\n         * @callback ComponentApi~changesetCallback\r\n         * @param {Object} changeSet - a key/value list of changed properties\r\n         */\r\n\r\n        /**\r\n         * Callback that passes a source's output to a component\r\n         * @callback ComponentApi~sourceCallback\r\n         * @param {Object} output - the source output\r\n         */\r\n    }\r\n}\r\n","/*global $,_,Backbone,console,require,T,DocumentDataModel*/\r\n/// <reference path=\"../lib/backbone-deep-model.ts\" />\r\n/// <reference path=\"../classes/commonDefinitions.ts\" />\r\n/// <reference path=\"../templates/combined.ts\" />\r\n/// <reference path=\"../models/component.ts\" />\r\n/// <reference path=\"../classes/ComponentApi.ts\"/>\r\n/// <reference path=\"../classes/log.ts\"/>\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-namespace\r\nnamespace QuickBase {\r\n    export class AppView extends Backbone.View<Backbone.Model> {\r\n        static COMMON_OPTIONS = [\r\n            \"callback\",\r\n            \"dashboardAppModel\",\r\n            \"dashboardViewModel\",\r\n            \"deltaClient\",\r\n            \"docDataModel\",\r\n            \"docViewModel\",\r\n            \"widgetId\",\r\n            \"quickView\",\r\n        ];\r\n\r\n        // common options\r\n        callback: Function;\r\n        dashboardAppModel: Backbone.Model;\r\n        dashboardViewModel: Backbone.Model;\r\n        deltaClient: any;\r\n        docDataModel: DocumentDataModel;\r\n        docViewModel: DocumentViewModel;\r\n        widgetId: string;\r\n\r\n        $appDiv = null;\r\n        app = null;\r\n        appOnSettingsChange = null;\r\n\r\n        componentApi: ComponentApi;\r\n        settingsModel: Backbone.DeepModel;\r\n        key: string;\r\n        appOptions: any;\r\n        componentId: string;\r\n        quickView: boolean;\r\n\r\n        constructor(options) {\r\n            super(options);\r\n\r\n            if (!options.el) {\r\n                this.el.classList.add(\"component-build-view\");\r\n            }\r\n\r\n            _.extend(this, _.pick(options, AppView.COMMON_OPTIONS));\r\n\r\n            if (options.key) {\r\n                // called by ComponentApi.loadApp - use key and settings as given\r\n                this.componentId = options.namespace || _.uniqueId(\"component_\");\r\n                this.appOptions = options.appOptions;\r\n                this.key = options.key;\r\n                this.settingsModel =\r\n                    options.settings instanceof Backbone.Model\r\n                        ? options.settings\r\n                        : new ComponentOptions(options.settings, {}, null);\r\n            } else {\r\n                // otherwise assume called by QuickDash/Panel and this.model represents a component\r\n                this.componentId = this.model.id;\r\n                this.key = this.model.get(\"key\");\r\n                this.settingsModel = this.model.get(\"options\");\r\n            }\r\n\r\n            this.initializeApi();\r\n            this.render();\r\n            this.requireApp();\r\n        }\r\n\r\n        initializeApi() {\r\n            // define api\r\n            this.componentApi = new ComponentApi(\r\n                _.extend({}, _.pick(this, AppView.COMMON_OPTIONS), {\r\n                    advancedMethods: true,\r\n                    appKey: this.key,\r\n                    componentId: this.componentId,\r\n                    deltaClient: this.deltaClient ? this.deltaClient.deltaClient : null,\r\n                    deltaClientLib: this.deltaClient,\r\n                    settingsModel: this.settingsModel,\r\n                }),\r\n            );\r\n        }\r\n\r\n        initalizeEvents() {\r\n            if (this.settingsModel) {\r\n                this.listenTo(this.settingsModel, \"change\", this.onSettingsModelChange);\r\n            }\r\n        }\r\n\r\n        initializeOnSettingsChange() {\r\n            let hasOnSettingsChange = false;\r\n\r\n            if (this.app && _.isFunction(this.app.onSettingsChange)) {\r\n                this.appOnSettingsChange = _.bind(this.app.onSettingsChange, this.app);\r\n            }\r\n\r\n            if (this.appOnSettingsChange && _.isFunction(this.settingsModel.toFlat)) {\r\n                // set component initial state\r\n                this.appOnSettingsChange(\r\n                    this.componentApi.processSettings(\r\n                        this.settingsModel.toFlat(),\r\n                        this.appOnSettingsChange,\r\n                    ),\r\n                );\r\n\r\n                // Set flag if component implements onSettingsChange (used by PropertiesPanel)\r\n                if (this.key === \"BasicComponents\") {\r\n                    // temporary extra check until all BasicComponents implement onSettingsChange\r\n                    if (_.isFunction(this.app.$view.onSettingsChange)) {\r\n                        hasOnSettingsChange = true;\r\n                    }\r\n                } else {\r\n                    hasOnSettingsChange = true;\r\n                }\r\n            }\r\n\r\n            if (this.model) {\r\n                if (hasOnSettingsChange) {\r\n                    this.model.set(\"hasOnSettingsChange\", true, { silent: true });\r\n                } else {\r\n                    this.model.unset(\"hasOnSettingsChange\");\r\n                }\r\n            }\r\n        }\r\n\r\n        onSettingsModelChange(model, options) {\r\n            try {\r\n                let changedAttributes, processedAttributes;\r\n\r\n                // options.propertyPath implies that we are setting a single property using a dot syntax path,\r\n                // in that case we pass the path to changedAttributes so it can return the same, flattening arrays as necessary (e.g. Layers.0.Visible: true)\r\n                changedAttributes = model.changedAttributes(\r\n                    null,\r\n                    options && options.propertyPath ? options.propertyPath : null,\r\n                );\r\n\r\n                // DeepModel changedAttributes can return empty objects for properties that didn't actually change\r\n                // we remove them here\r\n                _.each(changedAttributes, function(v, k) {\r\n                    let after, before;\r\n\r\n                    function accessor(item, key) {\r\n                        let itemKey,\r\n                            re = /^(\\w+)((?:\\.\\w+)+)$/.exec(key);\r\n\r\n                        if (re) {\r\n                            // arrays need numeric index\r\n                            itemKey = _.isArray(item) ? Number(re[1]) : re[1];\r\n                            return _.isObject(item)\r\n                                ? accessor(item[itemKey], re[2].substring(1))\r\n                                : item;\r\n                        } else {\r\n                            return _.isObject(item) ? item[key] : item;\r\n                        }\r\n                    }\r\n\r\n                    after = accessor(model.attributes, k);\r\n                    before = accessor(model.previousAttributes(), k);\r\n\r\n                    if (_.isEqual(before, after)) {\r\n                        delete changedAttributes[k];\r\n                    }\r\n                });\r\n\r\n                processedAttributes = this.componentApi.processSettings(\r\n                    changedAttributes,\r\n                    this.appOnSettingsChange,\r\n                );\r\n\r\n                if (this.appOnSettingsChange && !_.isEmpty(processedAttributes)) {\r\n                    this.appOnSettingsChange(processedAttributes);\r\n                }\r\n            } catch (e) {\r\n                Log.Error(\"AppView Settings Error\", e, this);\r\n            }\r\n        }\r\n\r\n        onResize(resizePanels?) {\r\n            if (this.app && this.app.onResize) {\r\n                this.app.onResize(resizePanels);\r\n            }\r\n        }\r\n\r\n        onResizeStart(resizePanels) {\r\n            if (this.app && this.app.onResizeStart) {\r\n                this.app.onResizeStart(resizePanels);\r\n            }\r\n        }\r\n\r\n        onResizeStop(resizePanels) {\r\n            if (this.app && this.app.onResizeStop) {\r\n                this.app.onResizeStop(resizePanels);\r\n            }\r\n        }\r\n\r\n        remove() {\r\n            if (this.app && _.isFunction(this.app.remove)) {\r\n                this.app.remove();\r\n            }\r\n\r\n            if (this.componentApi) {\r\n                // remove tooltip\r\n                this.componentApi.removeTooltip();\r\n                // Unsubscribe from all data sources and view states\r\n                this.componentApi.unsubscribeAll();\r\n            }\r\n\r\n            return Backbone.View.prototype.remove.apply(this);\r\n        }\r\n\r\n        render() {\r\n            this.$appDiv = this.$el;\r\n            return this;\r\n        }\r\n\r\n        requireApp() {\r\n            const self = this;\r\n\r\n            requirejs(\r\n                [self.key],\r\n                function(AppModule) {\r\n                    try {\r\n                        self.initializeApi();\r\n\r\n                        self.app = new AppModule(\r\n                            _.extend(\r\n                                {\r\n                                    el: self.$appDiv,\r\n                                    viewModel: self.docViewModel,\r\n                                    dataModel: self.docDataModel,\r\n                                    dashboardAppModel: self.dashboardAppModel,\r\n                                    dashboardViewModel: self.dashboardViewModel,\r\n                                    settingsModel: self.settingsModel,\r\n                                    websiteUrl: self.dashboardAppModel.get(\"websiteUrl\"),\r\n                                    DeltaClientLib: self.deltaClient,\r\n                                    api: self.componentApi.interface,\r\n                                    widgetId: self.widgetId,\r\n                                },\r\n                                self.appOptions,\r\n                            ),\r\n                        );\r\n\r\n                        self.initalizeEvents();\r\n                        self.initializeOnSettingsChange();\r\n\r\n                        if (_.isFunction(self.callback)) {\r\n                            self.callback(self.app);\r\n                        }\r\n                    } catch (error) {\r\n                        Log.Error(\"loading app error, require key: \" + self.key, error);\r\n                        if (_.isFunction(self.callback)) {\r\n                            self.callback(error);\r\n                        }\r\n                    }\r\n                },\r\n                function(err) {\r\n                    Log.Error(\"ComponentView:loadApp require error\", err);\r\n                    if (_.isFunction(self.callback)) {\r\n                        self.callback(err);\r\n                    }\r\n                },\r\n            );\r\n        }\r\n    }\r\n}\r\n","/*global $, Backbone*/\n/// <reference path=\"../templates/combined.ts\" />\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export interface DialogBaseOptions extends Backbone.ViewOptions<Backbone.Model> {\n        container?: HTMLElement;\n        callback?: (\n            o?: any,\n            success?: () => void,\n            error?: (model: Backbone.Model, msg: string) => void,\n        ) => void;\n        cancelBtnCallback?: (o?: any) => void;\n        dialogTitle: string;\n        iconClass: string;\n        minHeight?: number;\n        userClass?: string;\n        renderTemplate?: any;\n        requireSuccess?: boolean;\n        width?: number;\n        height?: number;\n        onClose?: () => void;\n        onOpen?: () => void;\n    }\n\n    export class DialogBase extends Backbone.View<Backbone.Model> {\n        protected $dialog: JQuery;\n        protected isCancel = false;\n        $dialogTitlebar: JQuery;\n        $dialogButtonpane: JQuery;\n        $dialogRoot: JQuery;\n\n        protected options: DialogBaseOptions;\n        private resizeListener;\n\n        constructor(options: DialogBaseOptions) {\n            super(options);\n            this.options = options;\n            this.preRender();\n            this.render();\n            this.postRender();\n\n            // attach resize listener\n            this.resizeListener = this.onResize.bind(this);\n            $(window).on(\"resize\", this.resizeListener);\n        }\n\n        public dialogClass() {\n            return \"dialog-base \" + (this.options.userClass || \"\");\n        }\n\n        public dialogButtons() {\n            return [\n                {\n                    text: \"Cancel\",\n                    click: () => this.dialogClose(),\n                    icons: {\n                        primary: \"fa fa-times\",\n                    },\n                },\n            ];\n        }\n\n        public dialogClose() {\n            const close = () => {\n                if (this.$dialog) {\n                    this.$dialog.dialog(\"close\");\n                }\n            };\n\n            if (this.isCancel) {\n                if (this.options.cancelBtnCallback) {\n                    this.options.cancelBtnCallback();\n                }\n\n                close();\n            } else {\n                if (this.options.requireSuccess) {\n                    if (this.options.callback) {\n                        this.options.callback(this.model, close, (model, errorMsg) => {\n                            ErrorDialog.ShowError(errorMsg || \"Unspecified Error\");\n                        });\n                    }\n                } else {\n                    if (this.options.callback) {\n                        this.options.callback(this.model);\n                    }\n\n                    close();\n                }\n            }\n        }\n\n        dialogOpen() {}\n\n        onResize() {\n            let appH = $(window).height(),\n                maxHeight;\n\n            // posision dialog in middle center of the app div\n            this.$dialogRoot.position({\n                of: $(window),\n            });\n\n            // resize the content div\n            maxHeight =\n                appH * 0.95 -\n                (this.$dialogTitlebar.outerHeight(true) + this.$dialogButtonpane.outerHeight(true));\n\n            this.$dialog.css(\"max-height\", maxHeight);\n        }\n\n        preRender() {}\n\n        postRender() {}\n\n        remove() {\n            if (this.$dialog) {\n                this.$dialog.dialog(\"destroy\");\n            }\n\n            this.options = null;\n            this.$dialog = null;\n            this.$dialogTitlebar = null;\n            this.$dialogButtonpane = null;\n            this.$dialogRoot = null;\n\n            // remove resize listener\n            $(window).off(\"resize\", this.resizeListener);\n\n            // remove from DOM\n            return Backbone.View.prototype.remove.apply(this);\n        }\n\n        openDialog() {\n            this.$el.dialog(\"open\");\n        }\n\n        render() {\n            const dialogOptions = {};\n\n            if (this.options.container) {\n                dialogOptions[\"appendTo\"] = this.options.container;\n            }\n\n            this.preRender();\n            this.$el.html(\n                this.options.renderTemplate ? this.options.renderTemplate() : this.renderTemplate(),\n            );\n\n            this.$dialog = this.$el.dialog(\n                _.extend(\n                    {\n                        dialogClass: this.dialogClass(),\n                        title: this.options.dialogTitle,\n                        resizable: false,\n                        minHeight: this.options.minHeight || 300,\n                        //'maxWidth': this.maxWidth,\n                        width: this.options.width || \"57em\",\n                        height: this.options.height || \"auto\",\n                        modal: true,\n                        autoOpen: true,\n                        draggable: false,\n                        closeOnEscape: true,\n                        buttons: this.dialogButtons(),\n                        position: { my: \"center\", at: \"center\", of: $(window) },\n                        open: () => {\n                            this.$el\n                                .parent()\n                                .find(\".titleIcon\")\n                                .remove();\n                            // add a dialog icon\n                            $(\n                                '<i class=\"titleIcon fa ' + this.options.iconClass + '\" />',\n                            ).insertBefore(this.$el.parent().find(\".ui-dialog-title\"));\n\n                            this.$dialogRoot = $(\".ui-dialog.dialog-base\");\n                            //this.$dialogRoot.css(\"max-height\", \"95%\");\n                            this.$dialogTitlebar = this.$dialogRoot.find(\".ui-dialog-titlebar\");\n                            this.$dialogButtonpane = this.$dialogRoot.find(\".ui-dialog-buttonpane\");\n\n                            this.dialogOpen();\n                            //this.onResize();\n\n                            // focus on first button\n                            // .ui-dialog-buttonpane > div > button:nth-child(1)\n                            this.$dialogButtonpane\n                                .find(\".ui-dialog-buttonpane > div > button:nth-child(1)\")\n                                .focus();\n\n                            if (this.options.onOpen) {\n                                this.options.onOpen();\n                            }\n                        },\n                        close: () => {\n                            this.trigger(\"closing\");\n\n                            if (this.options.onClose) {\n                                this.options.onClose();\n                            }\n\n                            this.remove();\n                        },\n                        resize: $.proxy(this.onResize, this),\n                    },\n                    dialogOptions,\n                ),\n            );\n\n            return this;\n        }\n\n        renderTemplate() {\n            return \"\";\n        }\n    }\n}\n","/*global $, T, Backbone, FormSchemas, BBForm, DialogBase*/\r\n/// <reference path=\"../templates/combined.ts\" />\r\n/// <reference path=\"DialogBase.ts\" />\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    interface AreYouSureDialogOptions extends DialogBaseOptions {\r\n        noSaveCb: Function;\r\n        saveCb: Function;\r\n        components?: Array<any>;\r\n        message: string;\r\n        dashChanged: boolean;\r\n    }\r\n\r\n    export class AreYouSureDialog extends DialogBase {\r\n        $errorInfo: JQuery;\r\n        $errorList: JQuery;\r\n        $firstBtn: JQuery;\r\n        closeArgs: any;\r\n\r\n        protected options: AreYouSureDialogOptions;\r\n\r\n        constructor(options) {\r\n            super(\r\n                _.extend(\r\n                    {\r\n                        iconClass: \"fa-asterisk\",\r\n                        dialogTitle: \"Save Changes\",\r\n                        minHeight: 110,\r\n                        width: 300,\r\n                    },\r\n                    options,\r\n                    {\r\n                        userClass:\r\n                            \"areyousure-dialog\" +\r\n                            (options.userClass ? \" \" + options.userClass : \"\"),\r\n                    },\r\n                ),\r\n            );\r\n        }\r\n\r\n        dialogButtons() {\r\n            return [\r\n                {\r\n                    text: \"Save\",\r\n                    click: _.bind(this.onClickSave, this),\r\n                    icons: {\r\n                        primary: \"fa fa-floppy-o\",\r\n                    },\r\n                },\r\n                {\r\n                    text: \"Don't Save\",\r\n                    click: _.bind(this.onClickDontSave, this),\r\n                    icons: {\r\n                        primary: \"fa fa-ban\",\r\n                    },\r\n                },\r\n                {\r\n                    text: \"Cancel\",\r\n                    click: _.bind(this.onClickCancel, this),\r\n                    icons: {\r\n                        primary: \"fa fa-times\",\r\n                    },\r\n                },\r\n            ];\r\n        }\r\n\r\n        doSave() {\r\n            const deferred = $.Deferred();\r\n\r\n            // TODO: gk don't like this here\r\n            (this.model as any).saveNow(deferred.reject, deferred.resolve);\r\n\r\n            return deferred.promise();\r\n        }\r\n\r\n        onKeyDown(e) {\r\n            e.stopPropagation();\r\n\r\n            switch (e[\"keyCode\"]) {\r\n                case $.ui.keyCode.ESCAPE:\r\n                    this.onClickCancel();\r\n                    break;\r\n                case 78: // n\r\n                    this.onClickDontSave();\r\n                    break;\r\n                case 83: // s\r\n                case 89: // y\r\n                    this.onClickSave();\r\n                    break;\r\n            }\r\n        }\r\n\r\n        onClickCancel() {\r\n            // don't leave this dashboard\r\n            this.isCancel = true;\r\n            this.closeArgs = \"cancel\";\r\n            this.dialogClose();\r\n        }\r\n\r\n        onClickDontSave() {\r\n            if (this.options && this.options.noSaveCb) {\r\n                this.options.noSaveCb();\r\n            }\r\n            this.dialogClose();\r\n        }\r\n\r\n        onClickSave() {\r\n            // Use callback if present else use promiss based doSave()\r\n            if (this.options && this.options.saveCb) {\r\n                this.options.saveCb();\r\n\r\n                this.dialogClose();\r\n            } else {\r\n                // block ui\r\n                this.$firstBtn.button(\"disable\");\r\n                this.$firstBtn.next().button(\"disable\");\r\n                this.$firstBtn\r\n                    .next()\r\n                    .next()\r\n                    .button(\"disable\");\r\n                this.doSave()\r\n                    .done(_.bind(this.onSaveDone, this))\r\n                    .fail(_.bind(this.onSaveFail, this));\r\n            }\r\n        }\r\n\r\n        onSaveDone() {\r\n            const errors = [];\r\n\r\n            if (_.isEmpty(this.options.components)) {\r\n                // close\r\n                this.dialogClose();\r\n            } else {\r\n                // navigate to the dash only after each widget has completed its callback\r\n                const afterSave = _.after(this.options.components.length, () => {\r\n                    if (_.isEmpty(errors)) {\r\n                        this.dialogClose();\r\n                    } else {\r\n                        // show errors\r\n                        this.$errorInfo.show();\r\n                        this.$errorList.empty();\r\n\r\n                        _.each(errors, error => {\r\n                            const $li = $(\"<li />\"),\r\n                                $span = $(\"<span />\");\r\n\r\n                            $span.attr(\"title\", error.widget);\r\n                            $span.text(error.component);\r\n                            $li.text(\": \" + error.message);\r\n\r\n                            $li.prepend($span);\r\n                            this.$errorList.append($li);\r\n                        });\r\n\r\n                        // unlock ui\r\n                        this.$firstBtn.button(\"enable\");\r\n                        this.$firstBtn.next().button(\"enable\");\r\n                        this.$firstBtn\r\n                            .next()\r\n                            .next()\r\n                            .button(\"enable\");\r\n                    }\r\n                });\r\n\r\n                _.each(this.options.components, callbackInfo => {\r\n                    if (_.isFunction(callbackInfo.callback)) {\r\n                        callbackInfo.callback(error => {\r\n                            if (error) {\r\n                                errors.push(\r\n                                    _.extend(\r\n                                        {\r\n                                            message: error,\r\n                                        },\r\n                                        _.pick(callbackInfo, [\"component\", \"widget\"]),\r\n                                    ),\r\n                                );\r\n                            }\r\n\r\n                            afterSave();\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        onSaveFail() {\r\n            // show error\r\n            this.$errorInfo.show();\r\n            // unlock ui\r\n            this.$firstBtn.button(\"enable\");\r\n            this.$firstBtn.next().button(\"enable\");\r\n            this.$firstBtn\r\n                .next()\r\n                .next()\r\n                .button(\"enable\");\r\n        }\r\n\r\n        getPromptMessage() {\r\n            const message = this.options.message || \"There are unsaved changes in this dashboard.\";\r\n            return message;\r\n        }\r\n\r\n        postRender() {\r\n            $(window).on(\"keydown.AreYouSureDialog\", _.bind(this.onKeyDown, this));\r\n            // Error info elements\r\n            this.$errorInfo = this.$(\".error-info\");\r\n            this.$errorList = this.$(\".error-list\");\r\n            this.$firstBtn = this.$dialog\r\n                .next()\r\n                .find(\"button\")\r\n                .first();\r\n            this.$errorInfo.hide();\r\n        }\r\n\r\n        renderTemplate() {\r\n            return T.AreYouSureDialog({\r\n                dashChanged: this.options.dashChanged, // if changed display changes\r\n                components: this.options.components, //each component that changed\r\n                message: this.getPromptMessage(),\r\n            });\r\n        }\r\n\r\n        remove() {\r\n            $(window).off(\".AreYouSureDialog\");\r\n            this.trigger(\"close\", this.closeArgs);\r\n            return DialogBase.prototype.remove.apply(this);\r\n        }\r\n    }\r\n}\r\n","/*globals Backbone, _, $, console*/\r\n/// <reference path=\"../templates/combined.ts\" />\r\n/// <reference path=\"../lib/delta-client-lib.ts\" />\r\n/// <reference path=\"../classes/log.ts\"/>\r\n/// <reference path=\"../lib/i18n.d.ts\" />\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class ChangePasswordDialog extends Backbone.View<Backbone.Model> {\r\n        MESSAGE_TYPES = [\"error\", \"success\", \"warning\"];\r\n\r\n        $dialog: JQuery;\r\n        $messageBox: JQuery;\r\n        $okBtn: JQuery;\r\n\r\n        clicked = false;\r\n        form: any;\r\n\r\n        boundToggleCaps;\r\n\r\n        onChangeSuccess: () => void;\r\n\r\n        constructor(options) {\r\n            super(options);\r\n            const username = null;\r\n\r\n            const User = Backbone.Model.extend({\r\n                schema: {\r\n                    username: {\r\n                        title: t(\"Username\"),\r\n                    },\r\n                    oldpassword: {\r\n                        title: t(\"Current Password\"),\r\n                        type: \"Password\",\r\n                        validators: [\"required\"],\r\n                    },\r\n                    password1: {\r\n                        title: t(\"New Password\"),\r\n                        type: \"Password\",\r\n                        validators: [\"required\"],\r\n                    },\r\n                    password2: {\r\n                        title: t(\"Re-Enter\"),\r\n                        type: \"Password\",\r\n                        validators: [\r\n                            { type: \"match\", field: \"password1\", message: \"Passwords must match!\" },\r\n                            \"required\",\r\n                        ],\r\n                    },\r\n                },\r\n            });\r\n\r\n            this.boundToggleCaps = this.toggleCapsLockMsg.bind(this);\r\n\r\n            this.model = new User({\r\n                username: username || undefined,\r\n            });\r\n\r\n            if (!username) {\r\n                delete (this.model as any).schema.username;\r\n            }\r\n\r\n            this.form = new Backbone[\"Form\"]({\r\n                model: this.model,\r\n            }).render();\r\n\r\n            this.$el.append(this.form.el);\r\n            this.$el.append('<div class=\"message-box\">');\r\n\r\n            // handle form submit\r\n            $(this.form.el).submit($.proxy(this.onSubmit, this));\r\n\r\n            this.$messageBox = this.$el.find(\".message-box\");\r\n\r\n            if (options.message) {\r\n                this.showMessage(options.message);\r\n            } else {\r\n                this.showMessage();\r\n            }\r\n\r\n            this.onChangeSuccess = options.onChangeSuccess;\r\n\r\n            this.$dialog = this.$el[\"dialog\"](\r\n                _.extend(\r\n                    {\r\n                        appendTo: options.container,\r\n                        dialogClass: \"quick-base change-password-dialog\",\r\n                        title: t(\"Change Password\"),\r\n                        resizable: false,\r\n                        height: 262,\r\n                        width: 320,\r\n                        modal: true,\r\n                        autoOpen: true,\r\n                        draggable: true,\r\n                        buttons: [\r\n                            {\r\n                                text: t(\"OK\"),\r\n                                click: $.proxy(this.onSubmit, this),\r\n                                icons: {\r\n                                    primary: \"fa fa-check\",\r\n                                },\r\n                            },\r\n                            {\r\n                                text: t(\"Cancel\"),\r\n                                click: $.proxy(this.close, this),\r\n                                icons: {\r\n                                    primary: \"fa fa-times\",\r\n                                },\r\n                            },\r\n                        ],\r\n                        open: () => {\r\n                            // add a dialog icon\r\n                            $('<i class=\"fa fa-check\" />').insertBefore(\r\n                                this.$el.parent().find(\".ui-dialog-title\"),\r\n                            );\r\n\r\n                            // add blur\r\n                            $(\".quick-base\").addClass(\"disturbed\");\r\n\r\n                            this.$okBtn = $(this)\r\n                                .parent()\r\n                                .find(\".ui-dialog-buttonpane button\")\r\n                                .first();\r\n\r\n                            this.$el.find(\".old-password-input\").focus();\r\n                        },\r\n                        close: () => {\r\n                            $(\".quick-base\").removeClass(\"disturbed\");\r\n                            ErrorTooltip.clearAll();\r\n\r\n                            if (_.isFunction(options.onClose)) {\r\n                                options.onClose();\r\n                            }\r\n\r\n                            this.onRemove();\r\n\r\n                            if (_.isFunction(options.onDialogClose)) {\r\n                                options.onDialogClose();\r\n                            }\r\n                        },\r\n                    },\r\n                    options,\r\n                ),\r\n            );\r\n\r\n            $(this.form.el)\r\n                .find(\"input\")\r\n                .on(\"keydown\", e => {\r\n                    if (e.which === 13) {\r\n                        this.onSubmit();\r\n                    }\r\n                });\r\n            // Key Press has different event state then keydown\r\n            $(this.form.el)\r\n                .find(\"input\")\r\n                .on(\"keypress\", (e: JQuery.Event) => {\r\n                    if (LoginDialog.checkCapslockOn(e.originalEvent)) {\r\n                        this.showMessage(\r\n                            '<i class=\"fa fa-warning\"/>' + t(\"Caps Lock is on\"),\r\n                            \"warning\",\r\n                        );\r\n                    } else {\r\n                        this.showMessage(); // hide\r\n                    }\r\n                });\r\n\r\n            window.addEventListener(\"keydown\", this.boundToggleCaps, true);\r\n        }\r\n\r\n        close() {\r\n            this.$dialog[\"dialog\"](\"close\");\r\n        }\r\n\r\n        onSubmit(e?: any) {\r\n            let $okBtn,\r\n                $cancelBtn,\r\n                $icon,\r\n                undo,\r\n                self = this;\r\n\r\n            if (e) {\r\n                e.stopPropagation();\r\n            }\r\n\r\n            if (!this.clicked) {\r\n                const validation = this.form.commit();\r\n                if (!_.isEmpty(validation)) {\r\n                    return;\r\n                }\r\n\r\n                this.clicked = true;\r\n                this.$messageBox.hide();\r\n\r\n                undo = function() {\r\n                    $icon.removeClass(\"fa-spinner fa-pulse\");\r\n                    $icon.css({\r\n                        width: \"\",\r\n                        height: \"\",\r\n                    });\r\n                    $icon.addClass(\"fa-check\");\r\n                    $okBtn.find(\".ui-button-text\").text(t(\"OK\"));\r\n                    $cancelBtn[\"button\"](\"enable\");\r\n                    self.clicked = false;\r\n                    DeltaClientLib.changingPassword = false;\r\n                };\r\n\r\n                // show changing in the button\r\n\r\n                // show wait info in the button\r\n                $okBtn = this.$okBtn; // $(e.currentTarget);\r\n                $icon = $okBtn.find(\".ui-button-icon-primary.fa-check\");\r\n                $icon.removeClass(\"fa-check\");\r\n                $icon.css({\r\n                    width: \"auto\",\r\n                    height: \"auto\",\r\n                });\r\n                $icon.addClass(\"fa-spinner fa-pulse\");\r\n                $okBtn.find(\".ui-button-text\").text(t(\"wait\" + \"...\"));\r\n                // disable cancel button\r\n                $cancelBtn = $okBtn.next();\r\n                $cancelBtn[\"button\"](\"disable\");\r\n\r\n                // validate new password\r\n                DeltaClientLib.changeUserPassword(\r\n                    self.model.get(\"oldpassword\"),\r\n                    self.model.get(\"password1\"),\r\n                    function() {\r\n                        Log.Info(\"Password changed successfully\");\r\n                        self.showMessage(\"Password changed successfully\", \"success\");\r\n                        if (_.isFunction(self.onChangeSuccess)) {\r\n                            self.onChangeSuccess();\r\n                        }\r\n                        _.delay(function() {\r\n                            self.close();\r\n                        }, 1000);\r\n                    },\r\n                    function(e) {\r\n                        Log.Error(\"Password change failed\");\r\n                        // display error\r\n                        self.showMessage(e);\r\n                        undo();\r\n                    },\r\n                );\r\n            }\r\n        }\r\n\r\n        onRemove() {\r\n            $(this.form.el)\r\n                .find(\"input\")\r\n                .off();\r\n\r\n            window.removeEventListener(\"keydown\", this.boundToggleCaps, true);\r\n\r\n            this.remove();\r\n        }\r\n\r\n        showMessage(message?: string, type?: string) {\r\n            if (message) {\r\n                this.$messageBox.html(message);\r\n                this.$messageBox\r\n                    .removeClass(this.MESSAGE_TYPES.join(\" \"))\r\n                    .addClass(type || \"error\");\r\n                this.$messageBox.show();\r\n            } else {\r\n                this.$messageBox.html();\r\n                this.$messageBox.removeClass(this.MESSAGE_TYPES.join(\" \"));\r\n                this.$messageBox.hide();\r\n            }\r\n        }\r\n\r\n        toggleCapsLockMsg(e: Event) {\r\n            if (e[\"which\"] === 20) {\r\n                if (e[\"getModifierState\"](\"CapsLock\")) {\r\n                    this.showMessage(\r\n                        '<i class=\"fa fa-warning\"/>' + t(\"Caps Lock is on\"),\r\n                        \"warning\",\r\n                    );\r\n                } else {\r\n                    this.showMessage(); // hide\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","/*global $, T, Backbone, FormSchemas, BBForm, DialogBase*/\n/// <reference path=\"../templates/combined.ts\" />\n/// <reference path=\"DialogBase.ts\" />\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class ConfirmDialog extends DialogBase {\n        constructor(options) {\n            super(\n                _.extend(\n                    {\n                        iconClass: \"fa-trash-o\",\n                        dialogTitle: \"Confirm Delete\",\n                        minHeight: 110,\n                        width: 275,\n                    },\n                    options,\n                    {\n                        userClass:\n                            \"confirm-dialog\" + (options.userClass ? \" \" + options.userClass : \"\"),\n                    },\n                ),\n            );\n\n            if (_.isFunction(options.renderTemplate)) {\n                this.renderTemplate = options.renderTemplate;\n            }\n        }\n\n        dialogButtons() {\n            return [\n                {\n                    text: \"OK\",\n                    click: () => {\n                        this.dialogClose();\n                    },\n                    icons: {\n                        primary: \"fa fa-check\",\n                    },\n                },\n                {\n                    text: \"Cancel\",\n                    click: () => {\n                        this.isCancel = true;\n                        this.dialogClose();\n                    },\n                    icons: {\n                        primary: \"fa fa-times\",\n                    },\n                },\n            ];\n        }\n\n        renderTemplate() {\n            return t(\"Are you sure you want to delete this item?\");\n        }\n\n        static ShowDelete(callbackFn, text) {\n            new ConfirmDialog(\n                _.extend(\n                    {\n                        iconClass: \"fa-trash-o\",\n                        dialogTitle: \"Confirm Delete\",\n                        callback: callbackFn,\n                    },\n                    text\n                        ? {\n                              renderTemplate() {\n                                  return text;\n                              },\n                          }\n                        : {},\n                ),\n            );\n        }\n\n        static ShowConfirm(props) {\n            const txt = props.txt || \"\",\n                containerOptions = props.container ? { container: props.container } : {};\n\n            new ConfirmDialog(\n                _.extend(\n                    {\n                        iconClass: props.iconClass || \"fa-question-circle\", //'fa-question', //'fa-stop',\n                        dialogTitle: props.dialogTitle || \"Confirmation\",\n                        callback: props.callback,\n                        cancelBtnCallback: props.cancelBtnCallback || _.noop,\n                        renderTemplate:\n                            props.renderTemplate ||\n                            function() {\n                                return (\n                                    txt + t(\"<br/>Are you sure you want to reload the Application?\")\n                                );\n                            },\n                    },\n                    containerOptions,\n                ),\n            );\n        }\n    }\n}\n","/*global $,_,Backbone,console,require,T,DocumentDataModel*/\r\n/// <reference path=\"../lib/backbone-deep-model.ts\" />\r\n/// <reference path=\"../classes/commonDefinitions.ts\" />\r\n/// <reference path=\"../classes/ComponentApi.ts\"/>\r\n/// <reference path=\"../classes/log.ts\"/>\r\n/// <reference path=\"../models/documentDataModel.ts\" />\r\n/// <reference path=\"../templates/combined.ts\" />\r\n/// <reference path=\"../views/AppView.ts\" />\r\n/// <reference path=\"../lib/i18n.d.ts\" />\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class ComponentView extends AppView {\r\n        private static _instances: Array<ComponentView> = [];\r\n\r\n        COMPONENT_SAVE_TIMEOUT = 2000;\r\n        QUERY_STATUS_DELAY = 200;\r\n        QUERY_STATUS_FADE = 3000;\r\n\r\n        $appDiv: JQuery;\r\n        $borderDiv: JQuery;\r\n        $customCss: JQuery;\r\n        $errorMessage: JQuery;\r\n        $progressBarDiv: JQuery;\r\n        $queryStatus: JQuery;\r\n        $titleDiv: JQuery;\r\n\r\n        app;\r\n        cssClasses;\r\n        customCss;\r\n        debouncedOnAlignmentChanged;\r\n        fadeTimer: number;\r\n        queryStatusTimer;\r\n        loadingTimer;\r\n        showLoadingIndicators;\r\n        showNoResultsIndicators = false;\r\n        queryStatusRemoveTimer: number;\r\n        customErrorClass = \"\";\r\n\r\n        constructor(options) {\r\n            super(options);\r\n            this.model.set(\"upgrading\", true, { silent: true });\r\n            ComponentView._instances.push(this);\r\n        }\r\n\r\n        static getInstances(): ComponentView[] {\r\n            return ComponentView._instances;\r\n        }\r\n\r\n        initalizeEvents() {\r\n            const doc = this.getContainerDocument();\r\n\r\n            AppView.prototype.initalizeEvents.apply(this, arguments);\r\n\r\n            this.listenTo(this.model, \"beforeRemove\", this.beforeRemove);\r\n\r\n            this.listenTo(this.dashboardViewModel, \"change:buildMode\", this.onBuildModeChanged);\r\n\r\n            // api listeners\r\n            this.listenTo(this.componentApi, \"hideErrorMessage\", this.hideErrorMessage);\r\n            this.listenTo(this.componentApi, \"hideQueryStatus\", this.hideQueryStatus);\r\n            this.listenTo(this.componentApi, \"showErrorMessage\", this.showErrorMessage);\r\n            this.listenTo(this.componentApi, \"showQueryStatus\", this.showQueryStatus);\r\n\r\n            // border and inner spacing changes\r\n            this.listenTo(doc, \"change:borderBackground\", (m, v) =>\r\n                this.setOptionsValue(\"format\", { tileBackgroundColor: \"#\" + v }),\r\n            );\r\n\r\n            this.listenTo(doc, \"change:transparentBackground\", (m, v) =>\r\n                this.setOptionsValue(\"format\", { tileTransparentBackground: v }),\r\n            );\r\n\r\n            this.listenTo(doc, \"change:borderColor\", (m, v) =>\r\n                this.setOptionsValue(\"format\", { tileBorderColor: \"#\" + v }),\r\n            );\r\n\r\n            this.listenTo(doc, \"change:borderRounding\", (m, v) =>\r\n                this.setOptionsValue(\"format\", { tileBorderRounding: v }),\r\n            );\r\n\r\n            this.listenTo(doc, \"change:borderSpacing\", (m, v) =>\r\n                this.setOptionsValue(\"Alignment\", {\r\n                    innerPaddingLeft: v,\r\n                    innerPaddingRight: v,\r\n                    innerPaddingTop: v,\r\n                    innerPaddingBottom: v,\r\n                    titlePaddingLeft: v,\r\n                    titlePaddingRight: v,\r\n                    titlePaddingTop: v,\r\n                }),\r\n            );\r\n\r\n            this.listenTo(doc, \"change:borderWidth\", (m, v) =>\r\n                this.setOptionsValue(\"format\", { tileBorderWidth: v }),\r\n            );\r\n\r\n            this.listenTo(doc, \"change:widgetsSpacing\", (m, v) =>\r\n                this.setOptionsValue(\"Alignment\", {\r\n                    paddingLeft: v,\r\n                    paddingRight: v,\r\n                    paddingTop: v,\r\n                    paddingBottom: v,\r\n                }),\r\n            );\r\n\r\n            this.listenTo(doc, \"change:borderShadow\", (m, v) =>\r\n                this.setOptionsValue(\"format\", { tileShadow: v }),\r\n            );\r\n            this.listenTo(doc, \"change:showLoadingIndicators\", this.onShowLoadingIndicatorsChanged);\r\n\r\n            // on format / alignment changes (widget styling)\r\n            this.listenTo(this.model.get(\"options\"), \"change:format\", this.onFormatChanged);\r\n\r\n            this.debouncedOnAlignmentChanged = _.debounce(this.onAlignmentChanged, 240);\r\n            this.listenTo(\r\n                this.model.get(\"options\"),\r\n                \"change:Alignment\",\r\n                this.debouncedOnAlignmentChanged,\r\n            );\r\n        }\r\n\r\n        applyCustomCss(newCustomCss) {\r\n            if (newCustomCss) {\r\n                if (!this.$customCss || !this.$customCss.length) {\r\n                    this.$customCss = $(\"<style />\", {\r\n                        \"data-widgetid\": this.widgetId,\r\n                        html: newCustomCss,\r\n                        type: \"text/css\",\r\n                    }).appendTo(document.head);\r\n                } else {\r\n                    this.$customCss.html(newCustomCss);\r\n                }\r\n                this.customCss = newCustomCss;\r\n            } else {\r\n                if (this.$customCss) {\r\n                    this.$customCss.remove();\r\n                    this.$customCss = null;\r\n                    this.customCss = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        applyCssClasses(newCssClasses) {\r\n            this.$appDiv.removeClass(this.cssClasses);\r\n\r\n            if (newCssClasses) {\r\n                if (_.isString(newCssClasses)) {\r\n                    this.cssClasses = newCssClasses;\r\n                } else {\r\n                    this.cssClasses = _.reduce(newCssClasses, function(classList, value) {\r\n                        return classList + \" \" + value;\r\n                    });\r\n                }\r\n                this.$appDiv.addClass(this.cssClasses);\r\n            } else {\r\n                this.cssClasses = null;\r\n            }\r\n        }\r\n\r\n        applyDashboardStyleSettings(): void {\r\n            const selectedDocumentId = this.dashboardViewModel.get(\"selectedDocumentId\");\r\n            const doc = this.dashboardAppModel.get(\"documents\").get(selectedDocumentId);\r\n            const format = this.model.get(\"options\").get(\"format\");\r\n            const align = this.model.get(\"options\").get(\"Alignment\");\r\n\r\n            // update format\r\n            if (format[\"tileBackgroundColor\"] === null) {\r\n                format[\"tileBackgroundColor\"] = \"#\" + doc.get(\"borderBackground\");\r\n            }\r\n            if (format[\"tileBorderColor\"] === null) {\r\n                format[\"tileBorderColor\"] = \"#\" + doc.get(\"borderColor\");\r\n            }\r\n            if (format[\"tileBorderRounding\"] === null) {\r\n                format[\"tileBorderRounding\"] = doc.get(\"borderRounding\");\r\n            }\r\n            if (format[\"tileBorderWidth\"] === null) {\r\n                format[\"tileBorderWidth\"] = doc.get(\"borderWidth\");\r\n            }\r\n            if (format[\"tileTransparentBackground\"] === null) {\r\n                format[\"tileTransparentBackground\"] = doc.get(\"transparentBackground\");\r\n            }\r\n            if (format[\"tileShadow\"] === null) {\r\n                format[\"tileShadow\"] = doc.get(\"borderShadow\");\r\n            }\r\n            // set format\r\n            this.model.get(\"options\").set(\"format\", format);\r\n\r\n            // update align\r\n            if (align[\"innerPaddingLeft\"] === null) {\r\n                align[\"innerPaddingLeft\"] = doc.get(\"borderSpacing\");\r\n            }\r\n            if (align[\"innerPaddingRight\"] === null) {\r\n                align[\"innerPaddingRight\"] = doc.get(\"borderSpacing\");\r\n            }\r\n            if (align[\"innerPaddingTop\"] === null) {\r\n                align[\"innerPaddingTop\"] = doc.get(\"borderSpacing\");\r\n            }\r\n            if (align[\"innerPaddingBottom\"] === null) {\r\n                align[\"innerPaddingBottom\"] = doc.get(\"borderSpacing\");\r\n            }\r\n            if (align[\"titlePaddingLeft\"] === null) {\r\n                align[\"titlePaddingLeft\"] = doc.get(\"borderSpacing\");\r\n            }\r\n            if (align[\"titlePaddingRight\"] === null) {\r\n                align[\"titlePaddingRight\"] = doc.get(\"borderSpacing\");\r\n            }\r\n            if (align[\"titlePaddingTop\"] === null) {\r\n                align[\"titlePaddingTop\"] = doc.get(\"borderSpacing\");\r\n            }\r\n            if (align[\"titlePaddingBottom\"] === null) {\r\n                align[\"titlePaddingBottom\"] = 0;\r\n            }\r\n            if (align[\"paddingLeft\"] === null) {\r\n                align[\"paddingLeft\"] = doc.get(\"widgetsSpacing\");\r\n            }\r\n            if (align[\"paddingRight\"] === null) {\r\n                align[\"paddingRight\"] = doc.get(\"widgetsSpacing\");\r\n            }\r\n            if (align[\"paddingTop\"] === null) {\r\n                align[\"paddingTop\"] = doc.get(\"widgetsSpacing\");\r\n            }\r\n            if (align[\"paddingBottom\"] === null) {\r\n                align[\"paddingBottom\"] = doc.get(\"widgetsSpacing\");\r\n            }\r\n            // set align\r\n            this.model.get(\"options\").set(\"Alignment\", align);\r\n        }\r\n\r\n        beforeRemove() {\r\n            let self = this,\r\n                appSaveCallback,\r\n                appSaveMessage,\r\n                beforeRemove;\r\n\r\n            if (this.app && _.isFunction(this.app.beforeRemove)) {\r\n                // if a component requires a check before being removed it should implement beforeRemove.\r\n                // returning a function/object from beforeRemove means that changes are pending and an AreYouSureDialog will be shown.\r\n                // the function will be called if the user decides to save and should then call the callback passed to it when complete.\r\n                // returning a falsey value means that no save is pending and the remove can continue as normal.\r\n                beforeRemove = this.app.beforeRemove();\r\n\r\n                // beforeRemove could be a simple function or an object containing the function and a message to display in AreYouSureDialog, e.g.\r\n                // {\r\n                //   callback(callback) {\r\n                //      doSave().then(function () {\r\n                //          // if error string is passed to callback it will be displayed and the save dialog will remain open\r\n                //          callback(error);\r\n                //      });\r\n                //   }\r\n                //   message: 'Changes need to be saved'\r\n                // }\r\n\r\n                if (beforeRemove) {\r\n                    if (_.isFunction(beforeRemove)) {\r\n                        appSaveCallback = beforeRemove;\r\n                    } else if (_.isFunction(beforeRemove.callback)) {\r\n                        appSaveCallback = beforeRemove.callback;\r\n                        appSaveMessage = beforeRemove.message;\r\n                    }\r\n                }\r\n\r\n                if (appSaveCallback) {\r\n                    return {\r\n                        // this wrapper callback will be be fired by AreYouSureDialog\r\n                        callback: saveCompleteCallback => {\r\n                            // ensure we only call callback to indicate component is finished once\r\n                            const complete = _.once(saveCompleteCallback),\r\n                                timer = _.delay(function() {\r\n                                    // put a time limit on the callback's execution\r\n                                    complete(\"Timed out\");\r\n                                }, self.COMPONENT_SAVE_TIMEOUT);\r\n\r\n                            try {\r\n                                // call the save function provided by the component\r\n                                appSaveCallback(function(error) {\r\n                                    // this is called by the component when it has finished its save\r\n                                    clearTimeout(timer);\r\n                                    complete(error);\r\n                                });\r\n                            } catch (error) {\r\n                                // return error to callback\r\n                                Log.Error(\"Save error\", error);\r\n                                clearTimeout(timer);\r\n                                complete(\"Save error\");\r\n                            }\r\n                        },\r\n                        component: self.model.get(\"key\"), // component name\r\n                        message: appSaveMessage, // message to show in AreYouSureDialog\r\n                        widget: self.model.id, // widget id\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        getComponentName() {\r\n            const componentDefinition =\r\n                this.dashboardAppModel.get(\"components\").get(this.model.get(\"definitionId\")) ||\r\n                this.dashboardAppModel.get(\"components\").find({\r\n                    appKey: this.model.get(\"key\"),\r\n                });\r\n\r\n            if (componentDefinition) {\r\n                return componentDefinition.get(\"componentName\");\r\n            }\r\n\r\n            return \"\";\r\n        }\r\n\r\n        getContainerDocument() {\r\n            const selectedDocumentId = this.dashboardViewModel.get(\"selectedDocumentId\");\r\n            return this.dashboardAppModel.get(\"documents\").get(selectedDocumentId);\r\n        }\r\n\r\n        hideErrorMessage() {\r\n            this.$errorMessage.hide();\r\n        }\r\n\r\n        hideQueryStatus() {\r\n            clearTimeout(this.queryStatusTimer);\r\n            clearInterval(this.loadingTimer);\r\n            this.queryStatusRemoveTimer = _.delay(() => {\r\n                this.$queryStatus.hide();\r\n            }, 200);\r\n        }\r\n\r\n        onAlignmentChanged(dontResize?) {\r\n            let self = this,\r\n                alignment = this.model.get(\"options\").get(\"Alignment\"),\r\n                appDivCss,\r\n                borderCss,\r\n                getAlignmentValue,\r\n                titleCss,\r\n                titleOuterHeight;\r\n\r\n            getAlignmentValue = function(key) {\r\n                return Number(\r\n                    self.componentApi.getPropertyValue(alignment[key], \"Alignment.\" + key),\r\n                );\r\n            };\r\n\r\n            borderCss = {\r\n                \"margin-left\": getAlignmentValue(\"paddingLeft\"),\r\n                \"margin-right\": getAlignmentValue(\"paddingRight\"),\r\n                \"margin-top\": getAlignmentValue(\"paddingTop\"),\r\n                \"margin-bottom\": getAlignmentValue(\"paddingBottom\"),\r\n            };\r\n\r\n            this.$borderDiv.css(borderCss);\r\n\r\n            // first set title\r\n            titleCss = {\r\n                \"margin-left\": getAlignmentValue(\"titlePaddingLeft\"),\r\n                \"margin-right\": getAlignmentValue(\"titlePaddingRight\"),\r\n                \"padding-top\": getAlignmentValue(\"titlePaddingTop\"),\r\n                \"padding-bottom\": getAlignmentValue(\"titlePaddingBottom\"),\r\n            };\r\n\r\n            this.$titleDiv.css(titleCss);\r\n\r\n            // then set app div\r\n            if (self.$titleDiv.is(\":visible\")) {\r\n                titleOuterHeight =\r\n                    self.$titleDiv.outerHeight(true) + getAlignmentValue(\"innerPaddingTop\");\r\n            } else {\r\n                titleOuterHeight = getAlignmentValue(\"innerPaddingTop\");\r\n            }\r\n\r\n            appDivCss = {\r\n                left: getAlignmentValue(\"innerPaddingLeft\"),\r\n                right: getAlignmentValue(\"innerPaddingRight\"),\r\n                top: titleOuterHeight,\r\n                bottom: getAlignmentValue(\"innerPaddingBottom\"),\r\n            };\r\n\r\n            self.$appDiv.css(appDivCss);\r\n\r\n            if (!dontResize) {\r\n                self.onResize();\r\n            }\r\n        }\r\n\r\n        onBuildModeChanged(model, value, options) {\r\n            if (this.dashboardViewModel.get(\"buildMode\")) {\r\n                this.$el.removeClass(\"build-off\");\r\n            } else {\r\n                this.$el.addClass(\"build-off\");\r\n            }\r\n        }\r\n\r\n        onFormatChanged(dontResize?) {\r\n            let align,\r\n                borderCss,\r\n                format = this.model.get(\"options\").get(\"format\"),\r\n                getFormatValue,\r\n                titleCss,\r\n                widgetTitle,\r\n                self = this;\r\n\r\n            //console.log(\"on format changed\", model, value);\r\n\r\n            getFormatValue = function(key) {\r\n                return self.componentApi.getPropertyValue(format[key], \"Format.\" + key);\r\n            };\r\n\r\n            borderCss = {\r\n                \"border-width\": getFormatValue(\"tileBorderWidth\"),\r\n                \"border-radius\": getFormatValue(\"tileBorderRounding\"),\r\n                \"border-color\": getFormatValue(\"tileBorderColor\"),\r\n                \"background-color\": getFormatValue(\"tileTransparentBackground\")\r\n                    ? \"transparent\"\r\n                    : getFormatValue(\"tileBackgroundColor\"),\r\n                \"box-shadow\": getFormatValue(\"tileShadow\")\r\n                    ? \"rgba(0, 0, 0, 0.78) 2px 2px 5px\"\r\n                    : \"none\",\r\n            };\r\n\r\n            // add css border\r\n            this.$borderDiv.css(borderCss);\r\n\r\n            titleCss = {\r\n                \"font-size\": getFormatValue(\"titleFontSize\"),\r\n                \"font-weight\": getFormatValue(\"titleFontBold\") ? \"bold\" : \"normal\",\r\n                \"text-align\": getFormatValue(\"titleHorizontal\"),\r\n                color: getFormatValue(\"titleColor\"),\r\n                \"background-color\": getFormatValue(\"titleTransparentBackground\")\r\n                    ? \"transparent\"\r\n                    : getFormatValue(\"titleBackgroundColor\"),\r\n                \"border-bottom-width\": getFormatValue(\"titleBottomBorderWidth\"),\r\n                \"text-shadow\": getFormatValue(\"titleShadow\")\r\n                    ? \"rgba(0, 0, 0, 0.5) 2px 2px 3px\"\r\n                    : \"none\",\r\n            };\r\n\r\n            //set titleDiv to have a border radius to prevent background overflow\r\n            let titleRadius = 0;\r\n            if (getFormatValue(\"tileBorderRounding\") > 0) {\r\n                titleRadius =\r\n                    getFormatValue(\"tileBorderRounding\") * 0.85 -\r\n                    getFormatValue(\"tileBorderWidth\") / 4;\r\n            }\r\n            this.$titleDiv.css(\"border-top-left-radius\", titleRadius);\r\n            this.$titleDiv.css(\"border-top-right-radius\", titleRadius);\r\n\r\n            align = self.model.get(\"options\").get(\"Alignment\");\r\n            widgetTitle = getFormatValue(\"widgetTitle\");\r\n\r\n            if (widgetTitle) {\r\n                // title\r\n                this.$titleDiv.css(titleCss);\r\n                // set the text\r\n                this.$titleDiv.text(widgetTitle);\r\n                // show\r\n                this.$titleDiv.show();\r\n                // change top\r\n                self.$appDiv.css(\r\n                    \"top\",\r\n                    align[\"innerPaddingTop\"] + self.$titleDiv.outerHeight(true),\r\n                );\r\n            } else {\r\n                this.$titleDiv.hide();\r\n                // change top\r\n                self.$appDiv.css(\"top\", align[\"innerPaddingTop\"]);\r\n            }\r\n\r\n            if (!dontResize) {\r\n                this.onResize();\r\n            }\r\n        }\r\n\r\n        onShowLoadingIndicatorsChanged(model, value) {\r\n            this.showLoadingIndicators = value;\r\n        }\r\n\r\n        onShowNoResultsIndicatorsChanged(model, value) {\r\n            this.showNoResultsIndicators = value;\r\n        }\r\n\r\n        onStyleChanged() {\r\n            const style = this.model.get(\"options\").get(\"Style\");\r\n            const getStyleValue = (key: string): any =>\r\n                this.componentApi.getPropertyValue(style[key], \"Style.\" + key);\r\n\r\n            const advancedCss = getStyleValue(\"advanced\");\r\n            if (advancedCss !== this.customCss) {\r\n                this.applyCustomCss(advancedCss);\r\n            }\r\n\r\n            const cssClasses = getStyleValue(\"cssClasses\");\r\n            if (cssClasses !== this.cssClasses) {\r\n                this.applyCssClasses(cssClasses);\r\n            }\r\n        }\r\n\r\n        postComponentLoad(componentDefinition, customElement?): void {\r\n            // on processed setting change\r\n            this.appOnSettingsChange = (settings): void => {\r\n                const keys = Object.keys(settings);\r\n                this.quickStart(componentDefinition.appArgs.quickStart);\r\n\r\n                // process Style changed if keys present\r\n                if (_.find(keys, k => k.indexOf(\"Style\") === 0)) {\r\n                    this.onStyleChanged();\r\n                }\r\n\r\n                // process format changed if keys present\r\n                if (_.find(keys, k => k.indexOf(\"format\") === 0)) {\r\n                    this.onFormatChanged();\r\n                }\r\n\r\n                // process Alignment changed if keys present\r\n                if (_.find(keys, k => k.indexOf(\"Alignment\") === 0)) {\r\n                    this.onAlignmentChanged();\r\n                }\r\n\r\n                if (customElement) customElement.settings = settings;\r\n                else if (this.app && _.isFunction(this.app.onSettingsChange)) {\r\n                    this.app.onSettingsChange(settings);\r\n                }\r\n            };\r\n\r\n            // set component initial state\r\n            if (this.appOnSettingsChange && this.model.get(\"options\").toFlat) {\r\n                const settings = this.componentApi.processSettings(\r\n                    this.model.get(\"options\").toFlat(),\r\n                    this.appOnSettingsChange,\r\n                );\r\n                if (customElement) {\r\n                    customElement.settings = settings;\r\n                    this.quickStart(componentDefinition.appArgs.quickStart);\r\n                } else {\r\n                    // invoke component setting change on load\r\n                    if (this.app && _.isFunction(this.app.onSettingsChange)) {\r\n                        this.app.onSettingsChange(settings);\r\n                        this.quickStart(componentDefinition.appArgs.quickStart);\r\n                    }\r\n\r\n                    // Set flag if component implements onSettingsChange (used by PropertiesPanel)\r\n                    if (_.isFunction(this.app.onSettingsChange)) {\r\n                        if (this.model.get(\"key\") === \"BasicComponents\") {\r\n                            // temporary extra check until all BasicComponents implement onSettingsChange\r\n                            if (_.isFunction(this.app.$view.onSettingsChange)) {\r\n                                this.model.set(\"hasOnSettingsChange\", true, {\r\n                                    silent: true,\r\n                                });\r\n                            } else {\r\n                                this.model.unset(\"hasOnSettingsChange\", { silent: true });\r\n                            }\r\n                        } else {\r\n                            this.model.set(\"hasOnSettingsChange\", true, { silent: true });\r\n                        }\r\n                    } else {\r\n                        this.model.unset(\"hasOnSettingsChange\", { silent: true });\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.model.trigger(\"componentLoaded\");\r\n        }\r\n\r\n        processComponentDefinition(existingComponentDefiniton, componentDefinition): void {\r\n            if (existingComponentDefiniton) {\r\n                existingComponentDefiniton.set(\r\n                    _.omit(\r\n                        componentDefinition,\r\n                        \"id\",\r\n                        \"componentName\",\r\n                        \"componentDescription\",\r\n                        \"appKey\",\r\n                        \"buildModeOnly\",\r\n                        \"listViewThumb\",\r\n                    ),\r\n                );\r\n            }\r\n\r\n            // mark components that should only show in build mode\r\n            if (componentDefinition[\"buildModeOnly\"]) {\r\n                this.$el.addClass(\"build-mode-only\");\r\n            }\r\n\r\n            // add class .build-off if buildMode is false\r\n            if (!this.dashboardViewModel.get(\"buildMode\")) {\r\n                this.$el.addClass(\"build-off\");\r\n            }\r\n\r\n            // new - injecting common definitions (styling)\r\n            this.updateComponentDefinition(componentDefinition, this.model);\r\n\r\n            // Set default options if none exist\r\n            if ($.isEmptyObject(this.model.get(\"options\").attributes) && componentDefinition) {\r\n                //self.model.set(componentDefinition);\r\n                this.model.get(\"options\").set(componentDefinition[\"appArgs\"].json);\r\n            } else {\r\n                // not empty -- need to update options\r\n                // update model options\r\n                this.model\r\n                    .get(\"options\")\r\n                    .set(\r\n                        \"Alignment\",\r\n                        _.extend(\r\n                            {},\r\n                            componentDefinition[\"appArgs\"][\"json\"][\"Alignment\"],\r\n                            this.model.get(\"options\").get(\"Alignment\"),\r\n                        ),\r\n                        { silent: true },\r\n                    );\r\n\r\n                this.model\r\n                    .get(\"options\")\r\n                    .set(\r\n                        \"Style\",\r\n                        _.extend(\r\n                            {},\r\n                            componentDefinition[\"appArgs\"][\"json\"][\"Style\"],\r\n                            this.model.get(\"options\").get(\"Style\"),\r\n                        ),\r\n                        { silent: true },\r\n                    );\r\n\r\n                // update model options\r\n                const formatOptions = _.extend(\r\n                    {},\r\n                    componentDefinition[\"appArgs\"][\"json\"][\"format\"],\r\n                    this.model.get(\"options\").get(\"format\"),\r\n                );\r\n\r\n                // remove old props\r\n                delete formatOptions[\"titlePaddingLeft\"];\r\n                delete formatOptions[\"titlePaddingRight\"];\r\n                delete formatOptions[\"titlePaddingTop\"];\r\n                delete formatOptions[\"titlePaddingBottom\"];\r\n\r\n                // set as options\r\n                this.model.get(\"options\").set({ format: null }, { silent: true });\r\n                this.model.get(\"options\").set({ format: formatOptions }, { silent: true });\r\n            }\r\n\r\n            this.componentApi.convertPathsToModels(\r\n                \"data\",\r\n                componentDefinition[\"appArgs\"].schema,\r\n                this.model.get(\"options\"),\r\n            );\r\n            this.componentApi.convertPathsToModels(\r\n                \"viewstate\",\r\n                componentDefinition[\"appArgs\"].schema,\r\n                this.model.get(\"options\"),\r\n            );\r\n\r\n            Component.convertDashboardTypesToModels(\r\n                this.model.get(\"options\"),\r\n                (path: string) => this.docDataModel.getByPath(path),\r\n                (path: string) => this.docViewModel.getByPath(path),\r\n            );\r\n\r\n            // if null then set dashboard setting\r\n            this.applyDashboardStyleSettings();\r\n\r\n            this.model.unset(\"upgrading\", { silent: true });\r\n\r\n            this.onStyleChanged();\r\n            this.onFormatChanged();\r\n            this.onAlignmentChanged();\r\n        }\r\n\r\n        quickStart(config) {\r\n            _.each(config, obj => {\r\n                if (this.settingsModel.get(obj.path) || this.quickView) {\r\n                    this.hideErrorMessage();\r\n                } else {\r\n                    const message = obj.message || \"populate widget\";\r\n\r\n                    this.showErrorMessage({\r\n                        error: t(\"Click to \") + \" <b> \" + message + \"</b>\",\r\n                        type: \"QuickStart\",\r\n                        onClick: () => {\r\n                            if (this.dashboardViewModel.get(\"selectedWidgetId\") !== this.widgetId) {\r\n                                this.$el.trigger(\"click\");\r\n                            }\r\n\r\n                            this.model.get(\"options\").trigger(\"quickStart\", obj.path);\r\n                        },\r\n                    });\r\n\r\n                    return false;\r\n                }\r\n            });\r\n        }\r\n\r\n        remove() {\r\n            // Remove custom css\r\n            if (this.$customCss) {\r\n                this.$customCss.remove();\r\n            }\r\n\r\n            ComponentView._instances = _.without(ComponentView._instances, this);\r\n\r\n            AppView.prototype.remove.apply(this, arguments);\r\n        }\r\n\r\n        render() {\r\n            const showLoadingIndicators = this.getContainerDocument().get(\"showLoadingIndicators\");\r\n\r\n            this.$el.html(T.ComponentView(this.model.toJSON()));\r\n            this.$errorMessage = this.$el.find(\".errorMessage\");\r\n            this.$queryStatus = this.$el.find(\".queryStatus\");\r\n            this.$titleDiv = this.$el.find(\".title-div\");\r\n            this.$borderDiv = this.$el.find(\".border-div\");\r\n\r\n            this.$appDiv = this.$el.find(\".app-div\");\r\n            if (this.widgetId) {\r\n                this.$customCss = $(\"head style[data-widgetid='\" + this.widgetId + \"']\");\r\n            }\r\n            this.$progressBarDiv = this.$el.find(\".progress-bar-div\");\r\n\r\n            // show loading if needed\r\n            this.onShowLoadingIndicatorsChanged(null, showLoadingIndicators);\r\n\r\n            this.model.set(\"upgrading\", true, { silent: true });\r\n\r\n            return this;\r\n        }\r\n\r\n        requireApp() {\r\n            const self = this,\r\n                rKey = self.model.get(\"key\");\r\n\r\n            let existingComponentDefiniton = self.dashboardAppModel\r\n                .get(\"components\")\r\n                .get(self.model.get(\"definitionId\"));\r\n\r\n            if (!existingComponentDefiniton) {\r\n                existingComponentDefiniton = self.dashboardAppModel.get(\"components\").find({\r\n                    appKey: self.model.get(\"key\"),\r\n                });\r\n            }\r\n\r\n            const customElementRef = existingComponentDefiniton.get(\"customElement\");\r\n            if (customElementRef && customElements.get(customElementRef)) {\r\n                // create & append custom element\r\n                const customElement = document.createElement(customElementRef);\r\n                self.$appDiv.append(customElement);\r\n\r\n                customElement.addEventListener(\"componentDefinition\", val => {\r\n                    const componentDefinition = val.detail;\r\n\r\n                    // update api ref\r\n                    customElement.componentApi = this.componentApi.interface;\r\n\r\n                    // load component\r\n                    this.processComponentDefinition(\r\n                        existingComponentDefiniton,\r\n                        componentDefinition,\r\n                    );\r\n\r\n                    this.initalizeEvents();\r\n\r\n                    // initially set theme\r\n                    customElement.theme = this.dashboardViewModel.get(\"DashboardTheme\");\r\n\r\n                    // add listener for theme changes\r\n                    this.listenTo(self.dashboardViewModel, \"change:DashboardTheme\", () => {\r\n                        customElement.theme = this.dashboardViewModel.get(\"DashboardTheme\");\r\n                    });\r\n\r\n                    // add resize listeners for build mode change\r\n                    this.listenTo(\r\n                        self.dashboardViewModel,\r\n                        \"change:buildMode\",\r\n                        () => (customElement.resize = \"\"),\r\n                    );\r\n\r\n                    // settings change setup\r\n                    this.postComponentLoad(componentDefinition, customElement);\r\n                });\r\n\r\n                _.delay(() => {\r\n                    customElement.options = {\r\n                        api: self.componentApi.interface,\r\n                        componentId: parseInt(self.model.get(\"definitionId\"), 10),\r\n                        componentModel: self.model,\r\n                        dashboardAppModel: self.dashboardAppModel,\r\n                        dashboardViewModel: self.dashboardViewModel,\r\n                        dataModel: self.docDataModel,\r\n                        settingsModel: self.model.get(\"options\"),\r\n                        viewModel: self.docViewModel,\r\n                        websiteUrl: self.dashboardAppModel.get(\"websiteUrl\"),\r\n                    };\r\n\r\n                    // hide loading\r\n                    this.$progressBarDiv.fadeOut(0, function() {\r\n                        $(this).remove();\r\n                    });\r\n                }, 1000);\r\n            } else {\r\n                requirejs(\r\n                    [rKey],\r\n                    function(AppModule) {\r\n                        try {\r\n                            // hide loading\r\n                            self.$progressBarDiv.fadeOut(0, function() {\r\n                                $(this).remove();\r\n                            });\r\n\r\n                            //take the saved value and merge with default component settings\r\n                            if (AppModule.mergeWithDefault) {\r\n                                self.model.set(\r\n                                    \"options\",\r\n                                    AppModule.mergeWithDefault(self.model.get(\"options\")),\r\n                                    { silent: true },\r\n                                );\r\n                            }\r\n                            if (AppModule.getDefaultJSONTemplates) {\r\n                                self.model.get(\r\n                                    \"options\",\r\n                                )._templates = AppModule.getDefaultJSONTemplates();\r\n                                //merge Global JSON Props\r\n                                self.model.get(\"options\")._templates.Defaults = _.extend(\r\n                                    {},\r\n                                    self.model.get(\"options\")._templates.Defaults,\r\n                                );\r\n                            }\r\n\r\n                            // Get component definition from AppView\r\n                            const componentDefinition = _.isFunction(\r\n                                AppModule.getComponentDefinition,\r\n                            )\r\n                                ? AppModule.getComponentDefinition({\r\n                                      api: self.componentApi.interface,\r\n                                      componentId: parseInt(self.model.get(\"definitionId\"), 10),\r\n                                      componentModel: self.model,\r\n                                      dashboardAppModel: self.dashboardAppModel,\r\n                                      dashboardViewModel: self.dashboardViewModel,\r\n                                      dataModel: self.docDataModel,\r\n                                      settingsModel: self.model.get(\"options\"),\r\n                                      viewModel: self.docViewModel,\r\n                                      websiteUrl: self.dashboardAppModel.get(\"websiteUrl\"),\r\n                                  })\r\n                                : _.cloneDeep({\r\n                                      appArgs: {\r\n                                          json: {},\r\n                                          schema: {\r\n                                              properties: {},\r\n                                              type: \"object\",\r\n                                          },\r\n                                      },\r\n                                  });\r\n\r\n                            // load component\r\n                            self.processComponentDefinition(\r\n                                existingComponentDefiniton,\r\n                                componentDefinition,\r\n                            );\r\n\r\n                            self.app = new AppModule({\r\n                                el: self.$appDiv[0],\r\n                                viewModel: self.docViewModel,\r\n                                dataModel: self.docDataModel,\r\n                                dashboardAppModel: self.dashboardAppModel,\r\n                                dashboardViewModel: self.dashboardViewModel,\r\n                                settingsModel: self.model.get(\"options\"),\r\n                                websiteUrl: self.dashboardAppModel.get(\"websiteUrl\"),\r\n                                componentModel: self.model,\r\n                                DeltaClientLib: self.deltaClient,\r\n                                api: self.componentApi.interface,\r\n                                widgetId: self.widgetId,\r\n                                quickView: self.quickView,\r\n                            });\r\n\r\n                            self.initalizeEvents();\r\n\r\n                            // settings change setup\r\n                            self.postComponentLoad(componentDefinition);\r\n\r\n                            if (_.isFunction(self.callback)) {\r\n                                self.callback(self.app);\r\n                            }\r\n                        } catch (error) {\r\n                            Log.Error(\r\n                                \"loading app error, require key: \" + self.model.get(\"key\"),\r\n                                error,\r\n                            );\r\n                            if (_.isFunction(self.callback)) {\r\n                                self.callback(error);\r\n                            }\r\n                        }\r\n                    },\r\n                    function(err) {\r\n                        Log.Error(\"ComponentView:loadApp require error\", err);\r\n                        if (_.isFunction(self.callback)) {\r\n                            self.callback(err);\r\n                        }\r\n                    },\r\n                );\r\n            }\r\n        }\r\n\r\n        showErrorMessage(errorObj) {\r\n            const errorType = errorObj.type || \"Error\";\r\n            let errorText = errorObj.error;\r\n            const $errorText = this.$errorMessage.find(\".errorText\");\r\n\r\n            //Remove flattened array indices if present in the string.\r\n            if (errorText.indexOf(\"0.0\") === 0) {\r\n                errorText = errorText.substring(4);\r\n            }\r\n\r\n            this.$errorMessage.removeClass(\"Error Warning Info QuickStart\").addClass(errorType);\r\n\r\n            this.$errorMessage.find(\".errorTitle span\").text(t(errorType));\r\n            $errorText.html(errorText);\r\n            this.$errorMessage.show();\r\n\r\n            // clear any previously set faders\r\n            if (this.fadeTimer) {\r\n                clearTimeout(this.fadeTimer);\r\n            }\r\n\r\n            this.$errorMessage.off(\"click\");\r\n\r\n            if (errorObj.onClick) {\r\n                this.$errorMessage.click(e => {\r\n                    // restrict to clicks within the panel\r\n                    const $target = $(e.target);\r\n                    if ($target.hasClass(\"errorPanel\") || $target.parents(\".errorPanel\").length) {\r\n                        e.stopPropagation();\r\n                        errorObj.onClick(e);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // set a fader?\r\n            if (errorType === \"Info\") {\r\n                this.fadeTimer = _.delay(() => this.$errorMessage.fadeOut(\"slow\"), 3000);\r\n            }\r\n        }\r\n\r\n        showQueryStatus(statusObj) {\r\n            let self = this,\r\n                statusText,\r\n                statusType,\r\n                statusTypeDisplay;\r\n\r\n            statusText = statusObj.message || statusObj.error || \"\";\r\n            statusType = statusObj.type || \"Error\";\r\n\r\n            // remove previously applied error class\r\n            if (self.customErrorClass) {\r\n                self.$queryStatus.removeClass(self.customErrorClass);\r\n                self.customErrorClass = \"\";\r\n            }\r\n\r\n            clearInterval(self.loadingTimer);\r\n            if (statusType === \"Loading\") {\r\n                let startTime = moment(),\r\n                    duration;\r\n\r\n                if (self.showLoadingIndicators) {\r\n                    statusText = \"0s\";\r\n                    self.loadingTimer = setInterval(function() {\r\n                        duration = moment.duration(moment().diff(startTime));\r\n                        statusText = duration.format(\"m[m] s[s]\");\r\n                        self.$queryStatus.find(\".statusText\").html(statusText);\r\n                    }, 1000);\r\n                } else return;\r\n            }\r\n\r\n            switch (statusType) {\r\n                case \"NoResults\":\r\n                    statusTypeDisplay = \"No Results\";\r\n                    break;\r\n                default:\r\n                    statusTypeDisplay = statusType;\r\n            }\r\n\r\n            //Remove flattened array indices if present in the string.\r\n            if (statusText.indexOf(\"0.0\") === 0) {\r\n                statusText = statusText.substring(4);\r\n            }\r\n\r\n            self.$queryStatus.css(\"margin\", self.$borderDiv.css(\"border-width\"));\r\n            self.$queryStatus.css(\"border-radius\", self.$borderDiv.css(\"border-radius\"));\r\n\r\n            self.$queryStatus\r\n                .removeClass(\"Error Warning Info Loading NoResults\")\r\n                .addClass(statusType);\r\n\r\n            self.$queryStatus\r\n                .find(\".statusTitle span\")\r\n                .text(t(statusTypeDisplay) + (statusText && statusType !== \"Loading\" ? \": \" : \"\"));\r\n\r\n            let rgxMatch;\r\n            // first matched group is empty in standalone mode\r\n            // with Delta, the error message starts with \"0: Database exception: \"\r\n            if (\r\n                statusType === \"Error\" &&\r\n                (rgxMatch = /(.*)cssClass:\"(.*)\":(.*)/m.exec(statusText))\r\n            ) {\r\n                self.customErrorClass = rgxMatch[2];\r\n                self.$queryStatus.addClass(self.customErrorClass);\r\n                statusText = rgxMatch[3];\r\n            }\r\n\r\n            self.$queryStatus.find(\".statusText\").html(statusText);\r\n\r\n            clearTimeout(self.queryStatusTimer);\r\n            clearTimeout(self.queryStatusRemoveTimer);\r\n            self.queryStatusTimer = _.delay(function() {\r\n                self.$queryStatus.show();\r\n            }, self.QUERY_STATUS_DELAY);\r\n\r\n            // clear any previously set faders\r\n            if (self.fadeTimer) {\r\n                clearTimeout(self.fadeTimer);\r\n            }\r\n\r\n            // set a fader?\r\n            if (statusType === \"Info\") {\r\n                self.fadeTimer = _.delay(function() {\r\n                    self.$queryStatus.fadeOut(\"slow\");\r\n                }, self.QUERY_STATUS_FADE);\r\n            }\r\n        }\r\n\r\n        updateComponentDefinition(componentDefinition, model) {\r\n            let commonDefinition = getCommonDefinition(),\r\n                alignment = componentDefinition[\"appArgs\"][\"schema\"][\"properties\"][\"Alignment\"],\r\n                format = componentDefinition[\"appArgs\"][\"schema\"][\"properties\"][\"format\"],\r\n                style = componentDefinition[\"appArgs\"][\"schema\"][\"properties\"][\"Style\"],\r\n                json = componentDefinition[\"appArgs\"][\"json\"][\"Style\"],\r\n                formatOptions;\r\n\r\n            // 1. Style\r\n            // #schema\r\n            if (style) {\r\n                // fix\r\n                _.each(\r\n                    commonDefinition[\"appArgs\"][\"schema\"][\"properties\"][\"Style\"][\"properties\"],\r\n                    function(value, key) {\r\n                        // fix or inject schema property\r\n                        style[\"properties\"][key] = value;\r\n                    },\r\n                );\r\n            } else {\r\n                // inject whole object\r\n                componentDefinition[\"appArgs\"][\"schema\"][\"properties\"][\"Style\"] =\r\n                    commonDefinition[\"appArgs\"][\"schema\"][\"properties\"][\"Style\"];\r\n            }\r\n\r\n            if (json) {\r\n                componentDefinition[\"appArgs\"][\"json\"][\"Style\"] = _.extend(\r\n                    {},\r\n                    commonDefinition[\"appArgs\"][\"json\"][\"Style\"],\r\n                    json,\r\n                );\r\n            } else {\r\n                // inject whole object\r\n                componentDefinition[\"appArgs\"][\"json\"][\"Style\"] = _.clone(\r\n                    commonDefinition[\"appArgs\"][\"json\"][\"Style\"],\r\n                );\r\n            }\r\n\r\n            // 2. Alignment\r\n            // #schema - no need to clone\r\n            if (alignment) {\r\n                // fix\r\n                _.each(\r\n                    commonDefinition[\"appArgs\"][\"schema\"][\"properties\"][\"Alignment\"][\"properties\"],\r\n                    function(value, key) {\r\n                        // fix or inject schema property\r\n                        alignment[\"properties\"][key] = value;\r\n                    },\r\n                );\r\n            } else {\r\n                // inject whole object\r\n                componentDefinition[\"appArgs\"][\"schema\"][\"properties\"][\"Alignment\"] =\r\n                    commonDefinition[\"appArgs\"][\"schema\"][\"properties\"][\"Alignment\"];\r\n            }\r\n\r\n            json = componentDefinition[\"appArgs\"][\"json\"][\"Alignment\"];\r\n            // #json - clone\r\n            if (json) {\r\n                componentDefinition[\"appArgs\"][\"json\"][\"Alignment\"] = _.extend(\r\n                    {},\r\n                    commonDefinition[\"appArgs\"][\"json\"][\"Alignment\"],\r\n                    json,\r\n                );\r\n            } else {\r\n                // inject whole object\r\n                componentDefinition[\"appArgs\"][\"json\"][\"Alignment\"] = _.clone(\r\n                    commonDefinition[\"appArgs\"][\"json\"][\"Alignment\"],\r\n                );\r\n            }\r\n\r\n            // 3. Format\r\n            // #schema\r\n            if (format) {\r\n                // fix\r\n                _.each(\r\n                    commonDefinition[\"appArgs\"][\"schema\"][\"properties\"][\"format\"][\"properties\"],\r\n                    function(value, key) {\r\n                        // fix or inject schema property\r\n                        format[\"properties\"][key] = value;\r\n                    },\r\n                );\r\n\r\n                // remove 4 schema properites\r\n                delete format[\"properties\"][\"titlePaddingLeft\"];\r\n                delete format[\"properties\"][\"titlePaddingRight\"];\r\n                delete format[\"properties\"][\"titlePaddingTop\"];\r\n                delete format[\"properties\"][\"titlePaddingBottom\"];\r\n            } else {\r\n                // inject whole object\r\n                componentDefinition[\"appArgs\"][\"schema\"][\"properties\"][\"format\"] =\r\n                    commonDefinition[\"appArgs\"][\"schema\"][\"properties\"][\"format\"];\r\n            }\r\n\r\n            // #json\r\n            json = componentDefinition[\"appArgs\"][\"json\"][\"format\"];\r\n            if (json) {\r\n                componentDefinition[\"appArgs\"][\"json\"][\"format\"] = _.extend(\r\n                    {},\r\n                    commonDefinition[\"appArgs\"][\"json\"][\"format\"],\r\n                    json,\r\n                );\r\n\r\n                // remove 4 schema properites\r\n                delete componentDefinition[\"appArgs\"][\"json\"][\"format\"][\"titlePaddingLeft\"];\r\n                delete componentDefinition[\"appArgs\"][\"json\"][\"format\"][\"titlePaddingRight\"];\r\n                delete componentDefinition[\"appArgs\"][\"json\"][\"format\"][\"titlePaddingTop\"];\r\n                delete componentDefinition[\"appArgs\"][\"json\"][\"format\"][\"titlePaddingBottom\"];\r\n            } else {\r\n                // inject whole object\r\n                componentDefinition[\"appArgs\"][\"json\"][\"format\"] = _.clone(\r\n                    commonDefinition[\"appArgs\"][\"json\"][\"format\"],\r\n                );\r\n            }\r\n        }\r\n\r\n        private setOptionsValue(prop: string, value: any): void {\r\n            // make change to component settings ('options')\r\n            const existingVal = this.model.get(\"options\").get(prop);\r\n\r\n            // set new\r\n            this.model.get(\"options\").set(prop, _.extend({}, existingVal, value));\r\n        }\r\n    }\r\n}\r\n","/*global _, $, Backbone, console, Conv, T, Tools, Component, Widget */\r\n/// <reference path=\"../templates/combined.ts\" />\r\n/// <reference path=\"../lib/delta-client-lib.ts\" />\r\n/// <reference path=\"../models/component.ts\" />\r\n/// <reference path=\"../views/ComponentView.ts\" />\r\n/// <reference path=\"../views/ConfirmDialog.ts\" />\r\n/// <reference path=\"../lib/i18n.d.ts\" />\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class ComponentDropView extends Backbone.View<Backbone.Model> {\r\n        protected dashboardAppModel: Backbone.Model;\r\n        protected dashboardViewModel: Backbone.Model;\r\n        DeltaClientLib: any;\r\n        protected quickView: boolean;\r\n        protected websiteUrl: string;\r\n        widgetClass = \"component-drop-widget\";\r\n        widgetsCollection: WidgetCollection;\r\n        widgets: Array<any>;\r\n        ignoreWidgetSelect: boolean;\r\n        selected: any;\r\n        debouncedResizeWidgets: (x: any) => void;\r\n\r\n        constructor(options) {\r\n            super(options);\r\n        }\r\n\r\n        initialize(options) {\r\n            this.$el.addClass(\"component-drop\");\r\n\r\n            this.dashboardAppModel = options[\"dashboardAppModel\"];\r\n            this.dashboardViewModel = options[\"dashboardViewModel\"];\r\n            this.DeltaClientLib = options[\"DeltaClientLib\"];\r\n            this.quickView = options[\"quickView\"];\r\n            this.websiteUrl = options[\"websiteUrl\"];\r\n            this.widgetsCollection = this.widgetsCollection || options[\"widgets\"];\r\n            this.widgets = this.widgets || [];\r\n\r\n            this.ignoreWidgetSelect = false;\r\n            this.widgetClass = \"component-drop-widget\";\r\n\r\n            this.initializeEvents();\r\n            this.initializeEvents_widgetCollection();\r\n\r\n            // init ui\r\n            if (this.quickView) {\r\n                this.switchOffBuildMode();\r\n            } else {\r\n                this.switchBuildMode(this.dashboardViewModel.get(\"buildMode\"));\r\n            }\r\n\r\n            this.applyCurrentWidgets();\r\n        }\r\n\r\n        initializeEvents() {\r\n            this.listenTo(this.dashboardViewModel, \"change:buildMode\", this.onBuildModeChanged);\r\n            this.listenTo(\r\n                this.dashboardViewModel,\r\n                \"change:selectedWidget\",\r\n                this.onSelectedWidgetChanged,\r\n            );\r\n            this.listenTo(\r\n                this.dashboardAppModel,\r\n                \"change:pendingSelectionWidgetId\",\r\n                this.onSelectingWidget,\r\n            );\r\n        }\r\n\r\n        initializeEvents_widgetCollection() {\r\n            this.listenTo(this.widgetsCollection, \"add\", this.onWidgetCollectionAdd);\r\n            this.listenTo(this.widgetsCollection, \"remove\", this.onWidgetCollectionRemove);\r\n        }\r\n\r\n        events(): any {\r\n            return {\r\n                dragenter: \"onDragEnter\",\r\n                dragleave: \"onDragLeave\",\r\n                dragover: \"onDragOver\",\r\n                drop: \"onDrop\",\r\n            };\r\n        }\r\n\r\n        addComponentToWidget(widgetModel: Widget, componentId: string, command: boolean) {\r\n            const componentDefinition = this.dashboardAppModel.get(\"components\").get(componentId);\r\n            const appKey = this.getAppKey(componentDefinition);\r\n            const widgetComponent = widgetModel.get(\"component\");\r\n            const widgetItem = this.findWidgetItem(widgetModel.id);\r\n            const component = this.createNewComponent(componentId, appKey, widgetModel);\r\n\r\n            if (widgetComponent) {\r\n                const widgetKey = widgetComponent.get(\"key\");\r\n\r\n                if (widgetKey === \"Tabs\") {\r\n                    // component responsible for loading the component\r\n                    const parent = widgetComponent.getInnermostComponents(widgetKey);\r\n                    parent.add(component);\r\n                    component.setParent(parent);\r\n                } else {\r\n                    if (widgetItem && widgetItem.view) {\r\n                        widgetItem.view.remove();\r\n                        widgetItem.view = null;\r\n                    }\r\n\r\n                    if (command) {\r\n                        widgetModel.commandSet({\r\n                            component: component,\r\n                        });\r\n                    } else {\r\n                        widgetModel.set(\"component\", component);\r\n                    }\r\n                }\r\n            } else {\r\n                if (command) {\r\n                    widgetModel.commandSet({\r\n                        component: component,\r\n                    });\r\n                } else {\r\n                    widgetModel.set(\"component\", component);\r\n                }\r\n            }\r\n        }\r\n\r\n        addWidget(widgetModel: Widget, bulk: boolean, index: number | null) {\r\n            let widgetId,\r\n                widgetItem,\r\n                $widget,\r\n                $remove,\r\n                self = this;\r\n\r\n            // create widget id\r\n            widgetId = widgetModel.id;\r\n\r\n            // new widget\r\n            $widget = this.renderWidget(widgetModel);\r\n\r\n            // add remove btn\r\n            $remove = $(document.createElement(\"div\"));\r\n            $remove.addClass(\"fa fa-times remove-btn\");\r\n            $remove.appendTo($widget);\r\n            $remove.click(function(e) {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n                widgetModel.trigger(\"removeWidget\");\r\n            });\r\n\r\n            // add widget class/id\r\n            $widget.addClass(this.getWidgetClass(index));\r\n            $widget.attr(\"data-widgetid\", widgetId);\r\n\r\n            // may not be in build mode\r\n            if (!this.dashboardViewModel.get(\"buildMode\")) {\r\n                $widget.addClass(\"build-off\");\r\n            }\r\n\r\n            // bind widget events\r\n            this.addWidgetEvents($widget);\r\n\r\n            widgetItem = {\r\n                $remove: $remove,\r\n                $widget: $widget,\r\n                widgetId: widgetId,\r\n                model: widgetModel,\r\n                view: null,\r\n            };\r\n\r\n            // save widget\r\n            this.widgets.push(widgetItem);\r\n\r\n            // load app\r\n            if (widgetModel.get(\"component\")) {\r\n                // select widget if not adding in bulk\r\n                this.renderComponent(\r\n                    widgetItem,\r\n                    bulk ? () => {} : () => this.selectWidget(widgetItem),\r\n                );\r\n            }\r\n\r\n            // listen for component\r\n            self.stopListening(widgetModel, \"change:component\");\r\n            self.listenTo(\r\n                widgetModel,\r\n                \"change:component\",\r\n                _.bind(\r\n                    function() {\r\n                        if (widgetItem.view) {\r\n                            widgetItem.view.remove();\r\n                            widgetItem.view = null;\r\n                        }\r\n\r\n                        widgetItem.$widget.find(\".grid-stack-item-content\").remove();\r\n\r\n                        self.renderComponent(widgetItem, () => self.selectWidget(widgetItem));\r\n                    },\r\n                    self,\r\n                    widgetItem,\r\n                ),\r\n            );\r\n\r\n            // listen for remove\r\n            self.stopListening(widgetModel, \"removeWidget\");\r\n            self.listenTo(widgetModel, \"removeWidget\", self.onRemoveWidget.bind(self, widgetModel));\r\n\r\n            return widgetItem;\r\n        }\r\n\r\n        addNewWidget(widgetModel?: Widget, componentId?: string, pasted?: boolean) {\r\n            if (!widgetModel) {\r\n                widgetModel = new Widget({}, {}, this.widgetsCollection);\r\n            }\r\n\r\n            if (componentId && !pasted) {\r\n                this.addComponentToWidget(widgetModel, componentId, false);\r\n            }\r\n\r\n            this.widgetsCollection.commandAdd(widgetModel, pasted ? \"Paste\" : null);\r\n\r\n            return _.findLast(this.widgets, { widgetId: widgetModel.id });\r\n        }\r\n\r\n        addWidgetEvents($widgets) {\r\n            let $widget,\r\n                self = this;\r\n\r\n            if ($widgets instanceof $) {\r\n                _.each($widgets, function(widget) {\r\n                    // get jquery obj\r\n                    $widget = $(widget);\r\n                    // hook up all events\r\n                    $widget.off(\"click\");\r\n                    $widget.on(\"click\", $.proxy(self.onWidgetClick, self));\r\n                });\r\n            } else {\r\n                throw \"Wrong parameter.\";\r\n            }\r\n        }\r\n\r\n        applyCurrentWidgets() {\r\n            const self = this;\r\n\r\n            // apply\r\n            _.each(this.widgetsCollection.models, function(widgetModel) {\r\n                self.addWidget(widgetModel, true, null);\r\n            });\r\n        }\r\n\r\n        clearWidgets(callback?: () => void) {\r\n            let self = this,\r\n                temp;\r\n            self.deselectCurrentWidget();\r\n            // remove widgets\r\n            // each remove widget is\r\n            if (this.widgets.length > 0) {\r\n                // remove widgets one by one\r\n                _.each(this.widgets, function(widgetItem) {\r\n                    // remove view\r\n                    if (widgetItem.view && _.isFunction(widgetItem.view.remove)) {\r\n                        widgetItem.view.remove();\r\n                    }\r\n                });\r\n                this.widgets = [];\r\n\r\n                // remove all widgets at once from gridstack\r\n                if (callback) {\r\n                    callback();\r\n                }\r\n            } else {\r\n                if (callback) {\r\n                    callback();\r\n                }\r\n            }\r\n        }\r\n\r\n        createComponentView(widgetItem, callback) {\r\n            let componentModel = widgetItem.model.get(\"component\"),\r\n                view,\r\n                selectedDocument;\r\n\r\n            selectedDocument = this.getSelectedDocument();\r\n\r\n            this.listenToOnce(componentModel, \"componentLoaded\", () => {\r\n                widgetItem.model.trigger(\"componentLoaded\");\r\n            });\r\n\r\n            view = new ComponentView({\r\n                model: componentModel,\r\n                callback: callback,\r\n                dashboardAppModel: this.dashboardAppModel,\r\n                dashboardViewModel: this.dashboardViewModel,\r\n                deltaClient: this.dashboardAppModel.get(\"isLite\") ? DashClient : DeltaClientLib,\r\n                docViewModel: selectedDocument.get(\"viewState\"),\r\n                docDataModel: selectedDocument.get(\"data\"),\r\n                quickView: this.quickView,\r\n                websiteUrl: this.websiteUrl,\r\n                widgetId: widgetItem.widgetId,\r\n            });\r\n\r\n            widgetItem.view = view;\r\n\r\n            if (view.model) {\r\n                widgetItem.$widget.attr(\"data-componentid\", view.model.get(\"key\"));\r\n                widgetItem.$remove.attr(\"title\", view.getComponentName());\r\n            }\r\n\r\n            return view;\r\n        }\r\n\r\n        createNewComponent(componentId: string, appKey: string, widget: Widget) {\r\n            const component = new Component({}, {}, widget);\r\n            component.set({\r\n                definitionId: componentId,\r\n                key: appKey,\r\n            });\r\n\r\n            return component;\r\n        }\r\n\r\n        deselectCurrentWidget() {\r\n            this.dashboardViewModel.set(\"selectedWidget\", null);\r\n            this.dashboardViewModel.set(\"selectedWidgetView\", null, { silent: true });\r\n        }\r\n\r\n        disableWidgetSelect(e?: any) {\r\n            //e, ui, $widget) {\r\n            if (e && e.stopPropagation) {\r\n                e.stopPropagation();\r\n            }\r\n            this.ignoreWidgetSelect = true;\r\n        }\r\n\r\n        enableWidgetSelect() {\r\n            // (e, ui, $widget) {\r\n            this.ignoreWidgetSelect = false;\r\n        }\r\n\r\n        findWidgetItem(widgetId) {\r\n            if (!widgetId) return null;\r\n\r\n            // find item in widgets\r\n            return _.find(this.widgets, function(i) {\r\n                return i.widgetId === widgetId;\r\n            });\r\n        }\r\n\r\n        getAppKey(componentDefinition) {\r\n            let appKey = componentDefinition.get(\"appKey\");\r\n\r\n            if (componentDefinition.get(\"user\") && !appKey.match(/^(?:[a-z]+:)?\\/\\/|^\\//)) {\r\n                // user component with relative path - remove .js suffix so requirejs uses baseUrl settings\r\n                appKey = appKey.replace(/\\.js$/, \"\");\r\n            }\r\n\r\n            return appKey;\r\n        }\r\n\r\n        getSafeDragNDropHandler(fn) {\r\n            return function(e) {\r\n                // console.log(\"IK ComponentDropView.getSafeDragNDropHandler\", _.now(), fn.name, arguments);\r\n                return this.isDragValid() || this.isDraggingSupportedFile(e)\r\n                    ? fn.apply(this, arguments)\r\n                    : false;\r\n            }.bind(this);\r\n        }\r\n\r\n        getSelectedDocument() {\r\n            return this.dashboardAppModel\r\n                .get(\"documents\")\r\n                .get(this.dashboardViewModel.get(\"selectedDocumentId\"));\r\n        }\r\n\r\n        getWidgetClass(ix?: number | null) {\r\n            return this.widgetClass;\r\n        }\r\n\r\n        isDragValid() {\r\n            // using api.isBuildMode not enough!\r\n            return this.dashboardAppModel.has(\"draggedComponentId\") && !this.quickView;\r\n        }\r\n\r\n        isDraggingSupportedFile(e) {\r\n            return (\r\n                !!e.originalEvent.dataTransfer &&\r\n                _.includes(e.originalEvent.dataTransfer.types, \"Files\") &&\r\n                !this.quickView &&\r\n                // IE doesn't expose filenames apart from drop event\r\n                (e.originalEvent.dataTransfer.items === undefined ||\r\n                    _.some(e.originalEvent.dataTransfer.items, function(file) {\r\n                        return _.includes([\"application/json\", \"text/xml\"], file.type);\r\n                    }))\r\n            );\r\n        }\r\n\r\n        onBuildModeChanged(model, value, options: any) {\r\n            this.switchBuildMode(this.dashboardViewModel.get(\"buildMode\"), options.userInitiated);\r\n        }\r\n\r\n        onDragEnter(e) {\r\n            // console.log(\"IK ComponentDropView.onDragEnter\", _.now());\r\n            if (this.isDragValid() && this.userCan(\"addNew\")) {\r\n                this.$el.addClass(\"drop-target\");\r\n            }\r\n\r\n            // preventDefault + stopPropagation\r\n            return false;\r\n        }\r\n\r\n        onDragLeave(e) {\r\n            // console.log(\"IK ComponentDropView.onDragLeave\", _.now());\r\n            if (this.isDragValid()) {\r\n                this.$el.removeClass(\"drop-target\");\r\n            }\r\n        }\r\n\r\n        onDragOver(e) {\r\n            // console.log(\"IK ComponentDropView.onDragOver\", _.now());\r\n            if (this.isDragValid() && !this.$el.hasClass(\"drop-target\")) {\r\n                this.$el.addClass(\"drop-target\");\r\n            }\r\n\r\n            // preventDefault + stopPropagation\r\n            return false;\r\n        }\r\n\r\n        onDrop(e) {\r\n            // console.log(\"IK ComponentDropView.onDrop\", _.now());\r\n            let componentDefinition, componentId, widgetId, widgetItem;\r\n\r\n            if (this.isDragValid()) {\r\n                this.$el.removeClass(\"drop-target\");\r\n\r\n                if (e.originalEvent.dataTransfer) {\r\n                    componentId = e.originalEvent.dataTransfer.getData(\"text\");\r\n                }\r\n\r\n                if (!componentId) return false;\r\n\r\n                componentDefinition = this.dashboardAppModel.get(\"components\").get(componentId);\r\n                widgetId = $(e.currentTarget)\r\n                    .find(\".component-drop-widget\")\r\n                    .first()\r\n                    .attr(\"data-widgetid\");\r\n\r\n                if (!componentDefinition) return false; // Invalid Drop Object\r\n\r\n                if (widgetId) {\r\n                    // use existing widget\r\n                    widgetItem = this.findWidgetItem(widgetId);\r\n\r\n                    // deselect current widget so we can reselect the new one\r\n                    this.deselectCurrentWidget();\r\n                }\r\n\r\n                if (widgetItem) {\r\n                    this.addComponentToWidget(widgetItem.model, componentId, true);\r\n                } else {\r\n                    this.addNewWidget(\r\n                        new Widget({}, {}, this.widgetsCollection),\r\n                        componentId,\r\n                        false,\r\n                    );\r\n                }\r\n            }\r\n\r\n            // preventDefault + stopPropagation\r\n            return false;\r\n        }\r\n\r\n        onRemoveWidget(widgetModel) {\r\n            this.widgetsCollection.commandRemove(widgetModel);\r\n        }\r\n\r\n        onResizeStart() {\r\n            _.each(this.widgets, function(widgetItem) {\r\n                widgetItem.view.onResizeStart && widgetItem.view.onResizeStart(true);\r\n            });\r\n        }\r\n\r\n        onResize(resizePanels?: boolean) {\r\n            _.each(this.widgets, function(widgetItem) {\r\n                widgetItem.view.onResize && widgetItem.view.onResize(true);\r\n            });\r\n        }\r\n\r\n        onResizeStop() {\r\n            _.each(this.widgets, function(widgetItem) {\r\n                widgetItem.view.onResizeStop && widgetItem.view.onResizeStop(true);\r\n            });\r\n\r\n            !this.userCan()\r\n                ? this.$el.find(\".component-build-view\").addClass(\"build-off\")\r\n                : this.$el.find(\".component-build-view\").removeClass(\"build-off\");\r\n        }\r\n\r\n        onSelectedWidgetChanged(model, value) {\r\n            // console.log(\"IK quickbase.componentdropview: onSelectedWidgetChanged\", this.cid);\r\n            let widgetItem;\r\n\r\n            if (this.selected) {\r\n                this.selected.$widget.removeClass(\"selected\");\r\n            }\r\n\r\n            if (value) {\r\n                widgetItem = this.findWidgetItem(value.id);\r\n\r\n                if (widgetItem) {\r\n                    this.selected = widgetItem;\r\n                    this.selected.$widget.addClass(\"selected\");\r\n                }\r\n            } else {\r\n                this.selected = null;\r\n            }\r\n        }\r\n\r\n        onSelectingWidget(model, id) {\r\n            if (model) {\r\n                this.onWidgetClick(null, id);\r\n                this.dashboardAppModel.set(\"pendingSelectionWidgetId\", null, { silent: true });\r\n            }\r\n        }\r\n\r\n        onWidgetClick(e, widgetId) {\r\n            // console.log(\"IK quickbase.componentdropview:onWidgetClick\", e, widgetId);\r\n            var widgetItem, widgetId;\r\n\r\n            // get widget id\r\n            if (e) {\r\n                widgetId = $(e.currentTarget).attr(\"data-widgetid\");\r\n            } else if (widgetId) {\r\n                widgetId = widgetId;\r\n            }\r\n\r\n            // find item\r\n            widgetItem = this.findWidgetItem(widgetId);\r\n\r\n            if (widgetItem && (widgetId || !$(e.target).is(widgetItem.$remove))) {\r\n                if (!this.ignoreWidgetSelect) {\r\n                    if (e && e.stopPropagation) {\r\n                        e.stopPropagation();\r\n                    }\r\n\r\n                    if (\r\n                        !(\r\n                            e &&\r\n                            $(e.target)\r\n                                .parent()\r\n                                .hasClass(\"QuickStart\")\r\n                        )\r\n                    ) {\r\n                        if (this.dashboardViewModel.get(\"selectedWidget\") === widgetItem.model) {\r\n                            this.dashboardViewModel.set(\"selectedWidget\", null);\r\n                            this.dashboardViewModel.set(\"selectedWidgetView\", null, {\r\n                                silent: true,\r\n                            });\r\n                        } else {\r\n                            this.dashboardViewModel.set(\"selectedWidget\", widgetItem.model);\r\n                            this.dashboardViewModel.set(\"selectedWidgetView\", widgetItem.view, {\r\n                                silent: true,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // beware of preventing default (using return false or e.preventDefault) ->\r\n            //  form would not submit, chekboxes stop working !\r\n            //  check this: https://issuetracker.firstderivatives.com/browse/KXAX-15933\r\n        }\r\n\r\n        onWidgetCollectionAdd(model: Widget, collection: WidgetCollection, options: any) {\r\n            this.addWidget(model, false, null);\r\n        }\r\n\r\n        onWidgetCollectionRemove(model: Widget, collection: WidgetCollection, options: any) {\r\n            this.removeWidget(model);\r\n        }\r\n\r\n        remove() {\r\n            this.clearWidgets();\r\n\r\n            return Backbone.View.prototype.remove.apply(this);\r\n        }\r\n\r\n        removeWidget(widgetModel) {\r\n            //find widget item\r\n            const widgetItem = _.find(this.widgets, { model: widgetModel });\r\n\r\n            if (widgetItem) {\r\n                if (this.selected && this.selected === widgetItem) {\r\n                    this.deselectCurrentWidget();\r\n                }\r\n\r\n                // remove from widgets array\r\n                this.widgets = _.without(this.widgets, widgetItem);\r\n\r\n                // hide widget background before removing the app\r\n                // has to be applied immediately\r\n                widgetItem.$widget.css({\r\n                    border: \"none\",\r\n                    background: \"none\",\r\n                    \"box-shadow\": \"none\",\r\n                    \"pointer-events\": \"none\",\r\n                });\r\n\r\n                // remove the app\r\n                if (widgetItem.view) {\r\n                    if (_.isFunction(widgetItem.view.remove)) {\r\n                        widgetItem.view.remove();\r\n                    }\r\n                }\r\n\r\n                // detach all events from view\r\n                widgetItem.$widget.off();\r\n                widgetItem.$widget.remove();\r\n            }\r\n        }\r\n\r\n        renderComponent(widgetItem, callback) {\r\n            const view = this.createComponentView(widgetItem, callback);\r\n\r\n            widgetItem.$widget.append(view.$el);\r\n            this.$el.append(widgetItem.$widget);\r\n        }\r\n\r\n        renderWidget(widgetModel) {\r\n            return $(\"<div/>\");\r\n        }\r\n\r\n        selectWidget(widgetItem) {\r\n            if (!this.ignoreWidgetSelect) {\r\n                this.dashboardViewModel.set(\"selectedWidget\", widgetItem.model);\r\n                this.dashboardViewModel.set(\"selectedWidgetView\", widgetItem.view, {\r\n                    silent: true,\r\n                });\r\n            }\r\n        }\r\n\r\n        setTheme(newTheme) {\r\n            _.each(this.widgets, function(widget) {\r\n                if (widget.view && widget.view.app && _.isFunction(widget.view.app.setTheme)) {\r\n                    widget.view.app.setTheme(newTheme);\r\n                }\r\n            });\r\n        }\r\n\r\n        showReplaceConfirmationDialog(agreedfn, widgetItem) {\r\n            const componentName = _.get(\r\n                this.dashboardAppModel\r\n                    .get(\"components\")\r\n                    .get(\r\n                        _.get(\r\n                            widgetItem,\r\n                            \"model.attributes.component.attributes.definitionId\",\r\n                            null,\r\n                        ),\r\n                    ),\r\n                \"attributes.componentName\",\r\n                \"\",\r\n            );\r\n\r\n            ConfirmDialog.ShowConfirm({\r\n                dialogTitle: \"Confirm Replace\",\r\n                renderTemplate: function() {\r\n                    return t(\r\n                        `Are you sure you would like to replace this ${componentName} component?`,\r\n                    );\r\n                },\r\n                callback: agreedfn,\r\n            });\r\n        }\r\n\r\n        switchBuildMode(newValue, userInitiated?: boolean) {\r\n            if (newValue) {\r\n                this.switchOnBuildMode(userInitiated);\r\n            } else {\r\n                this.switchOffBuildMode(userInitiated);\r\n            }\r\n        }\r\n\r\n        switchOffBuildMode(userInitiated?: boolean) {\r\n            this.disableWidgetSelect();\r\n\r\n            _.each(this.widgets, function(widgetItem) {\r\n                widgetItem.$widget && widgetItem.$widget.addClass(\"build-off\");\r\n            });\r\n        }\r\n\r\n        switchOnBuildMode(userInitiated?: boolean) {\r\n            this.enableWidgetSelect();\r\n\r\n            _.each(this.widgets, function(widgetItem) {\r\n                widgetItem.$widget && widgetItem.$widget.removeClass(\"build-off\");\r\n            });\r\n        }\r\n\r\n        userCan(action?: string) {\r\n            return this.dashboardViewModel.get(\"buildMode\") && !this.quickView;\r\n        }\r\n    }\r\n}\r\n","/*global $,_,Backbone,T*/\n/// <reference path=\"../templates/combined.ts\" />\n/// <reference path=\"../classes/log.ts\"/>\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class DocumentSelector extends Backbone.View<Backbone.Model> {\n        appModel = null;\n        availableHeight = 0;\n        debouncedRender: Function;\n        documentsList = null;\n        documentTypeMap = null;\n        select2: any;\n        showManage = false;\n        viewModel: Backbone.Model = null;\n        RECENT_DOCUMENT_COUNT = 3;\n\n        constructor(options) {\n            super(options);\n            this.appModel = options.appModel;\n            this.viewModel = options.viewModel;\n            this.showManage = options.showManage;\n            this.debouncedRender = _.debounce(this.render, 100);\n            this.initializeEvents();\n        }\n\n        initializeEvents() {\n            const docs = this.appModel.get(\"documents\");\n            this.listenTo(docs, \"reset\", this.onDocumentsReset);\n            this.listenTo(docs, \"add\", this.onDocumentsAdd);\n            this.listenTo(docs, \"remove\", this.onDocumentsRemove);\n            this.listenTo(\n                this.viewModel,\n                \"change:selectedDocumentId\",\n                this.onViewModelSelectedChanged,\n            );\n        }\n\n        blurSelect() {\n            // remove focus so keyboard shortcuts aren't triggered on this element\n            this.select2\n                .data(\"select2\")\n                .$container.find(\".select2-selection\")\n                .blur();\n        }\n\n        getDocuments() {\n            let other = [],\n                recent = [],\n                starred = [];\n\n            this.documentTypeMap = {};\n\n            const sortedByDate = _.sortBy(\n                this.appModel.get(\"documents\").map(d => d.attributes),\n                d => -Date.parse(d[\"lastUpdateDate\"]),\n            );\n\n            // Split documents by starred/recent/other\n            sortedByDate.forEach(d => {\n                // Do not show Draft dashboards in the Viewer\n                if (!this.appModel.get(\"quickview\") || d.name.indexOf(\"Draft:\") !== 0) {\n                    if (_.includes(d[\"tags\"], \"starred\")) {\n                        starred.push(d);\n                        this.documentTypeMap[d.id] = \"starred\";\n                    } else if (recent.length < this.RECENT_DOCUMENT_COUNT) {\n                        recent.push(d);\n                        this.documentTypeMap[d.id] = \"recent\";\n                    } else {\n                        other.push(d);\n                        this.documentTypeMap[d.id] = \"other\";\n                    }\n                }\n            });\n\n            // Sort starred and other alphabetically\n            starred = _.sortBy(starred, d => d[\"name\"].toLowerCase());\n            other = _.sortBy(other, d => d[\"name\"].toLowerCase());\n\n            this.documentsList = recent.concat(starred, other);\n        }\n\n        onDocumentsAdd(model) {\n            this.listenTo(model, \"change:name\", this.render);\n            this.$el.find(\"select\").select2(\"close\");\n            this.render();\n        }\n\n        onDocumentsRemove(model) {\n            this.stopListening(model);\n            this.render();\n        }\n\n        onDocumentsReset(collection, options) {\n            const self = this;\n\n            // stop listening old\n            _.each(options.previousModels, function(model) {\n                self.stopListening(model);\n            });\n\n            // start listening new\n            collection.each(function(model) {\n                self.listenTo(model, \"change:name\", self.render);\n            });\n\n            this.render();\n        }\n\n        onResize() {\n            this.availableHeight = $(\"body\").height() * 0.4;\n        }\n\n        onViewModelSelectedChanged(model, value) {\n            if (value !== this.$el.find(\"select\").val()) {\n                this.selectDocument(value);\n            }\n        }\n\n        render() {\n            const self = this;\n\n            this.getDocuments();\n\n            this.$el.html(T.DocumentSelector(this.documentsList));\n\n            // create select menu\n            this.select2 = this.$el.find(\"select\").select2({\n                language: {\n                    noResults: function() {\n                        return \"No Dashboards found\";\n                    },\n                },\n                templateResult(doc) {\n                    let $result;\n\n                    switch (self.documentTypeMap[doc.id]) {\n                        case \"starred\":\n                            $result = $(\n                                '<span><i class=\"dashboard-selector-icon fa fa-star\" title=\"Starred\"></i>' +\n                                    _.escape(doc.text) +\n                                    \"</span>\",\n                            );\n                            break;\n                        case \"recent\":\n                            $result = $(\n                                '<span><i class=\"dashboard-selector-icon fa fa-clock-o\" title=\"Recent\"></i>' +\n                                    _.escape(doc.text) +\n                                    \"</span>\",\n                            );\n                            break;\n                        default:\n                            $result = $(\"<span>\" + _.escape(doc.text) + \"</span>\");\n                    }\n\n                    return $result;\n                },\n                //'templateResult': function (doc) {\n                //    var $icon,\n                //        $preview,\n                //        selectedDocument,\n                //        thumb;\n\n                //    selectedDocument = self.appModel.get('documents').get(doc.id);\n                //    if (selectedDocument) {\n                //        thumb = selectedDocument.get('thumb');\n\n                //        if (thumb) {\n                //            $icon = $('<span class=\"dashboard-selector-icon\" style=\"background-image: url(' + thumb + ');\"></span><span class=\"dashboard-selector-text\">' + doc.text + '</span>');\n                //        } else {\n                //            $icon = $('<span class=\"dashboard-selector-icon\";\"></span><span class=\"dashboard-selector-text\">' + doc.text + '</span>');\n                //        }\n                //    }\n\n                //    return $icon;\n                //},\n                theme: \"document-selector\",\n                width: \"225px\",\n            });\n            this.onResize();\n\n            this.select2.on(\"select2:open\", () => {\n                const $dropdown = $(\".select2-container--document-selector .select2-dropdown\");\n\n                // if show manage and link not already added\n                if (this.showManage && $dropdown.find(\".manage\").length == 0) {\n                    const $manage = $(\n                        '<a class=\"manage\" title=\"' +\n                            t(\"Manage Dashboards\") +\n                            '\">' +\n                            t(\"Manage Dashboards\") +\n                            \"</a>\",\n                    );\n                    $manage\n                        .button({\n                            icons: {\n                                secondary: \"fa fa-share-square-o\",\n                            },\n                        })\n                        .click(() => {\n                            $manage.removeClass(\"ui-state-hover\");\n                            this.select2.select2(\"close\");\n                            this.trigger(\"manage\");\n                        });\n\n                    $dropdown.append(\"<hr>\");\n                    $dropdown.append($manage);\n                }\n\n                // set height\n                $dropdown\n                    .find(\".select2-results > ul\")\n                    .css(\"max-height\", this.availableHeight + \"px\");\n\n                //placeholder attribute prevents IE from invoking blur() if no value is -\n                //present in search field (known IE bug:https://github.com/select2/select2/issues/3300)\n                if (!Tools.isIE()) {\n                    $(\".select2-search__field\").attr(\"placeholder\", \"Search...\");\n                }\n            });\n\n            this.select2.on(\"select2:close\", function() {\n                _.defer(function() {\n                    self.blurSelect();\n                });\n            });\n\n            this.select2.on(\"select2:select\", function() {\n                const value = self.select2.val();\n\n                if (value !== self.viewModel.get(\"selectedDocumentId\")) {\n                    try {\n                        // can't pass callback to navigate so setting it here instead\n                        self.appModel.get(\"router\").onNavCancel = function() {\n                            // return to initial selection\n                            self.select2\n                                .val(self.viewModel.get(\"selectedDocumentId\"))\n                                .trigger(\"change\");\n                        };\n                        self.appModel.get(\"router\").navigate(value, { trigger: true });\n                    } catch (ex) {\n                        Log.Error(\"Select Document Error:\", ex);\n                    }\n                }\n\n                self.blurSelect();\n            });\n\n            this.selectDocument(this.viewModel.get(\"selectedDocumentId\"));\n\n            //this.$el.find(\"input\").attr(\"readonly\", true);\n\n            return this;\n        }\n\n        selectDocument(value) {\n            const $select = this.$el.find(\"select\"),\n                selectedDocument = this.appModel.get(\"documents\").get(value);\n\n            $select.val(value).trigger(\"change\");\n\n            if (selectedDocument) {\n                this.$el.find(\"input\").val(selectedDocument.get(\"name\"));\n            }\n        }\n    }\n}\n","/*global _,$,Backbone, window*/\r\n/// <reference path=\"../models/component.ts\" />\r\n/// <reference path=\"../models/widget.ts\" />\r\n/// <reference path=\"../templates/combined.ts\" />\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class DocumentView extends Backbone.View<QuickBase.Document> {\r\n        appModel: Backbone.Model;\r\n        screenView: ComponentDropView;\r\n        viewModel: DocumentViewModel;\r\n        model: QuickBase.Document;\r\n        quickView: boolean;\r\n\r\n        cssClasses = null;\r\n        customCss = null;\r\n        $customCss = null;\r\n        popups: Array<PopupView> = [];\r\n\r\n        prevCssViewModel = null;\r\n\r\n        constructor(options) {\r\n            super(options);\r\n\r\n            // assign props\r\n            this.appModel = options.appModel;\r\n            this.viewModel = options.viewModel;\r\n\r\n            this.quickView = options.quickView;\r\n\r\n            // upgrade document\r\n            this.model.upgrade();\r\n\r\n            // render\r\n            this.el.className = \"document-view\";\r\n            this.$el.html(T.DocumentView({}));\r\n\r\n            // events\r\n            this.initializeEvents();\r\n\r\n            //add custom styling\r\n            this.applyCustomCss();\r\n            this.onCssClassesChanged();\r\n\r\n            // select screen\r\n            this.onSelectedScreenChanged();\r\n\r\n            // if quickview, popups will be created after viewStatesParsed is triggered\r\n            if (!this.quickView) {\r\n                this.onResetPopups();\r\n            }\r\n        }\r\n\r\n        initializeEvents() {\r\n            this.listenTo(this.model.get(\"popups\"), \"reset viewStatesParsed\", this.onResetPopups);\r\n            this.listenTo(this.model.get(\"popups\"), \"add\", this.onAddPopup);\r\n            this.listenTo(this.model.get(\"popups\"), \"remove\", this.onRemovePopup);\r\n\r\n            this.listenTo(this.model, \"change:advancedCss\", this.applyCustomCss);\r\n            this.listenTo(this.model, \"change:cssClasses\", this.onCssClassesChanged);\r\n\r\n            this.listenTo(this.viewModel, \"change:selectedScreenId\", this.onSelectedScreenChanged);\r\n\r\n            this.listenTo(this.viewModel, \"change:DashboardTheme\", function(e) {\r\n                this.applyTheme(e.get(\"DashboardTheme\"));\r\n            });\r\n\r\n            $(window).on(\"keydown\", this.onKeyDown.bind(this));\r\n        }\r\n\r\n        applyCustomCss() {\r\n            const newCustomCss = this.model.get(\"advancedCss\");\r\n\r\n            if (newCustomCss) {\r\n                if (newCustomCss !== this.customCss) {\r\n                    if (!this.$customCss || !this.$customCss.length) {\r\n                        this.$customCss = $(\"<style />\", {\r\n                            documentid: this.model.id,\r\n                            html: newCustomCss,\r\n                            type: \"text/css\",\r\n                        }).appendTo(document.head);\r\n                    } else {\r\n                        this.$customCss.html(newCustomCss);\r\n                    }\r\n                    this.customCss = newCustomCss;\r\n                }\r\n            } else {\r\n                if (this.$customCss) {\r\n                    this.$customCss.remove();\r\n                    this.$customCss = null;\r\n                    this.customCss = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        applyCssClasses(newCssClasses) {\r\n            if (newCssClasses) {\r\n                if (_.isArray(newCssClasses)) {\r\n                    newCssClasses = _.reduce(newCssClasses, function(classList, value) {\r\n                        return classList + \" \" + value;\r\n                    });\r\n                }\r\n\r\n                if (newCssClasses !== this.cssClasses) {\r\n                    this.$el.removeClass(this.cssClasses);\r\n                    this.$el.addClass(newCssClasses);\r\n                    this.cssClasses = newCssClasses;\r\n                }\r\n            } else {\r\n                this.$el.removeClass(this.cssClasses);\r\n                this.cssClasses = null;\r\n            }\r\n        }\r\n\r\n        applyDataSources() {\r\n            _.each(this.model.get(\"data\").flatten(), function(dataSource) {\r\n                if (dataSource.isMapping()) {\r\n                    dataSource.apply();\r\n                }\r\n            });\r\n        }\r\n\r\n        //apply dashboard theme to existing widgets\r\n        applyTheme(newTheme) {\r\n            const self = this;\r\n            if (this.screenView) {\r\n                _.each(this.screenView.widgets, function(widget) {\r\n                    self.applyThemeToWidget(widget, newTheme);\r\n                });\r\n            }\r\n        }\r\n\r\n        applyThemeToWidget(widget, newTheme) {\r\n            if (widget.view.app && widget.view.app.setTheme) {\r\n                widget.view.app.setTheme(newTheme);\r\n            }\r\n        }\r\n\r\n        changeScreen(model) {\r\n            if (this.screenView) {\r\n                this.screenView.remove();\r\n            }\r\n\r\n            const $div = $(document.createElement(\"div\"));\r\n            $div.addClass(\"screen-view\");\r\n            $div.appendTo(this.$el.find(\".screen-view-div\"));\r\n\r\n            // reset variable\r\n            this.screenView = null;\r\n\r\n            require([\"Panel\"], function(AppModule) {\r\n                // ensure screen hasn't been added already\r\n                if (!this.screenView) {\r\n                    this.applyDataSources();\r\n                    this.passScreenPropertiesToDocumentModel(model, this.model);\r\n\r\n                    this.screenView = new AppModule({\r\n                        el: $div,\r\n                        model: model,\r\n                        dashboardAppModel: this.appModel,\r\n                        documentModel: this.model,\r\n                        dashboardViewModel: this.viewModel,\r\n                        //settingsModel: new Widget(),\r\n                        websiteUrl: this.appModel.get(\"websiteUrl\"),\r\n                        //componentModel: new Component(),\r\n                        DeltaClientLib: this.deltaClient,\r\n                        api: {},\r\n                        isBasePanel: true,\r\n                        quickView: this.quickView,\r\n                    });\r\n                }\r\n            }.bind(this));\r\n        }\r\n\r\n        createPopup(model): PopupView {\r\n            return new PopupView({\r\n                viewModel: this.viewModel,\r\n                appModel: this.appModel,\r\n                container: this.$el,\r\n                quickView: this.quickView,\r\n                model: model,\r\n            });\r\n        }\r\n\r\n        onAddPopup() {\r\n            this.popups.push(this.createPopup(arguments[0]));\r\n        }\r\n\r\n        onRemovePopup(popupModel) {\r\n            const popupView = _.find(this.popups, popup => {\r\n                return popup.model.get(\"id\") === popupModel.get(\"id\");\r\n            });\r\n\r\n            this.popups.splice(this.popups.indexOf(popupView), 1);\r\n            popupView.remove();\r\n        }\r\n\r\n        onResetPopups() {\r\n            const self = this;\r\n\r\n            _.each(this.popups, function(popup) {\r\n                popup.remove();\r\n            });\r\n\r\n            this.popups = [];\r\n\r\n            this.model.get(\"popups\").each(function(model) {\r\n                self.popups.push(self.createPopup(model));\r\n            });\r\n        }\r\n\r\n        onKeyDown(e: number): void {\r\n            const keyCode = e[\"keyCode\"];\r\n            if (e[\"ctrlKey\"] || e[\"metaKey\"]) {\r\n                const shortcuts = this.model.get(\"shortcuts\");\r\n                const keyString = String.fromCharCode(keyCode).toLowerCase();\r\n                const shortcut = _.find(shortcuts, x => x.Key === keyString);\r\n\r\n                if (shortcut && shortcut.Data) {\r\n                    shortcut.Data.forceExecute();\r\n                }\r\n            }\r\n        }\r\n\r\n        onCssClassesChanged() {\r\n            let newCssClasses = this.model.get(\"cssClasses\");\r\n\r\n            // save model triggers change with server values {_dashboardsType & value}\r\n            if (newCssClasses && newCssClasses._dashboardsType) {\r\n                return;\r\n            }\r\n\r\n            if (this.prevCssViewModel) {\r\n                this.stopListening(this.prevCssViewModel);\r\n                this.prevCssViewModel = null;\r\n            }\r\n\r\n            if (newCssClasses instanceof Backbone.Model) {\r\n                this.listenTo(newCssClasses, \"change:value\", function(model, value) {\r\n                    this.applyCssClasses(value);\r\n                });\r\n                this.prevCssViewModel = newCssClasses;\r\n                newCssClasses = newCssClasses.get(\"value\");\r\n            }\r\n            this.applyCssClasses(newCssClasses);\r\n        }\r\n\r\n        onResize() {\r\n            this.screenView && this.screenView.onResize(true);\r\n        }\r\n\r\n        onSelectedScreenChanged() {\r\n            let selectedScreenId,\r\n                screen,\r\n                ok = false;\r\n\r\n            // get selected screen id\r\n            selectedScreenId = this.viewModel.get(\"selectedScreenId\");\r\n\r\n            if (selectedScreenId) {\r\n                // get screen\r\n                screen = this.model.get(\"screens\").get(selectedScreenId);\r\n\r\n                if (screen) {\r\n                    // set screen\r\n                    this.changeScreen(screen);\r\n                    ok = true;\r\n                }\r\n            }\r\n\r\n            if (!ok) {\r\n                // try to set default screen\r\n                screen = this.model.get(\"screens\").findWhere({ isDefault: true });\r\n                if (screen) {\r\n                    // select this one\r\n                    this.viewModel.set(\"selectedScreenId\", screen.id);\r\n                } else {\r\n                    // try first\r\n                    screen = this.model.get(\"screens\").first();\r\n                    if (screen) {\r\n                        screen.set(\"isDefault\", true);\r\n                        // select this one\r\n                        this.viewModel.set(\"selectedScreenId\", screen.id);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        passScreenPropertiesToDocumentModel(screenModel, documentModel) {\r\n            let relativeHeight = screenModel.get(\"relativeHeight\"),\r\n                rowCount = screenModel.get(\"rowCount\") || 24,\r\n                rowHeight = screenModel.get(\"rowHeight\") || 25,\r\n                updatedConfig;\r\n\r\n            // use document's relative height, if screen doesn't have it\r\n            if (relativeHeight === undefined) {\r\n                relativeHeight = documentModel.get(\"relativeHeight\");\r\n                if (relativeHeight === undefined) {\r\n                    //brand new dashboard: fill height is on\r\n                    relativeHeight = true;\r\n                }\r\n            }\r\n\r\n            updatedConfig = {\r\n                relativeHeight: relativeHeight,\r\n                rowCount: rowCount,\r\n                rowHeight: rowHeight,\r\n            };\r\n\r\n            //update models with correct values\r\n            screenModel.set(updatedConfig);\r\n            documentModel.set(\r\n                _.extend(updatedConfig, {\r\n                    colCount: screenModel.get(\"colCount\"),\r\n                    floatable: screenModel.get(\"floatable\"),\r\n                }),\r\n            );\r\n\r\n            //let property inspector know to refresh layout\r\n            documentModel.trigger(\"basePanelLayoutChanged\");\r\n        }\r\n\r\n        pasteWidget(widgetModel) {\r\n            if (this.screenView && !this.quickView) {\r\n                // TODO screenview, panel etc should use a common interface\r\n                (this.screenView as any).pasteWidget(widgetModel);\r\n            }\r\n        }\r\n\r\n        remove() {\r\n            let data;\r\n\r\n            this.stopListening();\r\n\r\n            if (this.screenView) {\r\n                this.screenView.remove();\r\n            }\r\n\r\n            _.each(this.popups, function(popup) {\r\n                popup.remove();\r\n            });\r\n\r\n            if (this.$customCss) {\r\n                this.$customCss.remove();\r\n            }\r\n\r\n            // data model\r\n            data = this.model.get(\"data\");\r\n            if (data) {\r\n                if (data.stopPolledQueries) {\r\n                    data.stopPolledQueries();\r\n                }\r\n\r\n                if (data.removeSubscriptions) {\r\n                    data.removeSubscriptions();\r\n                }\r\n            }\r\n\r\n            $(window).off(\"keydown\");\r\n\r\n            return Backbone.View.prototype.remove.call(this);\r\n        }\r\n    }\r\n}\r\n","/*globals Backbone,_,$,console,DataModelPropertiesView,TreeView,T,t */\r\n/// <reference path=\"../views/ChangePasswordDialog.ts\" />\r\n/// <reference path=\"../lib/i18n.d.ts\" />\r\n/// <reference path=\"../templates/combined.ts\" />\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class LoginDialog extends Backbone.View<Backbone.Model> {\r\n        tagName: \"form\";\r\n\r\n        $dialog: JQuery;\r\n        $errorDialog: JQuery;\r\n\r\n        $loginBtn: JQuery;\r\n        $backBtn: JQuery;\r\n        $resetBtn: JQuery;\r\n\r\n        $buttonPanel: JQuery;\r\n        $buttonText: JQuery;\r\n        $userLoginForm: JQuery;\r\n        $forgotPasswordForm: JQuery;\r\n        $forgotPasswordBtn: JQuery;\r\n        $passwordResetInfo: JQuery;\r\n        $recoveryResponse: JQuery;\r\n        $resetUserName: JQuery;\r\n        $restPasswordError: JQuery;\r\n\r\n        appModel;\r\n        clicked;\r\n        boundCapsLockFn;\r\n        errorMessage: string;\r\n        container;\r\n        doLogin: () => void;\r\n        changePasswordDialog: ChangePasswordDialog;\r\n\r\n        constructor(options) {\r\n            super(options);\r\n\r\n            this.errorMessage = options.errorMessage;\r\n            this.appModel = options.appModel;\r\n            this.container = options.container;\r\n            this.doLogin = options.doLogin;\r\n\r\n            this.container.html(this.render().$el);\r\n\r\n            this.boundCapsLockFn = $.proxy(this.onWindowCapsLockClick, this);\r\n\r\n            this.initializeEvents();\r\n        }\r\n        /**\r\n         * Function checks if CapsLock is on jquery key event\r\n         */\r\n        static checkCapslockOn(e: Event): boolean {\r\n            const IS_MAC: boolean = /Mac/.test(navigator.platform),\r\n                charCode: number = e[\"charCode\"],\r\n                shiftKey: boolean = e[\"shiftKey\"];\r\n\r\n            let capsLock = false;\r\n\r\n            if (charCode >= 97 && charCode <= 122) {\r\n                capsLock = shiftKey;\r\n            } else if (charCode >= 65 && charCode <= 90 && !(shiftKey && IS_MAC)) {\r\n                capsLock = !shiftKey;\r\n            } // Other chars but ascii\r\n            else if (charCode > 122 && e[\"getModifierState\"](\"CapsLock\")) {\r\n                capsLock = true;\r\n            }\r\n\r\n            return capsLock;\r\n        }\r\n\r\n        onWindowCapsLockClick(e: Event): void {\r\n            if (e[\"which\"] === 20) {\r\n                if (e[\"getModifierState\"](\"CapsLock\")) {\r\n                    this.setErrorMessage(\"capsLock\", \"#ffc800\");\r\n                } else {\r\n                    this.$el.find(\".loginErrorPanel\").css(\"visibility\", \"hidden\");\r\n                }\r\n            }\r\n        }\r\n\r\n        render() {\r\n            let self = this,\r\n                errorMessage;\r\n\r\n            this.$el.html(T.LoginDialog({}));\r\n\r\n            // add blur\r\n            $(\".quick-base\").addClass(\"disturbed\");\r\n            // Pause Loading Animation\r\n            $(document)\r\n                .find(\".loadingScreen svg\")\r\n                .hide();\r\n            $(document)\r\n                .find(\".loading-info svg\")\r\n                .hide();\r\n\r\n            self.$userLoginForm = this.$el.find(\".user-login-form\");\r\n            self.$forgotPasswordForm = this.$el.find(\".forgot-password-form\");\r\n            self.$forgotPasswordBtn = this.$el.find(\".forgot-info\");\r\n            self.$passwordResetInfo = this.$el.find(\".password-reset-info\");\r\n            self.$recoveryResponse = this.$el.find(\".recovery-response\");\r\n            self.$resetUserName = this.$el.find(\".reset-username\");\r\n\r\n            this.$restPasswordError = this.$el.find(\".reset-password-error\");\r\n\r\n            self.$dialog = this.$el.find(\".login-form\");\r\n\r\n            self.$buttonPanel = this.$el.find(\".login-button-panel\");\r\n            // get the login btn\r\n            this.$el.find(\".login-btn\").button({\r\n                label: t(\"Login\"),\r\n                icons: {\r\n                    primary: \"fa fa-check\",\r\n                },\r\n            });\r\n\r\n            this.$el.find(\".back-btn\").button({\r\n                label: t(\"Back\"),\r\n                icons: {\r\n                    primary: \"fa fa-arrow-left\",\r\n                },\r\n            });\r\n\r\n            this.$el.find(\".reset-btn\").button({\r\n                icons: {\r\n                    primary: \"fa fa-undo\",\r\n                },\r\n                label: t(\"Reset\"),\r\n            });\r\n\r\n            self.$loginBtn = this.$el.find(\".login-btn\");\r\n\r\n            self.$backBtn = this.$el.find(\".back-btn\");\r\n            self.$backBtn.hide();\r\n            self.$resetBtn = this.$el.find(\".reset-btn\");\r\n            self.$resetBtn.hide();\r\n\r\n            if ((errorMessage = $.cookie(\"deltaLoginError\"))) {\r\n                $.removeCookie(\"deltaLoginError\", { path: \"/\" });\r\n            } else {\r\n                errorMessage = this.errorMessage;\r\n            }\r\n\r\n            if (errorMessage) {\r\n                this.setErrorMessage(errorMessage);\r\n            }\r\n\r\n            return this;\r\n        }\r\n\r\n        initializeEvents() {\r\n            const self = this;\r\n            //\r\n            self.$el.find(\".password, .username\").on(\"keydown\", (e: JQuery.Event) => {\r\n                if (e.which === 13) {\r\n                    self.onLoginButtonClick(e);\r\n                }\r\n            });\r\n\r\n            window.addEventListener(\"keydown\", this.boundCapsLockFn, true);\r\n\r\n            // Key Press has different event state handle Caps Lock msg\r\n            self.$el.find(\".password\").on(\"keypress\", (e: JQuery.Event) => {\r\n                if (LoginDialog.checkCapslockOn(e.originalEvent)) {\r\n                    self.setErrorMessage(\"capsLock\", \"#ffc800\");\r\n                } else {\r\n                    self.$el.find(\".loginErrorPanel\").css(\"visibility\", \"hidden\");\r\n                }\r\n            });\r\n\r\n            self.$forgotPasswordBtn.on(\"click\", function() {\r\n                self.showForgotPasswordForm();\r\n            });\r\n\r\n            self.$loginBtn.on(\"click\", function(e) {\r\n                e.preventDefault();\r\n                self.onLoginButtonClick(e);\r\n            });\r\n\r\n            self.$backBtn.on(\"click\", function(e) {\r\n                e.preventDefault();\r\n                self.hideForgotPasswordForm();\r\n            });\r\n            self.$resetBtn.on(\"click\", function(e) {\r\n                e.preventDefault();\r\n                self.onResetButtonClick();\r\n            });\r\n            // process login success callback only once\r\n            $(DeltaClientLib).one(\"DeltaClientLogin\", $.proxy(self.onLoginSuccess, self));\r\n        }\r\n\r\n        clickLoginButton() {\r\n            this.onLoginButtonClick({\r\n                currentTarget: $(\".login-button-panel .login-btn\"),\r\n            });\r\n        }\r\n\r\n        onLoginButtonClick(e) {\r\n            let self = this,\r\n                user,\r\n                password,\r\n                authJSON;\r\n\r\n            if (!this.clicked) {\r\n                user = this.$el.find(\".username\").val();\r\n                password = this.$el.find(\".password\").val();\r\n                this.$buttonText = $(e.currentTarget).find(\".ui-button-text\");\r\n\r\n                if (!user || !password) {\r\n                    this.setErrorMessage(\"Please enter your username and password.\");\r\n                    e.preventDefault();\r\n                    return;\r\n                }\r\n\r\n                this.setErrorMessage(\"Connecting please wait...\", \"#fff\");\r\n                this.clicked = true;\r\n\r\n                if (e) {\r\n                    $(e.currentTarget)\r\n                        .find(\".ui-button-icon-primary\")\r\n                        .removeClass(\"fa-check\");\r\n                    $(e.currentTarget)\r\n                        .find(\".ui-button-icon-primary\")\r\n                        .css({\r\n                            width: \"auto\",\r\n                            height: \"auto\",\r\n                        });\r\n                    $(e.currentTarget)\r\n                        .find(\".ui-button-icon-primary\")\r\n                        .addClass(\"fa-spinner fa-pulse\");\r\n                    this.$buttonText.text(t(\"wait\") + \"...\");\r\n                }\r\n\r\n                this.$el.find(\"input\").attr(\"disabled\", \"disabled\");\r\n\r\n                //send user data to the backend\r\n                _.isFunction(self.doLogin) &&\r\n                    self.doLogin(user, password, function(e) {\r\n                        self.setErrorMessage(e);\r\n                    });\r\n            }\r\n        }\r\n\r\n        onLoginSuccess() {\r\n            const self = this;\r\n\r\n            self.appModel.set(\"userName\", DeltaClientLib.deltaClient.user());\r\n\r\n            // set deltaToken\r\n            $.cookie(\"deltaToken\", DeltaClientLib.deltaClient.tokenKey(), {\r\n                expires: 30,\r\n                path: \"/\",\r\n            });\r\n\r\n            //$.cookie(\"dashauth\", JSON.stringify(authJSON));\r\n            $(\".quick-base\").removeClass(\"disturbed\");\r\n\r\n            self.onRemove();\r\n        }\r\n\r\n        onRemove() {\r\n            this.$loginBtn.off();\r\n            this.$backBtn.off();\r\n            this.$resetBtn.off();\r\n            this.$forgotPasswordBtn.off();\r\n            // Restart Loading Screen Animation\r\n            $(document)\r\n                .find(\".loadingScreen svg\")\r\n                .show();\r\n            $(document)\r\n                .find(\".loading-info svg\")\r\n                .show();\r\n\r\n            $(DeltaClientLib).off(\"DeltaClientLogin\", this.onLoginSuccess);\r\n\r\n            window.removeEventListener(\"keydown\", this.boundCapsLockFn, true);\r\n\r\n            this.remove();\r\n        }\r\n\r\n        onResetButtonClick() {\r\n            let self = this,\r\n                userName;\r\n\r\n            this.$restPasswordError.css(\"visibility\", \"hidden\");\r\n\r\n            this.$userLoginForm.removeClass(\"open\");\r\n            userName = this.$resetUserName.val();\r\n\r\n            if (userName && userName.length > 0) {\r\n                this.showPasswordResetInfo();\r\n                $.get(\"/kxuseradmin?operation=request&data=\" + userName)\r\n                    .done(function(data) {\r\n                        self.$recoveryResponse.text(data);\r\n                    })\r\n                    .fail(function(data) {\r\n                        let text = \"Error\";\r\n\r\n                        if (_.isString(data)) {\r\n                            text += \": \" + data;\r\n                        } else if (data && data.statusText) {\r\n                            text += \": \" + data.statusText;\r\n                        }\r\n\r\n                        self.$recoveryResponse.text(text);\r\n                    });\r\n            } else {\r\n                this.$restPasswordError.css(\"visibility\", \"visible\");\r\n            }\r\n        }\r\n\r\n        setErrorMessage(errorText, colour?) {\r\n            const self = this,\r\n                //only login button is being modified\r\n                $loginBtnIcon = self.$dialog\r\n                    .parent()\r\n                    .find(\".ui-button-icon-primary.fa-spinner.fa-pulse\"),\r\n                cssJSON = {};\r\n\r\n            this.$el.find(\".loginErrorPanel\").removeClass(\"warning\");\r\n\r\n            if (colour === \"#fff\") {\r\n                this.$el.find(\".loginErrorPanel\").addClass(\"info\");\r\n            } else if (colour === \"#ffc800\") {\r\n                // Caps Lock\r\n                this.$el.find(\".loginErrorPanel\").addClass(\"warning\");\r\n            } else {\r\n                this.$el.find(\".loginErrorPanel\").removeClass(\"info\");\r\n            }\r\n\r\n            if (errorText === \"locked\") {\r\n                errorText = t(\"Account is locked; please contact your administrator\");\r\n            } else if (errorText === \"capsLock\") {\r\n                errorText = '<i class=\"fa fa-warning\"/>' + t(\"Caps Lock is on\");\r\n            }\r\n\r\n            this.$el.find(\".loginErrorPanel\").css(cssJSON);\r\n\r\n            this.$el\r\n                .find(\".loginErrorPanel\")\r\n                .html(errorText)\r\n                .css(\"visibility\", \"visible\");\r\n\r\n            self.clicked = false;\r\n\r\n            if ($loginBtnIcon.length) {\r\n                $loginBtnIcon.removeClass(\"fa-spinner fa-pulse\");\r\n                $loginBtnIcon.addClass(\"fa-check\");\r\n                this.$loginBtn.find(\".ui-button-text\").text(t(\"Login\"));\r\n            }\r\n\r\n            self.$el.find(\"input\").removeAttr(\"disabled\");\r\n\r\n            if (\r\n                errorText === \"Please reset password\" ||\r\n                errorText === \"Your password has expired\"\r\n            ) {\r\n                if (!self.changePasswordDialog) {\r\n                    self.changePasswordDialog = new ChangePasswordDialog({\r\n                        appModel: self.appModel,\r\n                        container: self.container,\r\n                        message: errorText,\r\n                        onChangeSuccess: function() {\r\n                            // user will be logged as part of deltaClient.resetPassword,\r\n                            // so close login dialog\r\n                            self.$el.find(\".loginErrorPanel\").css(\"visibility\", \"hidden\");\r\n\r\n                            if (self.$el.data(\"uiDialog\")) {\r\n                                self.$el.dialog(\"close\");\r\n                            }\r\n                        },\r\n                        onDialogClose: _.bind(function() {\r\n                            self.changePasswordDialog = null;\r\n                        }, self),\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        showForgotPasswordForm() {\r\n            this.$userLoginForm.removeClass(\"open\");\r\n            this.$forgotPasswordForm.addClass(\"open\");\r\n            this.$passwordResetInfo.removeClass(\"open\");\r\n            this.$loginBtn.hide();\r\n            this.$backBtn.show();\r\n            this.$resetBtn.show();\r\n        }\r\n\r\n        showPasswordResetInfo() {\r\n            this.$userLoginForm.removeClass(\"open\");\r\n            this.$forgotPasswordForm.removeClass(\"open\");\r\n            this.$passwordResetInfo.addClass(\"open\");\r\n            this.$loginBtn.hide();\r\n            this.$resetBtn.hide();\r\n            this.$backBtn.show();\r\n        }\r\n\r\n        hideForgotPasswordForm() {\r\n            this.$forgotPasswordForm.removeClass(\"open\");\r\n            this.$passwordResetInfo.removeClass(\"open\");\r\n            this.$userLoginForm.addClass(\"open\");\r\n            this.$loginBtn.show();\r\n            this.$backBtn.hide();\r\n            this.$resetBtn.hide();\r\n        }\r\n    }\r\n}\r\n","/*global _, $, Backbone, console, Conv, T, Tools */\n/// <reference path=\"../templates/combined.ts\" />\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class HeuristicHelpers {\n        static getStringColumns(dataSource): Array<string> {\n            const data = dataSource.source ? dataSource.source : dataSource;\n            const stringColumns = _.filter(data.dataSet.columns.models, m => {\n                const t = Number(m.get(\"kdbType\"));\n                return t === 11;\n            }).map(c => c.id as string);\n\n            return stringColumns;\n        }\n\n        static getScalarColumns(dataSource): Array<string> {\n            const data = dataSource.source ? dataSource.source : dataSource;\n            const scalarColumns = _.filter(data.dataSet.columns.models, m => {\n                const t = Number(m.get(\"kdbType\"));\n                return (3 < t && t < 11) || (11 < t && t < 20);\n            }).map(c => c.id as string);\n\n            return scalarColumns;\n        }\n\n        static getNumericColumns(dataSource): Array<string> {\n            const data = dataSource.source ? dataSource.source : dataSource;\n            const numericColumns = _.filter(data.dataSet.columns.models, m => {\n                const t = Number(m.get(\"kdbType\"));\n                return 3 < t && t < 11;\n            }).map(c => c.id as string);\n\n            return numericColumns;\n        }\n\n        static getTimeColumns(dataSource): Array<string> {\n            const data = dataSource.source ? dataSource.source : dataSource;\n            const timeColumns = _.filter(data.dataSet.columns.models, m => {\n                const t = Number(m.get(\"kdbType\"));\n                return 11 < t && t < 20;\n            }).map(c => c.id as string);\n\n            return timeColumns;\n        }\n\n        static getListColumns(dataSource): Array<string> {\n            const data = dataSource.source ? dataSource.source : dataSource;\n            const listColumns = _.filter(data.dataSet.columns.models, m => {\n                const t = Number(m.get(\"kdbType\"));\n                return t === 0;\n            }).map(c => c.id as string);\n\n            return listColumns;\n        }\n    }\n}\n","/*global*/\r\n/// <reference path=\"../templates/combined.ts\" />\r\n/// <reference path=\"../lib/i18n.d.ts\" />\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export var HelpDialog = Backbone.View.extend({\r\n        $dialog: null,\r\n\r\n        appModel: null,\r\n        className: \"quick-base window\",\r\n        viewModel: null,\r\n\r\n        initialize: function(options) {\r\n            this.appModel = options.appModel;\r\n            this.container = options.container;\r\n            this.viewModel = options.viewModel;\r\n            this.tag = options.tag;\r\n            this.render();\r\n        },\r\n\r\n        remove: function() {\r\n            //completely remove dialog from DOM\r\n            this.$el[\"dialog\"](\"destroy\").remove();\r\n            // remove event handlers\r\n            this.stopListening();\r\n            this.$el.off();\r\n            // remove from dom\r\n            this.$el.remove();\r\n        },\r\n\r\n        render: function() {\r\n            let self = this,\r\n                doc = $(document),\r\n                docsUrl = this.appModel.get(\"DocsUrl\"),\r\n                webUrl = this.appModel.get(\"websiteUrl\").replace(\"/edit\", \"\"),\r\n                url = docsUrl !== undefined ? docsUrl : webUrl + \"docs/\",\r\n                isTabbed = this.appModel.get(\"isHelpDialogTabbed\") || false;\r\n\r\n            url = this.tag !== undefined ? url + \"/\" + this.tag : url;\r\n\r\n            if (isTabbed) {\r\n                window.open(url, \"_blank\");\r\n            } else {\r\n                this.$el.html($(\"<iframe />\").attr(\"src\", url));\r\n\r\n                this.$dialog = this.$el[\"dialog\"](\r\n                    _.extend(\r\n                        {\r\n                            appendTo: this.container,\r\n                            dialogClass: \"quick-base help-dialog\",\r\n                            title: t(\"Help\"),\r\n                            resizable: true,\r\n                            height: doc.height() * 0.8,\r\n                            width: doc.width() * 0.8,\r\n                            modal: true,\r\n                            autoOpen: true,\r\n                            draggable: true,\r\n                            open: function() {\r\n                                // add a dialog icon\r\n                                $('<i class=\"fa fa-question-circle\" />').insertBefore(\r\n                                    self.$el.parent().find(\".ui-dialog-title\"),\r\n                                );\r\n                            },\r\n                            close: function() {\r\n                                self.remove();\r\n                            },\r\n                        },\r\n                        this.options,\r\n                    ),\r\n                );\r\n            }\r\n        },\r\n    });\r\n}\r\n","/*global DashboardListView*/\r\n/// <reference path=\"../lib/delta-client-lib.ts\" />\r\n/// <reference path=\"../templates/combined.ts\" />\r\n/// <reference path=\"../views/AboutDialog.ts\" />\r\n/// <reference path=\"../views/HelpDialog.ts\" />\r\n/// <reference path=\"../views/ChangePasswordDialog.ts\" />\r\n/// <reference path=\"../views/AreYouSureDialog.ts\" />\r\n/// <reference path=\"../classes/log.ts\"/>\r\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\r\nnamespace QuickBase {\r\n    export class ProfileMenu extends Backbone.View<Backbone.Model> {\r\n        MAJOR_TIMEZONES = [\r\n            {\r\n                label: \"UTC / Unaltered\",\r\n                value: \"UTC\",\r\n            },\r\n            {\r\n                label: \"Frankfurt\",\r\n                value: \"Europe/Berlin\",\r\n            },\r\n            {\r\n                label: \"London\",\r\n                value: \"Europe/London\",\r\n            },\r\n            {\r\n                label: \"New York\",\r\n                value: \"America/New_York\",\r\n            },\r\n            {\r\n                label: \"Sydney\",\r\n                value: \"Australia/Sydney\",\r\n            },\r\n            {\r\n                label: \"Tokyo\",\r\n                value: \"Asia/Tokyo\",\r\n            },\r\n        ];\r\n\r\n        logLevels = [\r\n            {\r\n                label: \"None\",\r\n                value: 0,\r\n            },\r\n            {\r\n                label: \"Errors\",\r\n                value: 1,\r\n            },\r\n            {\r\n                label: \"Handled/Warnings\",\r\n                value: 2,\r\n            },\r\n            {\r\n                label: \"Log & Debugs\",\r\n                value: 3,\r\n            },\r\n            {\r\n                label: \"All\",\r\n                value: 4,\r\n            },\r\n        ];\r\n\r\n        $breadcrumbs: JQuery;\r\n        $buttonset: JQuery;\r\n        $changePasswordButton: JQuery;\r\n        $selectLanguage: JQuery;\r\n        $selectLogLevel: JQuery;\r\n        $selectTheme: JQuery;\r\n        $selectViewerTheme: JQuery;\r\n        $selectTimezone: JQuery;\r\n\r\n        dialogContainer = null;\r\n        themes;\r\n        isQuickView = false;\r\n        timezones: any;\r\n        appModel;\r\n        viewModel;\r\n\r\n        constructor(options) {\r\n            super(options);\r\n            this.el.className = \"account-menu ui-widget ui-widget-content\";\r\n            this.appModel = options.appModel;\r\n            this.dialogContainer = options.dialogContainer;\r\n            this.themes = options.themes;\r\n            this.viewModel = options.viewModel;\r\n            this.isQuickView = options.isQuickView ? true : false;\r\n            // Prevent menu from closing when clicked\r\n            this.$el.click(function(e) {\r\n                const target = $(e.target);\r\n                if (!target.is(\"li\")) {\r\n                    e.stopPropagation();\r\n                }\r\n            });\r\n\r\n            this.listenTo(this.viewModel, \"change:themeSwitchable\", this.onThemeSwitchableChange);\r\n            this.getTimezones();\r\n            this.render();\r\n        }\r\n\r\n        getTimezones() {\r\n            this.timezones = _.map(moment.tz.names(), function(timezone) {\r\n                return {\r\n                    group: timezone.substr(0, timezone.indexOf(\"/\")),\r\n                    label: timezone.substr(timezone.indexOf(\"/\") + 1),\r\n                    value: timezone,\r\n                };\r\n            });\r\n            this.timezones = _.groupBy(this.timezones, \"group\");\r\n        }\r\n\r\n        onAbout() {\r\n            const dialog = new AboutDialog({\r\n                appModel: this.appModel,\r\n                container: this.dialogContainer,\r\n                viewModel: this.viewModel,\r\n            });\r\n        }\r\n\r\n        onHelp() {\r\n            const dialog = new HelpDialog({\r\n                appModel: this.appModel,\r\n                container: this.dialogContainer,\r\n                viewModel: this.viewModel,\r\n            });\r\n        }\r\n\r\n        onChangeLanguage() {\r\n            const value = this.$selectLanguage.val();\r\n            if (value && value !== $.cookie(\"dashboard-language\")) {\r\n                $.cookie(\"dashboard-language\", value, { expires: 90, path: \"/\" });\r\n                window.location.reload(false);\r\n            }\r\n        }\r\n\r\n        onChangeLogLevel() {\r\n            const value = this.$selectLogLevel.val();\r\n            if (value && value !== $.cookie(\"dashboard-log-level\")) {\r\n                $.cookie(\"dashboard-log-level\", value, { expires: 90, path: \"/\" });\r\n            }\r\n            Log.trace(value.toString());\r\n        }\r\n\r\n        onChangePassword() {\r\n            const dialog = new ChangePasswordDialog({\r\n                appModel: this.appModel,\r\n                container: this.dialogContainer,\r\n            });\r\n        }\r\n\r\n        onChangeTheme() {\r\n            const value = this.$selectTheme.val();\r\n            if (value && value !== $.cookie(\"dashboard-theme\")) {\r\n                $.cookie(\"dashboard-theme\", value, { expires: 90, path: \"/\" });\r\n                this.trigger(\"themeChange\", value);\r\n            }\r\n        }\r\n\r\n        onChangeViewerTheme() {\r\n            const value = this.$selectViewerTheme.val();\r\n            if (value && value !== $.cookie(\"dashboard-viewer-theme\")) {\r\n                $.cookie(\"dashboard-viewer-theme\", value, { expires: 90, path: \"/\" });\r\n                this.trigger(\"themeChange\", value);\r\n            }\r\n        }\r\n\r\n        onChangeTimezone() {\r\n            const value = this.$selectTimezone.val();\r\n            if (value && value !== $.cookie(\"dashboard-timezone\")) {\r\n                $.cookie(\"dashboard-timezone\", value, { expires: 90, path: \"/\" });\r\n                window.location.reload(false);\r\n            }\r\n        }\r\n\r\n        onLogout() {\r\n            const self = this,\r\n                currentDashId = this.viewModel.get(\"selectedDocumentId\"),\r\n                currentDash = this.appModel.get(\"documents\").find(function(model) {\r\n                    return model.id === currentDashId;\r\n                }),\r\n                isChanged = this.isQuickView\r\n                    ? currentDash && currentDash.get(\"viewState\")[\"wasChanged\"]\r\n                    : currentDash && currentDash.get(\"wasChanged\");\r\n\r\n            if (isChanged && (!this.isQuickView || currentDash.get(\"unsavedViewerPrompt\"))) {\r\n                const x = new AreYouSureDialog({\r\n                    userClass: this.isQuickView ? \"quick-view\" : \"quick-dash\",\r\n                    container: this.dialogContainer,\r\n                    // don't save & exit\r\n                    noSaveCb: _.bind(DeltaClientLib.logout, DeltaClientLib),\r\n                    saveCb() {\r\n                        if (self.isQuickView) {\r\n                            // save viewstate & exit\r\n                            currentDash.get(\"viewState\").save(\r\n                                { id: currentDashId },\r\n                                {\r\n                                    success: _.bind(DeltaClientLib.logout, DeltaClientLib),\r\n                                },\r\n                            );\r\n                        } else {\r\n                            // save & exit\r\n                            currentDash.saveNow(\r\n                                $.noop, // error\r\n                                _.bind(DeltaClientLib.logout, DeltaClientLib), // success\r\n                            );\r\n                        }\r\n                    },\r\n                });\r\n            } else {\r\n                DeltaClientLib.logout();\r\n            }\r\n        }\r\n\r\n        onThemeSwitchableChange() {\r\n            if (this.viewModel.get(\"themeSwitchable\")) {\r\n                this.$selectViewerTheme.prop(\"disabled\", false);\r\n            } else {\r\n                this.$selectViewerTheme.prop(\"disabled\", true);\r\n            }\r\n        }\r\n\r\n        render() {\r\n            let self = this,\r\n                dropdowns;\r\n\r\n            this.$el.html(\r\n                T.ProfileMenu({\r\n                    majorTimezones: this.MAJOR_TIMEZONES,\r\n                    saml: this.appModel.get(\"saml\"),\r\n                    isLite: this.appModel.get(\"isLite\"),\r\n                    logLevel: this.logLevels,\r\n                    themes: this.themes,\r\n                    timezones: this.timezones,\r\n                    editor: !this.isQuickView,\r\n                    showBreadcrumbs: this.appModel.get(\"showBreadcrumbs\"),\r\n                }),\r\n            );\r\n\r\n            this.$buttonset = this.$el.find(\".buttonset\");\r\n            this.$selectLanguage = this.$el.find(\".select-language\");\r\n            this.$selectLogLevel = this.$el.find(\".select-log-level\");\r\n            this.$selectTheme = this.$el.find(\".select-theme\");\r\n            this.$selectTimezone = this.$el.find(\".select-timezone\");\r\n            this.$selectViewerTheme = this.$el.find(\".select-viewer-theme\");\r\n            this.$breadcrumbs = this.$el.find(\".breadcrumbs\");\r\n\r\n            this.$buttonset.buttonset();\r\n            this.$buttonset.menu({\r\n                select: function(event) {\r\n                    const option = $(event.currentTarget).attr(\"data-options\");\r\n\r\n                    switch (option) {\r\n                        case \"change-password\":\r\n                            self.onChangePassword();\r\n                            break;\r\n                        case \"about\":\r\n                            self.onAbout();\r\n                            break;\r\n                        case \"helpguide\":\r\n                            self.onHelp();\r\n                            break;\r\n                        case \"logout\":\r\n                            self.onLogout();\r\n                            break;\r\n                        case \"login-history\":\r\n                            self.trigger(\"login-history\");\r\n                            break;\r\n                        case \"logout-local\":\r\n                            self.ssoLogout(\"local\");\r\n                            break;\r\n                        case \"logout-global\":\r\n                            self.ssoLogout(\"global\");\r\n                        case \"open-editor\":\r\n                            window.open(\"./edit#\" + Tools.getHash(), \"_blank\");\r\n                            break;\r\n                        case \"open-viewer\":\r\n                            window.open(\"../#\" + Tools.getHash(), \"_blank\");\r\n                            break;\r\n                        case \"document-breadcrumbs\":\r\n                            self.toggleBreadcrumbs();\r\n                    }\r\n                },\r\n            });\r\n\r\n            dropdowns = [\r\n                {\r\n                    $el: this.$selectLanguage,\r\n                    value: $.cookie(\"dashboard-language\") || \"en\",\r\n                    options: {},\r\n                    callback: this.onChangeLanguage,\r\n                },\r\n                {\r\n                    $el: this.$selectLogLevel,\r\n                    value: $.cookie(\"dashboard-log-level\") || \"4\",\r\n                    options: { minimumResultsForSearch: 10 },\r\n                    callback: this.onChangeLogLevel,\r\n                },\r\n                {\r\n                    $el: this.$selectTheme,\r\n                    value: $.cookie(\"dashboard-theme\") || \"kx-darkroom\",\r\n                    options: { minimumResultsForSearch: 3 },\r\n                    callback: this.onChangeTheme,\r\n                },\r\n                {\r\n                    $el: this.$selectViewerTheme,\r\n                    value: $.cookie(\"dashboard-viewer-theme\") || \"kx-darkroom\",\r\n                    options: { minimumResultsForSearch: 3 },\r\n                    callback: this.onChangeViewerTheme,\r\n                },\r\n                {\r\n                    $el: this.$selectTimezone,\r\n                    value: Tools.timezone,\r\n                    options: {},\r\n                    callback: this.onChangeTimezone,\r\n                },\r\n            ];\r\n            _.each(dropdowns, function(d) {\r\n                d.$el.val(d.value);\r\n                d.$el.select2(_.extend({ theme: \"dashboards\" }, d.options));\r\n                d.$el.on(\"select2:select\", _.bind(d.callback, self));\r\n                d.$el.on(\"select2:open\", function() {\r\n                    $(\"body > .select2-container--dashboards.select2-container--open\").addClass(\r\n                        \"select2--environment\",\r\n                    );\r\n                    $(\".select2-search__field\").on(\"click\", function(e) {\r\n                        e.stopPropagation();\r\n                    });\r\n                });\r\n                d.$el.on(\"select2:close\", function() {\r\n                    $(\".select2-search__field\").off();\r\n                });\r\n            });\r\n\r\n            if (this.isQuickView) {\r\n                this.$el.find(\".row.theme\").css(\"display\", \"none\");\r\n            } else {\r\n                this.$el.find(\".row.viewer-theme\").css(\"display\", \"none\");\r\n            }\r\n\r\n            return this;\r\n        }\r\n\r\n        ssoLogout(type: string) {\r\n            DeltaClientLib.ssoLogout(type);\r\n        }\r\n\r\n        toggleBreadcrumbs() {\r\n            // toggle it on the model\r\n            this.appModel.set(\"showBreadcrumbs\", !this.appModel.get(\"showBreadcrumbs\"));\r\n\r\n            // update view\r\n            this.appModel.get(\"showBreadcrumbs\")\r\n                ? this.$breadcrumbs.addClass(\"checked\")\r\n                : this.$breadcrumbs.removeClass(\"checked\");\r\n        }\r\n    }\r\n}\r\n","/*global*/\n/// <reference path=\"../templates/combined.ts\" />\n/// <reference path=\"ComponentDropView.ts\" />\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class PopupView extends Backbone.View<Backbone.Model> {\n        $dialog: JQuery;\n\n        appModel: Backbone.Model;\n        viewModel: DocumentViewModel;\n        viewStateListeners = {};\n        quickView: boolean;\n        isEditing: boolean;\n        visibleListener: DocumentViewModel;\n        widgetId: string;\n\n        $contentPanel: JQuery;\n        $dialogContainer: JQuery;\n\n        onDialogAttributeChange: (() => void) & _.Cancelable;\n\n        componentDropView: ComponentDropView;\n\n        constructor(options) {\n            super(options);\n            this.appModel = options.appModel;\n            this.viewModel = options.viewModel;\n            this.quickView = options.quickView;\n            this.isEditing = options.isEditing;\n\n            this.$el.html(T.popup({}));\n            this.$dialog = this.$el.find(\".dialog\");\n            this.$contentPanel = this.$dialog.find(\".content-panel\");\n\n            if (options.container) {\n                this.$dialogContainer = options.container;\n            } else {\n                this.$dialogContainer = $(\".quick-dash > .content-panel > .document-view\");\n            }\n\n            this.onDialogAttributeChange = _.debounce(this.initializeDialog, 100);\n\n            this.initializeDialog();\n            this.initializeEvents();\n            this.initializeVisible();\n        }\n\n        initializeEvents() {\n            this.listenTo(this.viewModel, \"change:buildMode\", this.onBuildModeChange);\n            this.listenTo(\n                this.model,\n                \"change:dialogTitle change:dialogWidth change:dialogHeight\" +\n                    \" change:modal change:resizable\",\n                this.onDialogAttributeChange,\n            );\n            this.listenTo(this.model, \"change:visible\", this.initializeVisible);\n        }\n\n        destroyDialog() {\n            if (this.$dialog.dialog(\"instance\")) {\n                this.$dialog.dialog(\"destroy\");\n            }\n        }\n\n        initializeComponentDrop() {\n            let $componentDrop;\n\n            if (!this.componentDropView) {\n                //recreate $componentDrop;\n                // when popup is closed, $componentDrop is removed from DOM\n                $componentDrop = $(\"<div></div>\", { class: \"component-drop\" });\n                this.$contentPanel.append($componentDrop);\n\n                this.componentDropView = new ComponentDropView({\n                    el: $componentDrop,\n                    dashboardAppModel: this.appModel,\n                    dashboardViewModel: this.viewModel,\n                    DeltaClientLib: DeltaClientLib,\n                    quickView: this.quickView,\n                    widgets: this.model.get(\"widgets\"),\n                });\n            }\n        }\n\n        initializeDialog() {\n            let self = this,\n                options,\n                reopenDialog = false,\n                settings = this.processSettings();\n\n            options = {\n                appendTo: this.$dialogContainer,\n                autoOpen: false,\n                close: function() {\n                    const visible = self.model.get(\"visible\");\n                    if (\n                        !self.isEditing &&\n                        visible instanceof Backbone.Model &&\n                        visible.get(\"value\") !== false\n                    ) {\n                        visible.set(\"value\", false);\n                    }\n\n                    self.doActions(self.model.get(\"Actions\"));\n\n                    if (self.isEditing) {\n                        self.remove();\n                    } else {\n                        self.removeComponentDropView();\n                    }\n                },\n                dialogClass: \"popup-dialog\",\n                open: function() {\n                    if (self.componentDropView) {\n                        self.componentDropView.onResize();\n                    }\n\n                    // re-centre\n                    self.$dialog.dialog(\"option\", {\n                        position: { my: \"center\", at: \"center\", of: self.$dialogContainer },\n                    });\n\n                    self.$dialog.parent().attr(\"data-widgetid\", self.widgetId);\n\n                    if (self.isEditing) {\n                        // apply mask to container\n                        $(\"<div />\")\n                            .addClass(\"popup-mask ui-widget-overlay\")\n                            .appendTo(self.$dialogContainer)\n                            .click(function() {\n                                self.$dialog.dialog(\"close\");\n                            });\n                    }\n                },\n                position: { my: \"center\", at: \"center\", of: this.$dialogContainer },\n                resizeStop: function() {\n                    if (self.componentDropView) {\n                        self.componentDropView.onResize();\n                    }\n                },\n                title: settings.dialogTitle,\n            };\n\n            _.assign(options, this.getAdjustedSize(settings));\n\n            // set booleans\n            if (this.isEditing) {\n                options[\"modal\"] = false;\n                options[\"resizable\"] = false;\n            } else {\n                options[\"modal\"] = settings.modal === true ? true : false;\n                options[\"resizable\"] = settings.resizable === true ? true : false;\n            }\n\n            // if no title is given then hide it (required for correct jQuery UI formatting)\n            //options['text'] = (options['title']) ? true : false;\n\n            // apply options if dialog has already been initialized, or initialize new dialog\n            if (this.$dialog.dialog(\"instance\")) {\n                if (this.$dialog.dialog(\"option\", \"modal\") !== options[\"modal\"]) {\n                    // changing modal option requires closing/reopening the dialog\n                    reopenDialog = this.$dialog.dialog(\"isOpen\");\n                }\n\n                this.$dialog.dialog(\"option\", options);\n\n                if (reopenDialog) {\n                    this.$dialog.dialog(\"close\");\n                    this.$dialog.dialog(\"open\");\n                }\n            } else {\n                this.$dialog.dialog(options);\n            }\n        }\n\n        initializeVisible() {\n            const visible = this.model.get(\"visible\");\n\n            if (this.visibleListener) {\n                this.stopListening(this.visibleListener);\n            }\n\n            if (visible instanceof DocumentViewModel) {\n                this.listenTo(visible, \"change:value\", this.onVisibleChange);\n                this.visibleListener = visible;\n            }\n\n            this.onVisibleChange();\n        }\n\n        onBuildModeChange() {\n            if (this.isEditing) {\n                this.remove();\n            } else {\n                if (this.viewModel.get(\"buildMode\")) {\n                    this.$dialog.dialog(\"close\");\n                } else {\n                    this.initializeDialog();\n                    this.onVisibleChange();\n                }\n            }\n        }\n\n        getAdjustedSize(settings) {\n            // check width/height are within window range, or set to 80% of container if no value given\n            return {\n                height:\n                    Math.min(settings.dialogHeight, this.$dialogContainer.height()) ||\n                    this.$dialogContainer.height() * 0.8,\n                width:\n                    Math.min(settings.dialogWidth, this.$dialogContainer.width()) ||\n                    this.$dialogContainer.width() * 0.8,\n            };\n        }\n\n        onVisibleChange() {\n            let showDialog = this.model.get(\"visible\");\n\n            if (this.viewModel.get(\"buildMode\")) {\n                return;\n            }\n\n            if (showDialog instanceof DocumentViewModel) {\n                showDialog = showDialog.get(\"value\");\n            }\n\n            if (this.$dialog.dialog(\"instance\")) {\n                // viewstates has to complete propagation and finish unsubscribe if closing\n                _.defer(() => {\n                    this.toggleDialog(showDialog);\n                });\n            }\n        }\n\n        pasteWidget(widgetModel) {\n            const componentId = widgetModel.get(\"component\").get(\"definitionId\");\n            const existingWidget = this.componentDropView.widgetsCollection.first();\n\n            if (existingWidget) {\n                //specific id required for advanced css to work properly\n                widgetModel = widgetModel.clone(existingWidget.get(\"id\"));\n                widgetModel.setParent(this.componentDropView.widgetsCollection);\n\n                existingWidget.commandSet({\n                    component: widgetModel.get(\"component\"),\n                });\n            } else {\n                widgetModel.setParent(this.componentDropView.widgetsCollection);\n                this.componentDropView.addNewWidget(widgetModel, componentId, true);\n            }\n        }\n\n        // returns an object of settings mapped to value or viewstate value\n        // also handles listeners for viewstates\n        processSettings(): any {\n            const self = this,\n                attributes = _.omit(this.model.attributes, \"visible\"),\n                settings = {};\n\n            _.each(this.viewStateListeners, function(viewstate) {\n                self.stopListening(viewstate, \"change:value\");\n            });\n\n            this.viewStateListeners = {};\n\n            _.each(attributes, function(value, key) {\n                if (value instanceof DocumentViewModel) {\n                    settings[key] = value.get(\"value\");\n\n                    if (!self.viewStateListeners[value.path]) {\n                        self.listenTo(value, \"change:value\", () => {\n                            //if the dialog is opened and changing property just set the prop\n                            if (\n                                self.$dialog.dialog(\"instance\") &&\n                                self.$dialog.dialog(\"isOpen\") &&\n                                (value.path === \"height\" || value.path === \"width\")\n                            ) {\n                                self.$dialog.dialog(self.getAdjustedSize(self.processSettings()));\n                            } else {\n                                self.initializeDialog();\n                            }\n                        });\n                        self.viewStateListeners[value.path] = value;\n                    }\n                } else {\n                    settings[key] = value;\n                }\n            });\n\n            return settings;\n        }\n\n        remove() {\n            if (this.isEditing) {\n                this.$dialogContainer.find(\".popup-mask\").remove();\n            }\n\n            this.onDialogAttributeChange.cancel();\n            this.destroyDialog();\n            this.removeComponentDropView();\n            this.viewStateListeners = {};\n\n            return Backbone.View.prototype.remove.apply(this);\n        }\n\n        removeComponentDropView() {\n            if (this.componentDropView) {\n                this.componentDropView.remove();\n                this.componentDropView = null;\n            }\n        }\n\n        stringToBoolean(val) {\n            if (typeof val === \"boolean\") {\n                return val;\n            } else if (val) {\n                const string = val.toString();\n                switch (string.toLowerCase().trim()) {\n                    case \"true\":\n                    case \"yes\":\n                    case \"1\":\n                        return true;\n                    case \"false\":\n                    case \"no\":\n                    case \"0\":\n                    case null:\n                        return false;\n                    default:\n                        return Boolean(string);\n                }\n            } else {\n                return false;\n            }\n        }\n\n        toggleDialog(forceState) {\n            let setDialogOpen;\n\n            // forceState is true to open, false to close\n            if (!_.isUndefined(forceState)) {\n                setDialogOpen = forceState;\n            } else {\n                setDialogOpen = !this.$dialog.dialog(\"isOpen\");\n            }\n\n            // check if dialog has been initialized\n            if (this.$dialog.dialog(\"instance\")) {\n                if (this.stringToBoolean(setDialogOpen)) {\n                    // initialize child component when dialog is first opened\n                    this.initializeComponentDrop();\n                    const size = _.pick(this.$dialog.dialog(\"option\"), [\"width\", \"height\"]);\n                    if (Number(size.width) === 0 || Number(size.height) === 0) {\n                        this.$dialog.dialog(\"option\", this.getAdjustedSize(this.processSettings()));\n                    }\n                    this.$dialog.dialog(\"open\");\n                    //popup is not a widget -> dash properties shown in prop inspector\n                    if (this.viewModel.get(\"buildMode\")) {\n                        this.viewModel.set(\"selectedWidget\", this.model);\n                        this.viewModel.set(\"selectedWidgetView\", this, { silent: true });\n                    }\n                } else {\n                    this.$dialog.dialog(\"close\");\n                }\n            }\n        }\n\n        private doActions(actions: any[]): void {\n            _.each(actions, (action, i) => {\n                const current = this.getPropertyMeta(i, \"Current\"),\n                    target = this.getPropertyMeta(i, \"Target\");\n\n                if (current) {\n                    let valueToSet =\n                        current.type === \"viewstate\" ? current.value : action[\"Current\"];\n\n                    if (Tools.isKDBTemporal(valueToSet)) {\n                        valueToSet = Tools.convertKDBTemporalToMoment(valueToSet).toDashString();\n                    }\n\n                    if (target && target.type === \"viewstate\" && target.path) {\n                        // setting a viewstate in the current dashboard\n                        const property = this.model.get(\"Actions\")[i].Target;\n                        property.set(\"value\", valueToSet);\n                    }\n                }\n            });\n        }\n\n        private getPropertyMeta(index, propName): any {\n            let defaultValue, viewstateType, value;\n            const property = this.model.get(\"Actions\")[index][propName];\n\n            // if undefined or null\n            if (_.isNil(property)) return null;\n\n            const type = this.getSourceType(property);\n\n            switch (type) {\n                case \"viewstate\":\n                    value = property.get(\"value\");\n                    defaultValue = property.get(\"_default\");\n                    viewstateType = property.get(\"_type\");\n                    break;\n                default:\n                    value = property;\n            }\n\n            return {\n                path: property.path || null,\n                type: type,\n                value: value,\n                viewstateType: viewstateType || null,\n                defaultValue: defaultValue || null,\n            };\n        }\n\n        private getSourceType(source): string | null {\n            if (\n                source &&\n                (source instanceof DocumentViewModel ||\n                    (source.get && source.get(\"_viewType\")) ||\n                    (source.has && source.has(\"_default\") && source.has(\"value\")))\n            ) {\n                return \"viewstate\";\n            } else {\n                return null;\n            }\n        }\n    }\n}\n","/*\n * RawDataFormatter suppose to accept raw data, format string, and data type and\n * output formatted string. Also if format is not specified a default format is\n * applied based on provided colKdbType\n * @param rawValue {any} - value can be number, string or kdb temporal object\n * @param format {String} - VALID format string, validated in FileExportInterface\n * @param colKdbType {Number} - kdb type\n * @param isApplyDefaultFormat {Boolean} - should format string to be ignored\n * @param isTypeDate {Boolean} - if value of the date or/and time type\n * @return formattedValue {String} - formatted value\n */ // eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class RawDataFormatter {\n        public static applyFormatToValue(value, format, dataType, colKdbType, hideTrailingZeroes) {\n            let formattedValue,\n                kdbDataTypeClass, //ethier number or date\n                mappedKdbType;\n            //apply formatter\n            mappedKdbType = {\n                \"1\": \"Boolean\", //boolean\n                \"2\": \"String\", //guid\n                \"4\": \"Number\", //byte\n                \"5\": \"Number\", //short\n                \"6\": \"Number\", //int\n                \"7\": \"Number\", //long\n                \"8\": \"Number\", //real\n                \"9\": \"Number\", //float\n                \"10\": \"String\", //char\n                \"11\": \"String\", //symbol\n                \"12\": \"Timestamp\", //timestamp \"\"1990.01.01D20:59:59.000111123\"\"\n                \"13\": \"Month\", //month  \"1990.01\"\n                \"14\": \"Date\", //date \"1990.01.01\" Excel convertable?\n                \"15\": \"Datetime\", //datetime \"2003.03.23T08:31:53.001\"\n                \"16\": \"Timespan\", //timespan \"0D00:00:00.001786123\"\n                \"17\": \"Minute\", //minute    23:59\n                \"18\": \"Second\", //second    23:59:59\n                \"19\": \"Time\", //time  09:01:02:042\n            }[colKdbType];\n            //use kdb type of the value more acurate than field type\n            if (colKdbType > 3 && colKdbType < 10) {\n                kdbDataTypeClass = \"Number\";\n            } else if (colKdbType > 11 && colKdbType < 20) {\n                kdbDataTypeClass = \"DateTime\";\n            } else {\n                kdbDataTypeClass = \"String\";\n            }\n\n            // If we pass through TO_STRING then return value.toString\n            if (format == \"TO_STRING\") {\n                return value.toString();\n            }\n\n            //default format options to be used\n            if (!format) {\n                formattedValue = RawDataFormatter._applyDefaultFormat(\n                    value,\n                    dataType,\n                    mappedKdbType,\n                    hideTrailingZeroes,\n                    kdbDataTypeClass,\n                );\n            } else {\n                formattedValue = RawDataFormatter._applyFormat(\n                    value,\n                    format,\n                    dataType,\n                    mappedKdbType,\n                    hideTrailingZeroes,\n                    kdbDataTypeClass,\n                );\n            }\n\n            return formattedValue;\n        }\n\n        /* Apply format and traling zeroes to value\n         * @param value {any} - cell raw value\n         * @param format {String} - format to apply\n         * @param dataType {String} - column type as selected\n         * @param mappedKdbType {String} - value kdb type name\n         * @param hideTrailingZeroes {Boolen}\n         * @param kdbDataTypeClass {String} - classify values based on their kdb types\n         * @return formattedValue {String}\n         */\n        //TODO adopt to allow Temporal conversion in to number if\n        private static _applyFormat(\n            value,\n            format,\n            dataType,\n            mappedKdbType,\n            hideTrailingZeroes,\n            kdbDataTypeClass,\n        ) {\n            let formattedValue = value.toString(),\n                decimalPlaces,\n                m;\n\n            //In case of format is not resolved properly\n            if (format.indexOf(\"SmartNumber\") === 0) {\n                mappedKdbType = \"Smart Number\";\n            }\n            // apply formatter if not forced to string\n            switch (mappedKdbType) {\n                case \"Smart Number\":\n                    //case when trying to force kdb Temporals as number\n                    if (kdbDataTypeClass === \"DateTime\") {\n                        m = Tools.convertKDBTemporalToMoment(value);\n                        value = _.escape(m);\n                    }\n\n                    decimalPlaces = format.indexOf(\".\") !== -1 ? format.split(\".\")[1].length : 0;\n\n                    formattedValue = Tools.smartFormatNumber(\n                        value,\n                        decimalPlaces,\n                        !hideTrailingZeroes, //showTrailingZeroes\n                    );\n                    break;\n                case \"Number\":\n                    //do not format Infinity values\n                    if (!_.isNaN(Number(value)) && _.isFinite(Number(value))) {\n                        formattedValue = XLSX.SSF.format(format, Number(value));\n                        //hide trailig zeroes\n                        if (hideTrailingZeroes) {\n                            formattedValue = RawDataFormatter._hideTrailingZeroes(formattedValue);\n                        }\n                    }\n                    break;\n                //invalid dates to be converted to empty strings\n                /* XSLX converter for .csv exports all values as string\n                    so moment formatter is not suitable */\n                case \"Date\":\n                case \"Month\":\n                case \"Timestamp\":\n                case \"Datetime\":\n                case \"Timespan\":\n                case \"Minute\":\n                case \"Second\":\n                case \"Time\":\n                    //use user selected type to understand what formatting is expected to apply\n                    //allow to convert date in to number\n                    const isTime = dataType === \"Time\",\n                        isDateTime = dataType === \"DateTime\";\n\n                    m = Tools.convertKDBTemporalToMoment(value);\n                    //addressed situation in chartJs where date converted to number\n                    //\n                    if (dataType === \"Number\") {\n                        formattedValue = _.escape(m);\n\n                        if (\n                            !_.isNaN(Number(formattedValue)) &&\n                            _.isFinite(Number(formattedValue))\n                        ) {\n                            formattedValue = XLSX.SSF.format(format, Number(formattedValue));\n                            //hide trailig zeroes\n                            if (hideTrailingZeroes) {\n                                formattedValue = RawDataFormatter._hideTrailingZeroes(\n                                    formattedValue,\n                                );\n                            }\n                        }\n                    } else {\n                        if (_.isFunction(m.isValid) && !m.isValid()) {\n                            formattedValue = _.escape(m);\n                        } else {\n                            //todo format using \"kk\" is not recognised\n                            //if (moment.isDuration(m)) {\n                            //} else {\n                            //time & datetime have 3 decimal places\n                            formattedValue = isTime\n                                ? m.formatNano(format, { trim: false, trimNano: false })\n                                : isDateTime\n                                ? m.formatNano(format, { trim: false, trimNano: false })\n                                : m.formatNano(format);\n                            //}\n                        }\n                    }\n                    break;\n                case \"String\":\n                default:\n                    formattedValue = value.toString();\n                    break;\n            }\n\n            return formattedValue;\n        }\n        /* Apply format and traling zeroes to value\n         * @param value {any} - cell raw value\n         * @param dataType {String} - column type as selected\n         * @param mappedKdbType {String} - value kdb type name\n         * @param hideTrailingZeroes {Boolen}\n         * @param kdbDataTypeClass {String} - classify values based on their kdb types\n         * @return formattedValue {String}\n         */\n        private static _applyDefaultFormat(\n            value,\n            dataType,\n            mappedKdbType,\n            hideTrailingZeroes,\n            kdbDataTypeClass,\n        ) {\n            let formattedValue = value.toString();\n            let m = null;\n\n            //if value is Temporal\n            if (Tools.isKDBTemporal(value)) {\n                m = Tools.convertKDBTemporalToMoment(value);\n            }\n\n            //export date as string and ignore timezone/daylight offsets\n            if (kdbDataTypeClass === \"DateTime\") {\n                //ChartJs dates can be given type of number to allow conversion of durations\n                if (dataType === \"Number\") {\n                    formattedValue = _.escape(m);\n                } else {\n                    if (m && _.isFunction(m.format)) {\n                        formattedValue = m.format();\n                    } else if (_.isFunction(value.toString)) {\n                        formattedValue = value.toString();\n                    }\n                }\n            } else if (kdbDataTypeClass === \"Number\") {\n                //TODO add dates processing\n                if (hideTrailingZeroes) {\n                    //Hide trailing zeroes\n                    formattedValue = RawDataFormatter._hideTrailingZeroes(formattedValue);\n                }\n            }\n\n            return formattedValue;\n        }\n\n        /*@param valueStr {string} - number that may have traling zeros\n         Smart numbers are hendled in Tools*/\n        private static _hideTrailingZeroes(valueStr) {\n            let toReturn = valueStr,\n                tempSuffix,\n                lastChar;\n            //remove trailing zeroes\n            if (toReturn.indexOf(\".\") >= 0) {\n                lastChar = toReturn[toReturn.length - 1];\n                tempSuffix = \"\";\n\n                while (toReturn[toReturn.length - 1] === \"0\") {\n                    toReturn = toReturn.slice(0, -1);\n                }\n\n                //after removing zeroes remove decimal separator if it's the last character\n                if (toReturn[toReturn.length - 1] === \".\") {\n                    toReturn = toReturn.slice(0, -1);\n                }\n\n                //append suffix\n                toReturn += tempSuffix;\n            }\n            return toReturn;\n        }\n    }\n}\n","/*global _,$,Backbone,console,moment*/\n/// <reference path=\"RawDataFormatter.ts\" />\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class FileExportDataGenerator {\n        private static EXCEL_INCOMPATIBLE_FORMATS = [\n            \"\",\n            \"SmartNumber\",\n            \"SmartNumber.0\",\n            \"SmartNumber.00\",\n            \"SmartNumber.000\",\n            \"SmartNumber.0000\",\n            \"SmartNumber.00000\",\n            \"SmartNumber.000000\",\n            \"SmartNumber.0000000\",\n            \"SmartNumber.00000000\",\n            \"SmartNumber.000000000\",\n            \"SmartNumber.0000000000\",\n            \"HH:mm\",\n            \"HH:mm:ss\",\n            \"HH:mm:ss.SSS\",\n            \"HH:mm:ss.SSSSSS\",\n            \"HH:mm:ss.SSSSSSSSS\",\n            \"YYYY-MM-DD HH:mm:ss.SSS\",\n            \"YYYY-MM-DD HH:mm:ss.SSSSSS\",\n            \"YYYY-MM-DD HH:mm:ss.SSSSSSSSS\",\n            \"mm:ss\",\n            \"mm:ss.SSS\",\n            \"Mm:ss.SSSSSS\",\n            \"mm:ss.SSSSSSSSS\",\n            \"ss\",\n            \"ss.SSS\",\n            \"ss.SSSSSS\",\n            \"ss.SSSSSSSSS\",\n        ];\n\n        /*\n        * @return {obj} -\n          {\n            data: Array - aray of objects with cell properites \n            columnHeaders: Object - colomn meta data with fomat, \n                type, isStringType prerties for each colums  \n          }  \n        * Must match FileExport class expected format\n        */\n        public static getFormData(dataCollection, metaData, bookType) {\n            const returnDataRows = [];\n\n            //contains list of column metadata for\n            const columnHeaders = [];\n\n            //Add column headers as a first exported row\n            returnDataRows.push(\n                _.map(metaData, function(header, colIndex) {\n                    //check if name property exists\n                    const columnName = header.colName ? header.colName : header.colId;\n\n                    // If dataCollection is empty (chartjs multidatasource with noResults returned)\n                    if (!dataCollection.length) {\n                        columnHeaders[colIndex] = {\n                            isStringType: false,\n                            format: \"\",\n                            type: \"String\",\n                        };\n                    }\n\n                    return {\n                        formattedVal: columnName,\n                        value: columnName,\n                        type: \"String\",\n                    };\n                }),\n            );\n            //ReturnDataRows.push(metaData);\n\n            //Get data and create table rows\n            for (var i = 0; i < dataCollection.length; i++) {\n                var tableRow = [];\n                //Iterate throught each column header\n                _.each(metaData, function(header, colIndex) {\n                    let cellVal, formattedVal;\n                    //get each cell from row\n                    cellVal = dataCollection[i][header.colId];\n\n                    if (cellVal !== undefined && cellVal !== null) {\n                        formattedVal = FileExportDataGenerator.generateExportData(\n                            header,\n                            cellVal,\n                            colIndex,\n                            bookType,\n                            columnHeaders,\n                        );\n\n                        tableRow.push(formattedVal);\n                    } else {\n                        //all indexes of column headers must be filled\n                        columnHeaders[colIndex] = columnHeaders[colIndex] || {\n                            isStringType: false,\n                            format: header.dataFormat,\n                            type: header.dataType,\n                        };\n                        // Prevent removing empty comma in regex\n                        tableRow.push({\n                            formattedVal: \"\",\n                            value: \"\",\n                            type: null,\n                        });\n                        console.log(\"Cell value is either undefined or null: \" + header.colId);\n                    }\n                });\n\n                returnDataRows.push(tableRow);\n            }\n            //get serted indexes of all columns and find\n            return {\n                data: returnDataRows,\n                columnHeaders: columnHeaders,\n            };\n        }\n\n        /* Validate and convert value it to appropriate format for XLSX exporter\n         * !NOTE XLSX is not able to handle comlex formatter options for Time/DateTime\n         *   export so export those as string after applying formatter\n         * @param header {obj} - metaData for current col\n         * @param header.dataFormat {String} - format for column\n         * @param header.dataKdbType {Number} - value of kdb type\n         * @param header.dataType {String} - xAxis has options to specify col type\n         * @param header.hideTrailingZeroes {Boolean} - property found in Grids only\n         * @param header.prefix {String} - prefix to be appended to value\n         * @param header.suffix {String} - suffix to be appended to value\n         * @param value {any} - cell value can be moment obj, String or Number\n         * @param colIndex {Number} - index number of current row of the cell\n         * @param bookType {String} - .csv exported data is treated as a\n         *   string by XLSX exporter some conversion must be passed as string\n         *   eg. moment formatted dates\n         * @return returnCellObject {obj}\n         */\n        private static generateExportData(header, value, colIndex, bookType, columnHeaders) {\n            let index = colIndex,\n                cellFormat, //set format for individual cells used in \"%\"\n                format = header.dataFormat,\n                colKdbType = header.dataKdbType,\n                dataType = header.dataType,\n                hideTrailingZeroes = header.hideTrailingZeroes,\n                prefix = header.prefix,\n                suffix = header.suffix,\n                returnCellObject = {},\n                //for formats incompatible with XLSX\n                isFormatXLSXCompatible = FileExportDataGenerator.checkIfFormatXLSXCompatible(\n                    format,\n                ),\n                exportAsString =\n                    dataType !== \"Boolean\" && (!format || !isFormatXLSXCompatible) ? true : false,\n                formattedValue;\n\n            /* columnHeaders used by XLSX to get metaData of cells, index is linked to index of the cell in the row */\n            columnHeaders[index] = columnHeaders[index] || {\n                isStringType: false,\n                format: format,\n                type: dataType,\n            };\n\n            if (value !== \"\") {\n                /* Formats are applied based on KDB DATA TYPE of the value and only uses\n                user selected dataType to distingush between Time and DateTime WHEN applying formats */\n                formattedValue = RawDataFormatter.applyFormatToValue(\n                    value,\n                    format,\n                    dataType,\n                    colKdbType,\n                    hideTrailingZeroes,\n                );\n\n                // Escape special characters\n                if (bookType === \"csv\" && /^[-\\+=@]/.test(formattedValue)) {\n                    formattedValue = \"'\" + formattedValue;\n                }\n                //!NOTE resolve suffix conflicts in config generator\n                //May need to update prefix suffix policy\n                if (exportAsString) {\n                    returnCellObject = {\n                        formattedVal: formattedValue,\n                        value: prefix + formattedValue + suffix,\n                    };\n\n                    //mark to be exported as string\n                    columnHeaders[index].type = \"String\";\n                } else if (dataType === \"Boolean\") {\n                    //No further manipulatons required\n                    returnCellObject = {\n                        formattedVal: formattedValue,\n                        value: formattedValue === \"true\" ? true : false,\n                    };\n                    /* Explicitly convert number to percentage if % suffix is present\n                     * !NOTE to avoid this explicitly set col type to \"String\" in\n                     * component's config generator tools See Multichart vs Datagrid*/\n                } else if (dataType === \"Number\" && suffix === \"%\") {\n                    //check how value will look like after converted to %\n                    const pecentageVal = Number(value) * 100;\n\n                    //use decimal places\n                    const percentageStr =\n                        pecentageVal - Math.floor(pecentageVal) > 0\n                            ? pecentageVal.toFixed(2)\n                            : pecentageVal.toFixed(0);\n\n                    formattedValue = pecentageVal + \"%\";\n\n                    if (percentageStr.indexOf(\".\") !== -1) {\n                        format = \"0.00%\";\n                    } else {\n                        format = \"0%\";\n                    }\n\n                    //Prevent excell from cutting excess of 16 chars\n                    if (percentageStr.length > 16) {\n                        columnHeaders[index].isStringType = true;\n                    }\n                    returnCellObject = {\n                        formattedVal: formattedValue,\n                        value: Number(value), //has to be number\n                        format: format,\n                    };\n\n                    //Suffix and prefix can only be applied to String type or Number\n                } else if (\n                    !_.includes([\"Date\", \"Time\", \"DateTime\", \"Boolean\"], dataType) &&\n                    (prefix || suffix)\n                ) {\n                    //prefix/suffix must already contain space before and after\n                    returnCellObject = {\n                        formattedVal: formattedValue,\n                        value: prefix + formattedValue + suffix,\n                    };\n                    columnHeaders[index].type = \"String\";\n                } else {\n                    returnCellObject = FileExportDataGenerator._convertToExportFormat(\n                        index,\n                        formattedValue,\n                        value,\n                        dataType,\n                        format,\n                        bookType,\n                        hideTrailingZeroes,\n                        columnHeaders,\n                    );\n                }\n\n                //if value is \"\"\n            } else {\n                returnCellObject = {\n                    formattedVal: \"\",\n                    value: \"\",\n                    type: \"String\", //mark only cell\n                };\n            }\n\n            return returnCellObject;\n        }\n\n        /* Function checks if string is XLSX compatible */\n        private static checkIfFormatXLSXCompatible(format) {\n            let isCompatible = true;\n            if (\n                _.includes(FileExportDataGenerator.EXCEL_INCOMPATIBLE_FORMATS, format) ||\n                format.indexOf(\".SSS\") !== -1\n            ) {\n                isCompatible = false;\n            }\n            return isCompatible;\n        }\n        /*\n         * Convert values for XLSX to be exported as their selectd type if possible.\n         * @param index {Number} - index of culumn\n         * @param formattedValue {String} - value with formatter applied\n         * @param value {any} - raw cell val\n         * @param type {String} - column type\n         * @param format {String} - format applied to raw value\n         * @param bookType {String} - csv, xlsx or xls\n         * @param hideTrailingZeroes {Boolean} - property found in Grids only\n         * @return returnCellObject {obj}\n         */\n        private static _convertToExportFormat(\n            index,\n            formattedValue,\n            value,\n            type,\n            format,\n            bookType,\n            hideTrailingZeroes,\n            columnHeaders,\n        ) {\n            //convert to string instead of exporting using type Number or Date\n            let exportValue,\n                returnCellObject = {\n                    format: undefined,\n                    formattedVal: formattedValue,\n                    value: \"\",\n                    type: undefined,\n                };\n\n            //apply only to numeric values that exported as numbers not strings\n            if (type === \"Number\") {\n                //if numeric type has no numeric value Formatted numbers\n                if (isNaN(Number(value)) || !_.isFinite(Number(value))) {\n                    type = \"String\"; //skip applying fromatter\n                    returnCellObject.type = \"String\";\n                    /* If numeric type with length > 16 excel trims off \n                    least significant digits for num > 16 chars */\n                } else if (_.isString(formattedValue) && formattedValue.length > 16) {\n                    type = \"String\"; //skip applying fromatter\n                    columnHeaders[index].isStringType = true;\n                }\n            }\n            // in some cases skip formatting based on type\n            // apply formatter if not forced to string\n            switch (type) {\n                case \"Number\":\n                    //update format based on number digits not percentage\n                    if (hideTrailingZeroes && !/[%]/.test(format)) {\n                        //formatted values is a string with traling zeroes removed\n                        const precision =\n                                formattedValue.indexOf(\".\") !== -1\n                                    ? formattedValue.split(\".\")[1].length\n                                    : 0,\n                            //generate new precission\n                            precisionString = precision ? \".\" + Array(precision + 1).join(\"0\") : \"\",\n                            //get format string whole part\n                            fromatWholePart =\n                                format.indexOf(\".\") !== -1 ? format.split(\".\")[0] : format,\n                            //combine formatter whole part with precission part\n                            replaceFormat = fromatWholePart + precisionString;\n\n                        if (replaceFormat !== format) {\n                            //update format for value\n                            returnCellObject.format = replaceFormat;\n                        }\n                    }\n                    exportValue = Number(value);\n                    break;\n                //invalid dates tobe converted to empty strings\n                /* XSLX converter for .csv exports Date types without\n                applying formatters so moment formatter is not suitable */\n                case \"Date\":\n                    //utc prevents daysaving being applied\n                    if (\n                        bookType !== \"csv\" &&\n                        moment.utc(formattedValue, format).isValid() &&\n                        moment.utc(formattedValue, format).format() !== \"Invalid date\"\n                    ) {\n                        //ignore timezone offsets\n                        exportValue = moment.utc(formattedValue, format).format();\n                    } else if (bookType === \"csv\") {\n                        exportValue = formattedValue;\n                        columnHeaders[index].type = \"String\";\n                    }\n                    //invalid dates exported as string\n                    else {\n                        //export using formatted value\n                        exportValue = formattedValue;\n                        columnHeaders[index].isStringType = true;\n                    }\n                    break;\n                case \"Time\":\n                case \"DateTime\":\n                    //export those as a string\n                    exportValue = formattedValue;\n                    columnHeaders[index].type = \"String\";\n                    break;\n                case \"String\":\n                default:\n                    exportValue = formattedValue;\n                    break;\n            }\n\n            returnCellObject.value = exportValue;\n\n            return returnCellObject;\n        }\n    }\n}\n","/*global $, T, Backbone, FormSchemas, BBForm, DialogBase*/\n/// <reference path=\"../templates/combined.ts\" />\n/// <reference path=\"../lib/i18n.d.ts\" />\n/// <reference path=\"DialogBase.ts\" />\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    interface SimpleInputDialogOptions extends DialogBaseOptions {\n        inputValue?: any;\n        showLoading: boolean;\n    }\n\n    export class SimpleInputDialog extends DialogBase {\n        public inputValue: any;\n        $dialogButtonpane: JQuery;\n        protected options: SimpleInputDialogOptions;\n\n        constructor(options: SimpleInputDialogOptions) {\n            super(\n                _.extend(\n                    {\n                        iconClass: \"fa-keyboard-o\",\n                        dialogTitle: \"Simple Input\",\n                        userClass: \"simpleinput-dialog\",\n                        width: 275,\n                        height: 140,\n                    },\n                    options,\n                    {\n                        userClass:\n                            \"simpleinput-dialog\" +\n                            (options.userClass ? \" \" + options.userClass : \"\"),\n                    },\n                ),\n            );\n        }\n\n        dialogButtons() {\n            const self = this;\n            return [\n                {\n                    text: \"OK\",\n                    click() {\n                        if (self.options) {\n                            if (self.options.showLoading) {\n                                self.showLoadingSpinner();\n                                _.defer(function() {\n                                    self.dialogClose();\n                                });\n                            } else {\n                                self.dialogClose();\n                            }\n                        }\n                    },\n                    icons: {\n                        primary: \"fa fa-check\",\n                    },\n                },\n                {\n                    text: \"Cancel\",\n                    click() {\n                        self.isCancel = true;\n                        self.dialogClose();\n                    },\n                    icons: {\n                        primary: \"fa fa-times\",\n                    },\n                },\n            ];\n        }\n\n        postRender() {\n            this.$(\"input\").val(this.options.inputValue);\n            this.$(\"input\").on(\"input\", e => {\n                // self.options is returned in the callback\n                this.options.inputValue = this.inputValue = $(e.target).val();\n            });\n        }\n\n        renderTemplate() {\n            return t(\"<span>what?</span><input />\");\n        }\n\n        showLoadingSpinner() {\n            const $buttonOK = this.$dialogButtonpane.find(\"span.fa.fa-check\");\n            $buttonOK.removeClass(\"fa-check\");\n            $buttonOK.addClass(\"fa-spinner fa-pulse\");\n        }\n\n        static ShowInput(\n            callbackFn: any,\n            title: string,\n            label: string,\n            iconClass: string,\n            inputValue: string,\n            userClass: string,\n            showLoading?: boolean,\n        ): SimpleInputDialog {\n            return new SimpleInputDialog(\n                _.extend(\n                    {\n                        iconClass: iconClass,\n                        dialogTitle: title,\n                        callback: callbackFn,\n                        inputValue: inputValue,\n                        userClass: userClass,\n                        showLoading: showLoading,\n                    },\n                    label\n                        ? {\n                              renderTemplate: function() {\n                                  return t(\n                                      \"<div>\" +\n                                          label +\n                                          \"</div><input style='width: 100%; box-sizing: border-box;' />\",\n                                  );\n                              },\n                          }\n                        : {},\n                ),\n            );\n        }\n    }\n}\n","/*global _,$,Backbone,console, xlsx*/\n/// <reference path=\"FileExportDataGenerator.ts\" />\n/// <reference path=\"ExportTools.ts\" />\n/// <reference path=\"../views/SimpleInputDialog.ts\" />\n/// <reference path=\"../lib/i18n.d.ts\" />\n\n/*This class uses sheetJs.js library exported as a module XLSX.\n *The library is used to convert data grid form data from array or arrays\n * into Excel, csv, ect. file.\n *Detailed documentation is available at:\n *https://github.com/SheetJS/js-xlsx/blob/master/README.md\n */\n\n/**\n * appView parameters are passed as callback funcitons to avoid stale data\n * @param {object} options - object with key setting and models\n * @param {array} [options.dataSet] - returns appView.model.dataSet\n * @param {array}  options.metaData {obj} - alternative data collection to facilitate\n *       different data set for non pivot datasets\n *   options.workSheetTitle {string} - widget component name\n *   options.fileFormat {string} - what file export to be generated\n *   options.fileName {string} - file name from the file name prop\n *   options.csvExportDelimiter {string} - csv delimiter to replace comma\n */ // eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class FileExport {\n        bookType: XLSX.BookType;\n        csvExportDelimiter: string;\n        dataSet: any;\n        metaData: any;\n        configSets: any;\n        workSheetTitle: string;\n        fileFormat: string;\n        fileName: string;\n\n        constructor(options) {\n            this.csvExportDelimiter = options.csvExportDelimiter;\n            this.dataSet = options.dataSet;\n            this.metaData = options.metaData;\n            this.configSets = options.configSets;\n            this.workSheetTitle = options.workSheetTitle; //used as name for work_sheet\n            this.fileFormat = options.fileFormat;\n            this.fileName = options.fileName;\n\n            // Map required for Excel conversion by XLSX class\n            this.bookType = {\n                \".xlsx\": \"xlsx\",\n                \".xls\": \"xlml\",\n                \".csv\": \"csv\",\n            }[options.fileFormat];\n        }\n\n        createExportOfCurrentData(filename: string) {\n            let self = this,\n                //exporter variables\n                configSets = self.configSets,\n                dataSet = self.dataSet,\n                metadata = self.metaData,\n                tableDataArr = [],\n                workbook = { SheetNames: [], Sheets: {} },\n                workbookOutput,\n                delimiter = \",\",\n                arrStream,\n                bookType = self.bookType;\n\n            //Generate single table from multiple datasources\n            if (configSets && _.keys(configSets).length) {\n                _.each(configSets, function(configSet) {\n                    tableDataArr.push(\n                        FileExportDataGenerator.getFormData(\n                            configSet.dataSet,\n                            configSet.metaData,\n                            bookType,\n                        ),\n                    );\n                });\n            } else if (dataSet && dataSet.length && metadata && metadata.length) {\n                tableDataArr[0] = FileExportDataGenerator.getFormData(dataSet, metadata, bookType);\n            }\n\n            //Check that data is present\n            if (tableDataArr.length && tableDataArr[0].data.length) {\n                _.each(tableDataArr, function(tableData, ix) {\n                    let ws_name, worksheet;\n\n                    //get datasource name here\n                    ws_name = self.workSheetTitle || \"Work_sheet\";\n                    ws_name += tableDataArr.length > 1 ? \"_\" + ix : \"\";\n\n                    //convert table data JSsheet compatible format\n                    worksheet = self.convertDataToWorksheet(\n                        tableData.data,\n                        tableData.columnHeaders,\n                    );\n\n                    // add new sheet name to workbook\n                    workbook.SheetNames.push(ws_name);\n                    // add worksheet with data to workbook\n                    workbook.Sheets[ws_name] = worksheet;\n                    // process workbook and create export output\n                });\n\n                if (bookType !== \"csv\") {\n                    workbookOutput = XLSX.write(workbook, {\n                        bookType: bookType,\n                        bookSST: false,\n                        type: \"binary\",\n                    });\n\n                    arrStream = FileExport.s2ab(workbookOutput);\n                    self.downloadExportFile(filename, arrStream);\n                } else {\n                    let index = 1;\n                    if (self.csvExportDelimiter && self.csvExportDelimiter.length) {\n                        delimiter = self.csvExportDelimiter;\n                    }\n\n                    _.each(workbook.Sheets, function(worksheet) {\n                        // If multiple files append part string to export name\n                        const newPartName =\n                            tableDataArr.length > 1\n                                ? filename.slice(0, -4) + \"part\" + index + \".csv\"\n                                : filename;\n\n                        try {\n                            workbookOutput = XLSX.utils.sheet_to_csv(worksheet, { FS: delimiter });\n                        } catch (err) {\n                            console.log(\"Error\", err);\n                            return;\n                        }\n\n                        /* CSV Export is string of comma separated values devided in to \n                            rows by new line character */\n                        //fix:KXAX-2956 \"ID\" column caused excel to show warning when opening csv\n                        //get index of ID string in header substring\n                        if (workbookOutput.indexOf(\"ID\") === 0) {\n                            // Escape special characters if used as delimiter\n                            if (/[-\\+\\{\\}\\[\\]\\?\\^\\*\\.\\|\\$]/.test(delimiter)) {\n                                delimiter = \"\\\\\" + delimiter;\n                            }\n                            const regex = new RegExp(\"(ID[^\" + delimiter + \"\\n]*)\");\n                            workbookOutput = workbookOutput.replace(regex, '\"$1\"');\n                        }\n\n                        self.downloadExportFile(newPartName, workbookOutput);\n\n                        index += 1;\n                    });\n                }\n            } else {\n                console.error(\"Data formatter function returned invalid parameter or no data\");\n            }\n        }\n\n        downloadExportFile(filename, data) {\n            let blob,\n                link,\n                //required for download\n                contentType = \"application/octet-stream\";\n\n            // Download Exported file\n            link = document.createElement(\"a\");\n\n            if (window.Blob) {\n                blob = new Blob([data], {\n                    type: contentType,\n                });\n\n                if (window.navigator.msSaveOrOpenBlob) {\n                    //IE fix\n                    link.onclick = function() {\n                        window.navigator.msSaveOrOpenBlob(blob, filename);\n                    };\n                } else {\n                    if (link.download !== undefined) {\n                        link.setAttribute(\"href\", URL.createObjectURL(blob));\n                    }\n                }\n            } else {\n                link.setAttribute(\"href\", encodeURI(contentType + \",\" + data));\n            }\n\n            if (link.download !== undefined) {\n                link.setAttribute(\"download\", filename);\n            }\n\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n        }\n\n        /*\n         * Call this function to start file export process\n         */\n        showDialog() {\n            let self = this,\n                defaultName,\n                fileFormat = self.fileFormat,\n                namePrefix = {\n                    \".csv\": \"Csv\",\n                    \".xlsx\": \"Excel\",\n                }[fileFormat];\n\n            //generate default file name\n            defaultName = self.fileName + fileFormat;\n\n            SimpleInputDialog.ShowInput(\n                function() {\n                    let filename = this.inputValue;\n\n                    filename = \"\" + filename || ExportTools.getDefaultExportFileName(namePrefix);\n                    // Sanitize file name\n                    filename = filename.replace(/:/g, \"-\").replace(/[^\\w \\.\\-]/g, \"\");\n                    //validate file extention name at the end of the string\n                    if (!new RegExp(fileFormat + \"$\").test(filename)) {\n                        filename += fileFormat;\n                    }\n                    self.createExportOfCurrentData(filename);\n                },\n                t(\"Export file\"),\n                t(\"Please enter the filename\"),\n                \"fa fa-download\",\n                defaultName,\n                \"\",\n                true,\n            );\n        }\n\n        /**Set of functions for Excel/csv converter convert  -\n         * function example from http://sheetjs.com/demos/writexlsx.html\n         * @param data {obj} - expected values\n         * @param resetIndexes {obj} - where key is a index of columns to be set to string\n         */\n        convertDataToWorksheet(data, columnHeaders) {\n            //as many as column you have in data, columnInfo-array has the same length\n\n            const ws = {},\n                range = { s: { c: 10000000, r: 10000000 }, e: { c: 0, r: 0 } },\n                datenum = function datenum(v, date1904) {\n                    if (date1904) v += 1462;\n                    const epoch = Date.parse(v);\n                    return (\n                        (epoch - new Date(Date.UTC(1899, 11, 30)).getTime()) / (24 * 60 * 60 * 1000)\n                    );\n                };\n            //parse row index\n            for (let R = 0; R != data.length; ++R) {\n                //parse cell index\n                for (let C = 0; C != data[R].length; ++C) {\n                    if (range.s.r > R) range.s.r = R;\n                    if (range.s.c > C) range.s.c = C;\n                    if (range.e.r < R) range.e.r = R;\n                    if (range.e.c < C) range.e.c = C;\n\n                    let cellVals = data[R][C],\n                        //check if cell has type override\n                        type =\n                            cellVals.type !== undefined && cellVals.type !== \"\"\n                                ? cellVals.type\n                                : columnHeaders[C][\"type\"],\n                        format = cellVals.format ? cellVals.format : columnHeaders[C][\"format\"],\n                        cell: XLSX.CellObject = {} as XLSX.CellObject;\n\n                    if (type === null) {\n                        continue;\n                    }\n\n                    //facility to reset all cell in the column to the\n                    // same type used if number digits length is > 16\n                    if (columnHeaders[C][\"isStringType\"]) {\n                        type = \"String\";\n                        //use unformatted value that\n                        cellVals.value = cellVals.formattedVal || cellVals.value;\n                    }\n\n                    //map to excel table values\n                    const cell_ref = XLSX.utils.encode_cell({ c: C, r: R });\n\n                    //use XLSX.SSF.get_table() to ccheck all formats and their indexes\n                    //XLSX.SSF.format(formatindex, value) in some cases show output val\n                    switch (type) {\n                        case \"Number\":\n                            if (format) {\n                                cell.t = \"n\";\n                                cell.z = format;\n                            } else {\n                                cell.t = \"s\";\n                            }\n                            break;\n                        case \"Boolean\":\n                            cell.t = \"b\"; //must be Boolean and not string\n                            break;\n                        case \"Date\":\n                            cell.t = \"d\";\n                            cell.z = format;\n                            break;\n                        case \"DateTime\":\n                            cell.t = \"d\";\n                            cell.z = format;\n                            break;\n                        //String and Time handled here\n                        default:\n                            cell.t = \"s\";\n                            break;\n                    }\n\n                    cell.s = { alignment: { horizontal: \"top\" } };\n                    cell.v = cellVals.value;\n                    ws[cell_ref] = cell;\n                }\n            }\n            if (range.s.c < 10000000) ws[\"!ref\"] = XLSX.utils.encode_range(range);\n            return ws;\n        }\n\n        // Create array buffer for download\n        private static s2ab(s) {\n            const buf = new ArrayBuffer(s.length);\n            const view = new Uint8Array(buf);\n            for (let i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) & 0xff;\n            return buf;\n        }\n    }\n}\n","/*global $, T, Backbone, FormSchemas, BBForm, DialogBase*/\n/// <reference path=\"../templates/combined.ts\" />\n/// <reference path=\"DialogBase.ts\" />\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class ErrorDialog extends DialogBase {\n        constructor(options) {\n            super(\n                _.extend(\n                    {\n                        iconClass: \"fa-exclamation-triangle\",\n                        dialogTitle: \"Error\",\n                        minHeight: 110,\n                        width: 275,\n                    },\n                    options,\n                    {\n                        userClass:\n                            \"error-dialog\" + (options.userClass ? \" \" + options.userClass : \"\"),\n                    },\n                ),\n            );\n        }\n\n        dialogButtons() {\n            return [\n                {\n                    text: \"OK\",\n                    click: () => {\n                        this.dialogClose();\n                    },\n                    icons: {\n                        primary: \"fa fa-check\",\n                    },\n                },\n            ];\n        }\n\n        renderTemplate() {\n            return t(\"Are you sure you want to delete this item?\");\n        }\n\n        static ShowError(text, callbackFn?: () => void) {\n            new ErrorDialog(\n                _.extend(\n                    {\n                        callback: _.isFunction(callbackFn) ? callbackFn : _.noop,\n                    },\n                    text\n                        ? {\n                              renderTemplate: () => {\n                                  return text;\n                              },\n                          }\n                        : {},\n                ),\n            );\n        }\n    }\n}\n","/*global _,$,Backbone,console */\n/// <reference path=\"../templates/combined.ts\" />\n/// <reference path=\"ExportTools.ts\" />\n/// <reference path=\"../views/ErrorDialog.ts\" />\n// eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class FileExporterView extends Backbone.View<Backbone.Model> {\n        DATA_SOURCE_PROPERTY = \"Basics.Data\";\n        EXPORT_PROPERTY_OBJECT = \"FileExport\";\n        EXPORT_PROPERTY_KEYS = [\n            \"ShowExportCsvButton\",\n            \"ShowExportExcelButton\",\n            \"ShowFullExportButton\",\n            \"ShowClipboard\",\n            \"ShowScreenshot\",\n        ];\n\n        api: any;\n        appViewModel: Backbone.Model;\n\n        isIE: boolean;\n\n        $lnkCopyScreenshot: JQuery;\n        $lnkCsvExport: JQuery;\n        $lnkDownloadScreenshot: JQuery;\n        $lnkExcelExport: JQuery;\n        $lnksExport: JQuery;\n        $lnkFullExport: JQuery;\n        $lnksScreenshot: JQuery;\n        $root: JQuery;\n\n        fileExport: (f: any) => void;\n        getExportConfig: () => any;\n        getSvgNode: () => any;\n\n        SETTINGS: Array<string>;\n\n        constructor(options) {\n            super(options);\n            // this is used by\n            _.extend(this, _.pick(options, this.SETTINGS));\n\n            this.isIE =\n                HTMLCanvasElement &&\n                HTMLCanvasElement.prototype &&\n                (HTMLCanvasElement as any).prototype.msToBlob;\n\n            this.$el.html(T.fileExporter({}));\n\n            this.$root = this.$el.find(\">.pnlButtons\");\n            this.$lnksExport = this.$el.find(\".lnksExport\");\n            this.$lnkCsvExport = this.$el.find(\"a.lnkCsvExport\");\n            this.$lnkExcelExport = this.$el.find(\"a.lnkExcelExport\");\n            this.$lnkFullExport = this.$el.find(\"a.lnkFullExport\");\n            this.$lnksScreenshot = this.$el.find(\".lnksScreenshot\");\n            this.$lnkCopyScreenshot = this.$el.find(\"a.lnkCopyScreenshot\");\n            this.$lnkDownloadScreenshot = this.$el.find(\"a.lnkDownloadScreenshot\");\n\n            this.initializeEvents();\n        }\n\n        initializeEvents() {\n            this.listenTo(\n                this.appViewModel,\n                \"change:\" +\n                    this.EXPORT_PROPERTY_OBJECT +\n                    this.EXPORT_PROPERTY_KEYS.concat(\" change:\" + this.EXPORT_PROPERTY_OBJECT),\n                this.displayChoiceLinkButtons,\n            );\n\n            //important arugment is file extension string\n            this.$lnkCsvExport.click(_.bind(this.fileExport, this, \".csv\"));\n            this.$lnkExcelExport.click(_.bind(this.fileExport, this, \".xlsx\"));\n            this.$lnkFullExport.click(_.bind(this.apiExport, this));\n            this.$lnkDownloadScreenshot.click(_.bind(this.downloadImage, this));\n        }\n\n        apiExport() {\n            let self = this,\n                $spinner,\n                exportConfig = this.getExportConfig(),\n                exportFileName = ExportTools.getExportFileName(\n                    exportConfig.fileName,\n                    exportConfig.altFileName,\n                    \"FullExport\",\n                );\n\n            $spinner = $(\"<span />\")\n                .addClass(\"export-spinner fa fa-spinner fa-pulse\")\n                .attr(\"title\", t(\"Download in progress\"))\n                .appendTo(this.$lnkFullExport);\n            self.$lnkFullExport.addClass(\"export-in-progress\");\n\n            self.api.exportData(\n                this.appViewModel.get(self.DATA_SOURCE_PROPERTY),\n                function() {\n                    $spinner.remove();\n                    self.$lnkFullExport.removeClass(\"export-in-progress\");\n                },\n                { exportName: exportFileName },\n            );\n        }\n\n        displayChoiceLinkButtons() {\n            let changedFileExport = false,\n                redrawChart = false;\n\n            const settings = this.appViewModel.get(this.EXPORT_PROPERTY_OBJECT);\n\n            if (!settings) {\n                return;\n            }\n\n            if (settings.changed) {\n                changedFileExport = true;\n            }\n\n            if (\n                settings.ShowExportCsvButton ||\n                settings.ShowExportExcelButton ||\n                settings.ShowFullExportButton ||\n                (settings.ShowScreenshot && !this.isIE)\n            ) {\n                //redraw chart if links panel was not visible\n                if (this.$lnksExport.hasClass(\"link-disabled\") && changedFileExport) {\n                    redrawChart = true;\n                }\n\n                this.$lnksExport.removeClass(\"link-disabled\");\n                this.$lnkCsvExport.toggleClass(\"link-disabled\", !settings.ShowExportCsvButton);\n                this.$lnkExcelExport.toggleClass(\"link-disabled\", !settings.ShowExportExcelButton);\n                this.$lnkFullExport.toggleClass(\"link-disabled\", !settings.ShowFullExportButton);\n                this.$lnkDownloadScreenshot.toggleClass(\n                    \"link-disabled\",\n                    !(settings.ShowScreenshot && !this.isIE),\n                );\n            } else {\n                this.$lnksExport.addClass(\"link-disabled\");\n\n                if (changedFileExport) {\n                    redrawChart = true;\n                }\n            }\n\n            if (\n                settings.ShowExportCsvButton ||\n                settings.ShowExportExcelButton ||\n                settings.ShowFullExportButton ||\n                (settings.ShowScreenshot && !this.isIE)\n            ) {\n                this.trigger(\"enable-links\");\n            } else {\n                this.trigger(\"disable-links\");\n            }\n\n            if (redrawChart) {\n                this.trigger(\"redraw-chart\");\n            }\n        }\n\n        downloadImage() {\n            let fileName = this.getFileName();\n\n            fileName = _.isString(fileName) && fileName.length ? fileName : \"Screenshot\";\n\n            fileName += \".png\";\n\n            this.generateImage(function(blob) {\n                Tools.fileSave(fileName, blob);\n            });\n        }\n\n        generateImage(callback) {\n            let boundingRect,\n                canvas = document.createElement(\"canvas\"),\n                context = canvas.getContext(\"2d\"),\n                height,\n                image = new Image(),\n                width,\n                svgBlob,\n                svgBlobUrl,\n                svgNode = this.getSvgNode(),\n                svgString;\n\n            boundingRect = svgNode.getBoundingClientRect();\n            height = Math.round(boundingRect.height);\n            width = Math.round(boundingRect.width);\n\n            canvas.width = width;\n            canvas.height = height;\n            canvas.style.display = \"block\";\n\n            svgNode.style.width = width;\n            svgNode.style.height = height;\n            svgString = getSVGString(svgNode);\n\n            if (this.isIE) {\n                alert(\"This feature is not supported in your browser\");\n                return;\n            }\n\n            context.clearRect(0, 0, width, height);\n            context.fillStyle = getBackroundColor(svgNode);\n            context.fillRect(0, 0, width, height); // copy background colour\n\n            svgBlob = new Blob([svgString], { type: \"image/svg+xml;charset=utf-8\" });\n            svgBlobUrl = URL.createObjectURL(svgBlob);\n\n            image.onload = function() {\n                URL.revokeObjectURL(svgBlobUrl);\n                context.drawImage(image, 0, 0);\n                canvas.toBlob(callback);\n            };\n\n            image.src = svgBlobUrl;\n\n            function getSVGString(svgNode) {\n                const svgNodeClone = cloneWithStyle(svgNode);\n\n                const serializer = new XMLSerializer();\n                let svgString = serializer.serializeToString(svgNodeClone);\n                svgString = svgString.replace(\n                    /<svg/,\n                    '<svg width=\"' + width + '\" height=\"' + height + '\"',\n                );\n                svgString = svgString.replace(/(\\w+)?:?xlink=/g, \"xmlns:xlink=\"); // Fix root xlink without namespace\n                svgString = svgString.replace(/NS\\d+:href/g, \"xlink:href\"); // Safari NS namespace fix\n                // see https://stackoverflow.com/questions/12625876/how-to-detect-chrome-and-safari-browser-webkit#answer-12625944\n                const isChrome =\n                    /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\n                if (isChrome) {\n                    // for once it's chrome being annoying\n                    let rex;\n                    while ((rex = /(<rect[^>]*) style=\"[^>]*\"([^>]*>)/.exec(svgString))) {\n                        svgString = svgString.replace(rex[0], rex[1] + rex[2]);\n                    }\n                }\n                return svgString;\n\n                function cloneWithStyle(node) {\n                    const source = node,\n                        target = node.cloneNode(true);\n                    target.style.cssText = getComputedStyle(source);\n                    const sourceElements = source.getElementsByTagName(\"*\");\n                    const targetElements = target.getElementsByTagName(\"*\");\n                    for (let i = sourceElements.length; i--; ) {\n                        const sourceElement = sourceElements[i];\n                        const targetElement = targetElements[i];\n                        targetElement.style.cssText = getComputedStyle(sourceElement);\n                    }\n                    return target;\n                }\n            }\n\n            function getComputedStyle(node) {\n                // because FF computedStyle.cssText is lazy\n                const vanillaComputedStyle = document.defaultView.getComputedStyle(node, \"\");\n                try {\n                    return (\n                        vanillaComputedStyle.cssText ||\n                        Array.from(vanillaComputedStyle)\n                            .reduce(function(a, b) {\n                                return a + b + \": \" + vanillaComputedStyle[b] + \"; \";\n                            }, \"\")\n                            .trim()\n                    );\n                } catch (e) {\n                    // IE will choke on Array.from but who cares\n                    return \"\";\n                }\n            }\n\n            function getBackroundColor(svgNode) {\n                const color = document.defaultView.getComputedStyle(svgNode)[\"background-color\"];\n                return /^rgb\\(/.test(color) ? color : getBackroundColor(svgNode.parentNode);\n            }\n        }\n\n        getButtonSettings() {}\n\n        getFileName() {\n            let config = this.getExportConfig(),\n                fileName = \"\";\n            if (\n                _.isObject(config) &&\n                ((_.isArray(config.fileName) && config.fileName.length) || config.altFileName)\n            ) {\n                fileName = ExportTools.getExportFileName(config.fileName, config.altFileName, \"\");\n            }\n\n            return fileName;\n        }\n\n        remove() {\n            this.$lnkCsvExport.off();\n            this.$lnkExcelExport.off();\n            this.$lnkFullExport.off();\n            this.$lnkCopyScreenshot.off();\n            this.$lnkDownloadScreenshot.off();\n\n            return Backbone.View.prototype.remove.apply(this, arguments);\n        }\n\n        //Show error if chart is pivot chart\n        showExportError(textMsg) {\n            var textMsg = textMsg || \"Export of .csv or .xlsx for pivot charts is not supported.\";\n            ErrorDialog.ShowError(textMsg);\n        }\n    }\n\n    // setting need to be set on prototype\n    FileExporterView.prototype.SETTINGS = [\"api\", \"appViewModel\"];\n}\n","/*global _,$,Backbone,console, xlsx*/\n/// <reference path=\"FileExport.ts\" />\n/// <reference path=\"fileExporterView.ts\" />\n\n/*\n * Config generator tool has to be used to generate config for fileExport that creates\n * fully compatible structure with strict parameter validation\n */ // eslint-disable-next-line @typescript-eslint/no-namespace,@typescript-eslint/no-unused-vars\nnamespace QuickBase {\n    export class ExportTools {\n        static FileExporterView = FileExporterView;\n\n        //add chart date formats here\n        static CHARTS_DATETIME_FORMAT_MAP = {\n            \"YYYY-MM-DD HH:mm:ss\": \"YYYY-MM-DD HH:mm:ss\",\n            \"YYYY-MM-DD hh:mm:ss\": \"YYYY-MM-DD hh:mm:ss\", //test\n            \"YYYY-MM-DD kk:mm:ss\": \"YYYY-MM-DD kk:mm:ss\", //test\n            \"YYYY-MM-DD HH:mm:ss.SSS\": \"YYYY-MM-DD HH:mm:ss.SSS\",\n            \"YYYY-MM-DD HH:mm:ss.SSSSSS\": \"YYYY-MM-DD HH:mm:ss.SSSSSS\",\n            \"YYYY-MM-DD HH:mm:ss.SSSSSSSSS\": \"YYYY-MM-DD HH:mm:ss.SSSSSSSSS\",\n        };\n\n        //Taken from in Tools.Formats\n        static TIME_FORMAT_MAP = {\n            \"HH:mm\": \"HH:mm\",\n            \"HH:mm:ss\": \"HH:mm:ss\",\n            \"hh:mm:ss\": \"hh:mm:ss\", //test\n            \"kk:mm:ss\": \"kk:mm:ss\", //test\n            \"hh:mm:ss.SS\": \"hh:mm:ss.SS\", //test\n            \"HH:mm:ss.SSS\": \"HH:mm:ss.SSS\",\n            \"HH:mm:ss.SSSSSS\": \"HH:mm:ss.SSSSSS\",\n            \"HH:mm:ss.SSSSSSSSS\": \"HH:mm:ss.SSSSSSSSS\",\n            \"mm:ss\": \"mm:ss\",\n            \"kk:mm\": \"kk:mm\", //test\n            \"mm:ss.SS\": \"mm:ss.SS\",\n            \"mm:ss.SSS\": \"mm:ss.SSS\",\n            \"mm:ss.SSSSSS\": \"mm:ss.SSSSSS\",\n            \"mm:ss.SSSSSSSSS\": \"mm:ss.SSSSSSSSS\",\n            ss: \"ss\",\n            \"ss.SSS\": \"ss.SSS\",\n            \"ss.SSSSSS\": \"ss.SSSSSS\",\n            \"ss.SSSSSSSSS\": \"ss.SSSSSSSSS\",\n        };\n\n        //Taken from in Tools.Formats\n        static DATE_FORMAT_MAP = {\n            \"YYYY-MM-DD\": \"YYYY-MM-DD\",\n            \"DD.MM.YYYY\":  \"DD.MM.YYYY\",\n            \"YYYY-MMM-DD\": \"YYYY-MMM-DD\",\n            \"YYYY-MMMM-DD\": \"YYYY-MMMM-DD\",\n            \"YYYY-MM\": \"YYYY-MM\",\n            \"YYYY-MMM\": \"YYYY-MMM\",\n            \"YYYY-MMMM\": \"YYYY-MMMM\",\n            \"MM/DD/YYYY\": \"MM/DD/YYYY\",\n            \"DD/MM/YYYY\": \"DD/MM/YYYY\",\n            \"D/M/YYYY\": \"D/M/YYYY\",\n            \"M/D/YYYY\": \"M/D/YYYY\",\n            \"D/M/YY\": \"D/M/YY\",\n            \"M/D/YY\": \"M/D/YY\",\n            \"D MMM\": \"D MMM\",\n            \"D MMM YYYY\": \"D MMM YYYY\",\n            \"MMM D\": \"MMM D\",\n            \"MMM DD\": \"MMM DD\",\n            \"MMM Do\": \"MMM Do\", //test\n            \"MMM D, YYYY\": \"MMM D, YYYY\",\n            //for kdb month type\n            \"MM/YYYY\": \"MM/YYYY\",\n            \"M/YY\": \"M/YY\",\n            \"MMM YYYY\": \"MMM YYYY\",\n        };\n\n        static CHARTS_DATE_FORMAT_MAP = _.extend(\n            {},\n            ExportTools.DATE_FORMAT_MAP,\n            ExportTools.TIME_FORMAT_MAP,\n            ExportTools.CHARTS_DATETIME_FORMAT_MAP,\n        );\n\n        //add chart number formats here\n        static CHARTS_NUMBERS_FORMAT_MAP = {\n            \"no decimal\": \"0\",\n            \"No Decimal Point\": \"0\",\n            \"0\": \"0\",\n            \"1\": \"#0.0\",\n            \"1 decimal\": \"#0.0\",\n            \"1 Decimal Points\": \"#0.0\",\n            \"2\": \"#0.00\",\n            \"2 decimal\": \"#0.00\",\n            \"2 Decimal Points\": \"#0.00\",\n            \"3\": \"#0.000\",\n            \"3 decimal\": \"#0.000\",\n            \"3 Decimal Points\": \"#0.000\",\n            \"4\": \"#0.0000\",\n            \"4 decimal\": \"#0.0000\",\n            \"4 Decimal Points\": \"#0.0000\",\n            \"5\": \"#0.00000\",\n            \"5 Decimal Points\": \"#0.00000\",\n            \"6\": \"#0.000000\",\n            \"6 Decimal Points\": \"#0.000000\",\n            \"no decimal + seperator\": \"#,##0\",\n            \"1 decimal + seperator\": \"#,##0.0\",\n            \"2 decimal + seperator\": \"#,##0.00\",\n            \"3 decimal + seperator\": \"#,##0.000\",\n            \"4 decimal + seperator\": \"#,##0.0000\",\n            \"Smart Number\": \"SmartNumber\", //smart number without decimals\n            Logarithmic: \"\",\n            \"no format\": \"\",\n        };\n\n        static CHARTS_DATA_FORMAT_MAP = _.extend(\n            {},\n            ExportTools.CHARTS_DATE_FORMAT_MAP,\n            ExportTools.CHARTS_NUMBERS_FORMAT_MAP,\n        );\n\n        //check if format compatible with selected col type and modify if necessary\n        static resolveChartColumnFormatAndType(dataType, dataRawFormat, dataKdbType) {\n            let dataFormat = ExportTools.CHARTS_DATA_FORMAT_MAP[dataRawFormat],\n                isFormatTypeDate = ExportTools.CHARTS_DATE_FORMAT_MAP[dataFormat] ? true : false,\n                isValTypeFloat = dataKdbType === 8 || dataKdbType === 9 ? true : false,\n                isValTypeDate = dataKdbType > 11 && dataKdbType < 20 ? true : false,\n                //include string and symbol\n                isValTypeNumber = dataKdbType > 3 && dataKdbType < 10 ? true : false;\n            //if unsupported type force convert to string\n            if (dataKdbType === 3 || dataKdbType < 1 || dataKdbType > 19) {\n                dataKdbType = 11;\n                dataFormat = \"TO_STRING\";\n                dataType = \"String\";\n            } else {\n                //remove decimals if kdb type is not float or real\n                if (!isFormatTypeDate && !isValTypeFloat && dataFormat.indexOf(\".\") !== -1) {\n                    dataFormat = dataFormat.split(\".\")[0];\n                }\n\n                //validating that format is in the list\n                if (dataFormat === undefined) {\n                    console.log(\n                        \"Invalid format: \" +\n                            dataFormat +\n                            \" or kdbType: \" +\n                            dataKdbType +\n                            \". Exporting with default formats as String type\",\n                    );\n                    dataFormat = \"\";\n                    dataType = \"String\";\n                } else {\n                    //Apply default formatters if selected type is string\n                    if (dataType === \"String\") {\n                        dataFormat = \"\";\n                    }\n                    //case Date val type AND format NOT date OR dataType Number\n                    else if (isValTypeDate && (dataType === \"Number\" || !isFormatTypeDate)) {\n                        dataType = \"String\";\n                        dataFormat = \"\";\n                        console.log(\n                            \"!ExportTools format mismatch, using default format.\" +\n                                \"Params, value kdbType : \" +\n                                dataKdbType +\n                                \", col type: \" +\n                                dataType +\n                                \", format: \" +\n                                dataRawFormat,\n                        );\n                        //case Number val type AND format IS date OR dataType Date\n                    } else if (!isValTypeDate && (isFormatTypeDate || dataType === \"Date\")) {\n                        dataType = \"String\";\n                        dataFormat = \"\";\n                        console.log(\n                            \"!ExportTools format mismatch, using default format.\" +\n                                \"Params, value kdbType : \" +\n                                dataKdbType +\n                                \", col type: \" +\n                                dataType +\n                                \", format: \" +\n                                dataRawFormat,\n                        );\n                    } else if (dataType === \"Number\" && !isValTypeNumber) {\n                        //avoid attempting to export Number\n                        dataType = \"String\";\n                    }\n                    //Resolve subtype of Date based on format\n                    if (dataType === \"Date\" && isFormatTypeDate) {\n                        dataType = ExportTools.getTemporalTypeFromFormat(dataFormat);\n                    }\n                    //Export smart number as string\n                    if (dataFormat.indexOf(\"SmartNumber\") === 0) {\n                        dataType = \"String\";\n                    }\n                }\n            }\n            //Force boolean otherwise columns is not exported\n            if (dataKdbType === 1) {\n                dataType = \"Boolean\";\n            }\n            return { dataType: dataType, dataFormat: dataFormat, dataKdbType: dataKdbType };\n        }\n\n        /* Get filename string from object extracted from \n        viewModel.get(\"FileExport.FileName\") Should be same for all components */\n        static getExportFileName(fileName, altFileName, componentId) {\n            let fileNameParts;\n\n            if (fileName && _.isObject(fileName)) {\n                fileNameParts = _.map(fileName, function(p) {\n                    p = p[\"FileNamePart\"];\n                    //dictionary converts to empty string\n                    if (p === null || _.isObject(p)) {\n                        p = \"\";\n                    }\n                    return p.toString();\n                });\n                fileName = fileNameParts.join(\"\");\n            }\n\n            if (!fileName) {\n                if (altFileName) {\n                    fileName = altFileName;\n                } else {\n                    fileName = ExportTools.getDefaultExportFileName(componentId);\n                }\n            }\n            //sanitize filename\n            //replace all chars apart from: AZ az 09 . _ - (empty space)\n            fileName = fileName.replace(/:/g, \"-\").replace(/[^\\w \\.\\-]/g, \"\");\n\n            return fileName;\n        }\n\n        static getDefaultExportFileName(namePrefix) {\n            let date,\n                month,\n                day,\n                name = namePrefix ? namePrefix + \"_\" : \"\",\n                convertTo2digit = function(c) {\n                    c = \"\" + c;\n                    if (c.length === 1) {\n                        c = \"0\" + c;\n                    }\n                    return c;\n                };\n\n            date = new Date();\n            month = date.getMonth() + 1;\n            day = date.getDate();\n\n            return name + date.getFullYear() + convertTo2digit(month) + convertTo2digit(day);\n        }\n\n        /**\n         * Helper function to toggle full export link inactive\n         * @param {object} docDataModel - document data model of the data source \n         * @param {object} linkExport - full export link jquery object\n         */\n        static onQueryChange(docDataModel: QuickBase.DocumentDataModel, linkExport: JQuery): void {\n            // If no datasource or full export is disabled do nothing\n            if (docDataModel) {\n                var queryType = docDataModel.get(\"_dataType\"),\n                    subscriptionType = docDataModel.get(\"_subscriptionType\");\n\n                if (queryType === \"virtual\" || subscriptionType === \"streaming\") {\n                    linkExport.toggleClass(\"events-disabled\", true);\n                    linkExport.attr(\n                        \"title\",\n                        t(\n                            \"Full export is not supported in Virtual and Streaming queries\",\n                        ),\n                    );\n                } else {\n                    linkExport.toggleClass(\"events-disabled\", false);\n                    linkExport.attr(\n                        \"title\",\n                        t(\"Download the full dataset from the server\"),\n                    );\n                }\n            }\n        }\n        \n        //static function\n        static openFileExportDialog(config) {\n            //private variable\n            const args = config,\n                fileExportParams = {};\n            try {\n                if (_.keys(args).length >= 4) {\n                    if (args.configSets && _.keys(args.configSets).length) {\n                        fileExportParams[\"configSets\"] = args.configSets;\n                    } else {\n                        //check that dataSet is an Array of Object\n                        if (\n                            args.dataSet &&\n                            _.isArray(args.dataSet) &&\n                            _.isObject(args.dataSet[0])\n                        ) {\n                            fileExportParams[\"dataSet\"] = args.dataSet;\n                        } else {\n                            throw \"Missing or invalid dataSet parameter\";\n                        }\n\n                        //check that metadata is JSON object with specific keys\n                        if (args.metaData && _.isArray(args.metaData)) {\n                            //check if metaData object contain expected keys\n                            if (_validateMetaData(args.metaData)) {\n                                fileExportParams[\"metaData\"] = args.metaData;\n                            } else {\n                                throw \"Invalid metaData properities.\";\n                            }\n                        } else {\n                            throw \"Missing or invalid metaData parameter\";\n                        }\n                    }\n                    //check fileFormat is specified\n                    if (\n                        args.fileFormat !== undefined &&\n                        _.isString(args.fileFormat) &&\n                        _.includes([\".xlsx\", \".xls\", \".csv\"], args.fileFormat)\n                    ) {\n                        fileExportParams[\"fileFormat\"] = args.fileFormat;\n                    } else {\n                        throw \"Invalid file format property\";\n                    }\n\n                    //check fileName is string, can be empty string\n                    if (args.fileName !== undefined && _.isString(args.fileName)) {\n                        fileExportParams[\"fileName\"] = args.fileName;\n                    } else {\n                        throw \"Invalid file name property\";\n                    }\n\n                    //same as file name\n                    if (args.workSheetTitle !== undefined && _.isString(args.workSheetTitle)) {\n                        fileExportParams[\"workSheetTitle\"] = args.workSheetTitle;\n                    } else {\n                        throw \"Invalid workSheetTitle property\";\n                    }\n\n                    /* Optional csv export delimiter */\n                    if (\n                        args.csvExportDelimiter !== undefined &&\n                        _.isString(args.csvExportDelimiter)\n                    ) {\n                        fileExportParams[\"csvExportDelimiter\"] = args.csvExportDelimiter;\n                    }\n\n                    //all pass execute FileExport\n                    const fileExport = new FileExport(fileExportParams);\n\n                    fileExport.showDialog();\n                } else {\n                    throw \"Incorrect number of FileExport parameters expected 5, got: \" +\n                        args.length;\n                }\n                // Check if error message needs handling for end user\n            } catch (e) {\n                console.error(\"FileConverterTools validation error: \", e);\n            }\n            //TODO add ISOWeekDay param for canvas charts add in all config generators\n            function _validateMetaData(metaData) {\n                const isMetaDataValid = _.every(metaData, function(meta) {\n                    //check if all keys are present\n                    const isMetaDataKeysValid =\n                            _.difference(_.keys(meta), [\n                                \"colId\",\n                                \"dataType\",\n                                \"dataKdbType\",\n                                \"dataFormat\",\n                                \"hideTrailingZeroes\",\n                                \"prefix\",\n                                \"suffix\",\n                                \"colName\",\n                            ]).length === 0,\n                        isValidKdbType =\n                            meta.dataKdbType > 0 && meta.dataKdbType < 20 && meta.dataKdbType !== 3;\n                    if (isMetaDataKeysValid && isValidKdbType) {\n                        //review format checking\n                        //&& validateFormat(meta.dataFormat)\n                        return true;\n                    } else {\n                        return false;\n                    }\n                });\n                return isMetaDataValid;\n            }\n\n            //TODO Review this\n            // Map to validate valid formats\n            function _validateFormat(formatStr) {\n                let isValid = false,\n                    decimalRegEx = /^[0]{1,10}$/g, //match decimal 0s between 1 and 10\n                    validNumberFormatArr = [\"0\", \"0.0%\", \"0.00%\"],\n                    validStringFormatArr = [\n                        \"\",\n                        \"SmartNumber\", //smart number without decimals\n                        \"YYYY-MM-DD\",\n                        \"MM/DD/YYYY\",\n                        \"D/M/YYYY\",\n                        \"M/D/YYYY\",\n                        \"D/M/YY\",\n                        \"M/D/YY\",\n                        \"YYYY-MMM-DD\",\n                        \"D MMM\",\n                        \"D MMM YYYY\",\n                        \"MMM D\",\n                        \"MMM D, YYYY\", //dates formats\n                        \"HH:mm\",\n                        \"HH:mm:ss\",\n                        \"HH:mm:ss.SSS\",\n                        \"HH:mm:ss.SSSSSS\",\n                        \"HH:mm:ss.SSSSSSSSS\",\n                        \"mm:ss\",\n                        \"mm:ss.SSS\",\n                        \"Mm:ss.SSSSSS\",\n                        \"mm:ss.SSSSSSSSS\",\n                        \"ss\",\n                        \"ss.SSS\",\n                        \"ss.SSSSSS\",\n                        \"ss.SSSSSSSSS\", //time fomats\n                        \"YYYY-MM-DD HH:mm:ss\",\n                        \"YYYY-MM-DD HH:mm:ss.SSS\",\n                        \"YYYY-MM-DD HH:mm:ss.SSSSSS\",\n                        \"YYYY-MM-DD HH:mm:ss.SSSSSSSSS\", // date time formats\n                    ];\n\n                //check non deciaml and datetime formats\n                if (\n                    _.includes(validStringFormatArr, formatStr) ||\n                    _.includes(validNumberFormatArr, formatStr)\n                ) {\n                    isValid = true;\n                    /*case with formater with decimal places. \n                    Check only one decimal delimeter */\n                } else if (\n                    formatStr.indexOf(\".\") !== -1 &&\n                    formatStr.split(\".\").length === 2 &&\n                    (formatStr.indexOf(\"#0.\") !== -1 ||\n                        formatStr.indexOf(\"#,##0.\") !== -1 ||\n                        formatStr.indexOf(\"SmartNumber.0\") !== -1)\n                ) {\n                    //number of trailing decimal zeros\n                    if (decimalRegEx.test(formatStr.split(\".\")[1])) {\n                        isValid = true;\n                    }\n                }\n                return isValid;\n            }\n        }\n\n        /* Function identifies temporal data type based on fomrat string\n         * Possible values: Date, Time, DateTime, \"\"\n         * if format was not resolved retun \"\"\n         */\n        static getTemporalTypeFromFormat(format) {\n            let isDate,\n                isTime,\n                type = \"\";\n\n            if (format) {\n                //symbols appear only in date format\n                isDate = /[M,Y,D,d,Q]/.test(format) ? true : false;\n                //symbols appear only in time format\n                isTime = /[H,h,k,m,S,s]/.test(format) ? true : false;\n                if (isDate) {\n                    type = \"Date\";\n                    if (isTime) {\n                        type = \"DateTime\";\n                    }\n                } else if (isTime) {\n                    type = \"Time\";\n                }\n            }\n            return type;\n        }\n\n        /*Treat all column names as regex\n         * @param columnId {string} - Column id or regEx\n         * @param allColumnIds {Array<string>} - domain of columns to search in\n         * @return validColumns {Array<string>} - valid columns selected by regex\n         */\n        static regExValidateColumnIDs(columnId, allColumnIds) {\n            //convert string to regEx\n            const rgxString =\n                columnId.indexOf(\"/\") == 0\n                    ? columnId.substring(1)\n                    : \"^\" + columnId.replace(/\\*/g, \"(.*)\") + \"$\";\n            const regExpX = new RegExp(rgxString);\n            const validColumns = _.filter(allColumnIds, function(col) {\n                return col.match(regExpX);\n            });\n            return validColumns;\n        }\n    }\n}\n","/// <reference path=\"../lib/dash-client-lib.ts\" />\r\n/// <reference path=\"../lib/delta-client-lib.ts\" />\r\n/// <reference path=\"../lib/error-tooltip.ts\" />\r\n/// <reference path=\"../lib/genericTooltip.ts\" />\r\n/// <reference path=\"../lib/helpers.ts\" />\r\n/// <reference path=\"../classes/quickbase.ts\" />\r\n/// <reference path=\"../lib/tools.ts\" />\r\n/// <reference path=\"../classes/RTTI.ts\" />\r\n/// <reference path=\"../lib/ipc/Util.ts\" />\r\n/// <reference path=\"../lib/jquery.cookie.ts\" />\r\n/// <reference path=\"../lib/jsbn.ts\" />\r\n\r\n/// <reference path=\"../models/component.ts\" />\r\n/// <reference path=\"../models/componentDefinition.ts\" />\r\n/// <reference path=\"../models/connection.ts\" />\r\n/// <reference path=\"../models/connectionGroup.ts\" />\r\n/// <reference path=\"../models/service.ts\" />\r\n/// <reference path=\"../models/document.ts\" />\r\n/// <reference path=\"../models/documentDataModel.ts\" />\r\n/// <reference path=\"../models/documentViewModel.ts\" />\r\n/// <reference path=\"../models/layout.ts\" />\r\n/// <reference path=\"../models/popup.ts\" />\r\n/// <reference path=\"../models/screen.ts\" />\r\n/// <reference path=\"../models/widget.ts\" />\r\n/// <reference path=\"../viewModels/app.ts\" />\r\n\r\n/// <reference path=\"AboutDialog.ts\" />\r\n/// <reference path=\"Accordion.ts\" />\r\n/// <reference path=\"AppView.ts\" />\r\n/// <reference path=\"AreYouSureDialog.ts\" />\r\n/// <reference path=\"ChangePasswordDialog.ts\" />\r\n/// <reference path=\"ConfirmDialog.ts\" />\r\n/// <reference path=\"DialogBase.ts\" />\r\n/// <reference path=\"ComponentView.ts\" />\r\n/// <reference path=\"ComponentDropView.ts\" />\r\n/// <reference path=\"DocumentSelector.ts\" />\r\n/// <reference path=\"DocumentView.ts\" />\r\n/// <reference path=\"LoginDialog.ts\" />\r\n/// <reference path=\"HeuristicHelpers.ts\" />\r\n/// <reference path=\"ProfileMenu.ts\" />\r\n/// <reference path=\"PopupView.ts\" />\r\n\r\n/// <reference path=\"../export/ExportTools.ts\" />\r\n/// <reference path=\"../classes/NotificationManager.ts\"/>\r\n\r\nQuickBase[\"BigInteger\"] = jsbn.BigInteger;\r\n\r\n/*\r\nvar App = {\r\n    //handling Long type\r\n    \"BigInteger\": jsbn.BigInteger,\r\n\r\n    // Lib\r\n    \"DashClient\": DashClient,\r\n    \"DashClientLib\": DashClientLib,\r\n    \"DeltaClientLib\": DeltaClientLib,\r\n    \"ErrorTooltip\": ErrorTooltip,\r\n    \"Helpers\": Helpers,\r\n    \"InitializeQuickbase\": InitializeQuickbase,\r\n    \"Log\": Log,\r\n\r\n    // Models and Collections\r\n    \"AppViewModel\": AppViewModel,\r\n    \"Component\": Component,\r\n    \"ComponentCollection\": ComponentCollection,\r\n    \"ComponentDefinition\": ComponentDefinition,\r\n    \"ComponentDefinitionCollection\": ComponentDefinitionCollection,\r\n    \"ComponentOptions\": ComponentOptions,\r\n    \"Connection\": Connection,\r\n    \"ConnectionCollection\": ConnectionCollection,\r\n    \"ConnectionGroup\": ConnectionGroup,\r\n    \"ConnectionGroupCollection\": ConnectionGroupCollection,\r\n    \"Service\": Service,\r\n    \"ServiceCollection\": ServiceCollection,\r\n    \"Document\": Dash,\r\n    \"DocumentCollection\": DashCollection,\r\n    \"DocumentDataModel\": DocumentDataModel,\r\n    \"DocumentViewModel\": DocumentViewModel,\r\n    \"Layout\": Layout,\r\n    \"Popup\" : Popup,\r\n    \"PopupCollection\" : PopupCollection,\r\n    \"Screen\": DashScreen,\r\n    \"ScreenCollection\": DashScreenCollection,\r\n    \"Widget\": Widget,\r\n    \"WidgetCollection\": WidgetCollection,\r\n\r\n    // Views\r\n    \"AboutDialog\": AboutDialog,\r\n    \"AccordionView\": AccordionView,\r\n    \"AppView\": AppView,\r\n    \"AreYouSureDialog\": AreYouSureDialog,\r\n    \"SimpleInputDialog\": SimpleInputDialog,\r\n    \"DialogBase\": DialogBase,\r\n    \"ErrorDialog\": ErrorDialog,\r\n    \"ChangePasswordDialog\": ChangePasswordDialog,\r\n    \"ComponentView\": ComponentView,\r\n    \"ConfirmDialog\": ConfirmDialog,\r\n    \"ComponentDropView\": ComponentDropView,\r\n    \"DocumentView\": DocumentView,\r\n    \"DocumentGraph\": DocumentGraph,\r\n    \"DocumentSelector\": DocumentSelector,\r\n    \"HelpDialog\": HelpDialog,\r\n    \"LoginDialog\": LoginDialog,\r\n    \"MainToolbarBaseView\": MainToolbarBaseView,\r\n    \"ProfileMenu\": ProfileMenu,\r\n    \"PopupView\": PopupView,\r\n    // Temporary Library\r\n    \"y\r\n    \": ExportConverterTools,\r\n    \"NotificationManager\": NotificationManager,\r\n    // Util libs\r\n    \"Tools\": Tools,\r\n    \"RTTI\": RTTI,\r\n    \"ipc\": ipc\r\n};*/\r\n\r\n// Extend cookies or set defaults\r\nconst cookies = {\r\n    language: $.cookie(\"dashboard-language\") || \"en\",\r\n    logLevel: $.cookie(\"dashboard-log-level\") || 1,\r\n    theme: $.cookie(\"dashboard-theme\") || \"kx-darkroom\",\r\n    viewerTheme: $.cookie(\"dashboard-viewer-theme\") || \"kx-darkroom\",\r\n};\r\n\r\n// this is set on login now in delta-client-base.js\r\n$.cookie(\"dashboard-language\", cookies.language, { expires: 30, path: \"/\" });\r\n$.cookie(\"dashboard-log-level\", cookies.logLevel, { expires: 30, path: \"/\" });\r\n$.cookie(\"dashboard-theme\", cookies.theme, { expires: 30, path: \"/\" });\r\n$.cookie(\"dashboard-viewer-theme\", cookies.viewerTheme, { expires: 30, path: \"/\" });\r\n\r\n//FIX: KXAX-7082 overwrite default Backbone's decodeFragment() which uses decodeURI\r\n_.extend(Backbone.History.prototype, {\r\n    decodeFragment: function(fragment) {\r\n        return fragment;\r\n    },\r\n});\r\n","/*!\n * jQuery Cookie Plugin v1.4.1\n * https://github.com/carhartl/jquery-cookie\n *\n * Copyright 2013 Klaus Hartl\n * Released under the MIT license\n */\n(function ($) {\n\n\tvar pluses = /\\+/g;\n\n\tfunction encode(s) {\n\t\treturn encodeURIComponent(s);\n\t}\n\n\tfunction decode(s) {\n\t\treturn decodeURIComponent(s);\n\t}\n\n\tfunction stringifyCookieValue(value) {\n\t\treturn encode(String(value));\n\t}\n\n\tfunction parseCookieValue(s) {\n\t\tif (s.indexOf('\"') === 0) {\n\t\t\t// This is a quoted cookie as according to RFC2068, unescape...\n\t\t\ts = s.slice(1, -1).replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, '\\\\');\n\t\t}\n\n\t\ttry {\n\t\t\t// Replace server-side written pluses with spaces.\n\t\t\t// If we can't decode the cookie, ignore it, it's unusable.\n\t\t\t// If we can't parse the cookie, ignore it, it's unusable.\n\t\t\ts = decodeURIComponent(s.replace(pluses, ' '));\n\t\t\treturn s;\n\t\t} catch(e) {}\n\t}\n\n\tfunction read(s, converter?) {\n\t\tvar value = parseCookieValue(s);\n\t\treturn $.isFunction(converter) ? converter(value) : value;\n\t}\n\n\t$.cookie = function (key: string, value?: any, options?: JQueryCookieOptions) {\n\n\t\t// Write\n\n\t\tif (value !== undefined && !$.isFunction(value)) {\n\t\t\toptions = $.extend({}, options);\n\n\t\t\tif (typeof options.expires === 'number') {\n\t\t\t\tvar days = options.expires, t = options.expires = new Date();\n\t\t\t\tt.setTime(+t + days * 864e+5);\n\t\t\t}\n\n\t\t\treturn (document.cookie = [\n\t\t\t\tencode(key), '=', stringifyCookieValue(value),\n\t\t\t\toptions.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE\n\t\t\t\toptions.path    ? '; path=' + options.path : '',\n\t\t\t\toptions.domain  ? '; domain=' + options.domain : '',\n\t\t\t\toptions.secure  ? '; secure' : ''\n\t\t\t].join(''));\n\t\t}\n\n\t\t// Read\n\n\t\tvar result = key ? undefined : {};\n\n\t\t// To prevent the for loop in the first place assign an empty array\n\t\t// in case there are no cookies at all. Also prevents odd result when\n\t\t// calling $.cookie().\n\t\tvar cookies = document.cookie ? document.cookie.split('; ') : [];\n\n\t\tfor (var i = 0, l = cookies.length; i < l; i++) {\n\t\t\tvar parts = cookies[i].split('=');\n\t\t\tvar name = decode(parts.shift());\n\t\t\tvar cookie = parts.join('=');\n\n\t\t\tif (key && key === name) {\n\t\t\t\t// If second argument (value) is a function it's a converter...\n\t\t\t\tresult = read(cookie, value);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Prevent storing a cookie that we couldn't decode.\n\t\t\tif (!key && (cookie = read(cookie)) !== undefined) {\n\t\t\t\tresult[name] = cookie;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t} as JQueryCookieStatic;\n\n\t$.removeCookie = function (key: string, options?: JQueryCookieOptions): boolean {\n\t\tif ($.cookie(key) === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Must not alter options, thus extending a fresh object...\n\t\t$.cookie(key, '', $.extend({}, options, { expires: -1 }));\n\t\treturn !$.cookie(key);\n\t};\n\n})($);\n"],"sourceRoot":"/home/devadmin/ui-node/workspace/boardsForKx_kx-platform-461-BIUTER4DCW6NKG3S2ISL6W2UZXERPH7HZ62EPPJCBYR7WX5S56WQ/dash-core/QuickBase"}